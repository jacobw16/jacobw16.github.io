{"id":"node_modules/@tensorflow/tfjs-layers/dist/common.js","dependencies":[{"name":"C:\\Users\\Jacob\\Documents\\jump(3)\\scripts\\node_modules\\@tensorflow\\tfjs-layers\\dist\\common.js.map","includedInParent":true,"mtime":499162500000},{"name":"C:\\Users\\Jacob\\Documents\\jump(3)\\scripts\\node_modules\\@tensorflow\\tfjs-layers\\src\\common.ts","includedInParent":true,"mtime":499162500000},{"name":"C:\\Users\\Jacob\\Documents\\jump(3)\\scripts\\package.json","includedInParent":true,"mtime":1581030063848},{"name":"C:\\Users\\Jacob\\Documents\\jump(3)\\scripts\\node_modules\\@tensorflow\\tfjs-layers\\package.json","includedInParent":true,"mtime":1581030261368},{"name":"./keras_format/common","loc":{"line":15,"column":23},"parent":"C:\\Users\\Jacob\\Documents\\jump(3)\\scripts\\node_modules\\@tensorflow\\tfjs-layers\\dist\\common.js","resolved":"C:\\Users\\Jacob\\Documents\\jump(3)\\scripts\\node_modules\\@tensorflow\\tfjs-layers\\dist\\keras_format\\common.js"},{"name":"./utils/generic_utils","loc":{"line":16,"column":30},"parent":"C:\\Users\\Jacob\\Documents\\jump(3)\\scripts\\node_modules\\@tensorflow\\tfjs-layers\\dist\\common.js","resolved":"C:\\Users\\Jacob\\Documents\\jump(3)\\scripts\\node_modules\\@tensorflow\\tfjs-layers\\dist\\utils\\generic_utils.js"}],"generated":{"js":"\"use strict\";\n/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Common functions for TensorFlow.js Layers.\n */\nvar common_1 = require(\"./keras_format/common\");\nvar generic_utils_1 = require(\"./utils/generic_utils\");\n// A map from the requested scoped name of a Tensor to the number of Tensors\n// wanting that name so far.  This allows enforcing name uniqueness by appending\n// an incrementing index, e.g. scope/name, scope/name_1, scope/name_2, etc.\nvar nameMap = new Map();\nfunction checkDataFormat(value) {\n    generic_utils_1.checkStringTypeUnionValue(common_1.VALID_DATA_FORMAT_VALUES, 'DataFormat', value);\n}\nexports.checkDataFormat = checkDataFormat;\nfunction checkPaddingMode(value) {\n    generic_utils_1.checkStringTypeUnionValue(common_1.VALID_PADDING_MODE_VALUES, 'PaddingMode', value);\n}\nexports.checkPaddingMode = checkPaddingMode;\nfunction checkPoolMode(value) {\n    generic_utils_1.checkStringTypeUnionValue(common_1.VALID_POOL_MODE_VALUES, 'PoolMode', value);\n}\nexports.checkPoolMode = checkPoolMode;\nvar _nameScopeStack = [];\nvar _nameScopeDivider = '/';\n/**\n * Enter namescope, which can be nested.\n */\nfunction nameScope(name, fn) {\n    _nameScopeStack.push(name);\n    try {\n        var val = fn();\n        _nameScopeStack.pop();\n        return val;\n    }\n    catch (e) {\n        _nameScopeStack.pop();\n        throw e;\n    }\n}\nexports.nameScope = nameScope;\n/**\n * Get the current namescope as a flat, concatenated string.\n */\nfunction currentNameScopePrefix() {\n    if (_nameScopeStack.length === 0) {\n        return '';\n    }\n    else {\n        return _nameScopeStack.join(_nameScopeDivider) + _nameScopeDivider;\n    }\n}\n/**\n * Get the name a Tensor (or Variable) would have if not uniqueified.\n * @param tensorName\n * @return Scoped name string.\n */\nfunction getScopedTensorName(tensorName) {\n    if (!isValidTensorName(tensorName)) {\n        throw new Error('Not a valid tensor name: \\'' + tensorName + '\\'');\n    }\n    return currentNameScopePrefix() + tensorName;\n}\nexports.getScopedTensorName = getScopedTensorName;\n/**\n * Get unique names for Tensors and Variables.\n * @param scopedName The fully-qualified name of the Tensor, i.e. as produced by\n *  `getScopedTensorName()`.\n * @return A unique version of the given fully scoped name.\n *   If this is the first time that the scoped name is seen in this session,\n *   then the given `scopedName` is returned unaltered.  If the same name is\n *   seen again (producing a collision), an incrementing suffix is added to the\n *   end of the name, so it takes the form 'scope/name_1', 'scope/name_2', etc.\n */\nfunction getUniqueTensorName(scopedName) {\n    if (!isValidTensorName(scopedName)) {\n        throw new Error('Not a valid tensor name: \\'' + scopedName + '\\'');\n    }\n    if (!nameMap.has(scopedName)) {\n        nameMap.set(scopedName, 0);\n    }\n    var index = nameMap.get(scopedName);\n    nameMap.set(scopedName, nameMap.get(scopedName) + 1);\n    if (index > 0) {\n        var result = scopedName + \"_\" + index;\n        // Mark the composed name as used in case someone wants\n        // to call getUniqueTensorName(\"name_1\").\n        nameMap.set(result, 1);\n        return result;\n    }\n    else {\n        return scopedName;\n    }\n}\nexports.getUniqueTensorName = getUniqueTensorName;\nvar tensorNameRegex = new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\\._\\/]*$/);\n/**\n * Determine whether a string is a valid tensor name.\n * @param name\n * @returns A Boolean indicating whether `name` is a valid tensor name.\n */\nfunction isValidTensorName(name) {\n    return !!name.match(tensorNameRegex);\n}\nexports.isValidTensorName = isValidTensorName;\n"},"sourceMaps":{"js":{"version":3,"file":"common.js","sourceRoot":"","sources":["../src/common.ts"],"names":[],"mappings":";AAAA;;;;;;;;GAQG;;AAEH;;GAEG;AACH,gDAAkH;AAClH,uDAAgE;AAEhE,4EAA4E;AAC5E,gFAAgF;AAChF,2EAA2E;AAC3E,IAAM,OAAO,GAAwB,IAAI,GAAG,EAAkB,CAAC;AAE/D,SAAgB,eAAe,CAAC,KAAc;IAC5C,yCAAyB,CAAC,iCAAwB,EAAE,YAAY,EAAE,KAAK,CAAC,CAAC;AAC3E,CAAC;AAFD,0CAEC;AAED,SAAgB,gBAAgB,CAAC,KAAc;IAC7C,yCAAyB,CAAC,kCAAyB,EAAE,aAAa,EAAE,KAAK,CAAC,CAAC;AAC7E,CAAC;AAFD,4CAEC;AAED,SAAgB,aAAa,CAAC,KAAc;IAC1C,yCAAyB,CAAC,+BAAsB,EAAE,UAAU,EAAE,KAAK,CAAC,CAAC;AACvE,CAAC;AAFD,sCAEC;AAED,IAAM,eAAe,GAAa,EAAE,CAAC;AACrC,IAAM,iBAAiB,GAAG,GAAG,CAAC;AAE9B;;GAEG;AACH,SAAgB,SAAS,CAAI,IAAY,EAAE,EAAW;IACpD,eAAe,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IAC3B,IAAI;QACF,IAAM,GAAG,GAAM,EAAE,EAAE,CAAC;QACpB,eAAe,CAAC,GAAG,EAAE,CAAC;QACtB,OAAO,GAAG,CAAC;KACZ;IAAC,OAAO,CAAC,EAAE;QACV,eAAe,CAAC,GAAG,EAAE,CAAC;QACtB,MAAM,CAAC,CAAC;KACT;AACH,CAAC;AAVD,8BAUC;AAED;;GAEG;AACH,SAAS,sBAAsB;IAC7B,IAAI,eAAe,CAAC,MAAM,KAAK,CAAC,EAAE;QAChC,OAAO,EAAE,CAAC;KACX;SAAM;QACL,OAAO,eAAe,CAAC,IAAI,CAAC,iBAAiB,CAAC,GAAG,iBAAiB,CAAC;KACpE;AACH,CAAC;AAED;;;;GAIG;AACH,SAAgB,mBAAmB,CAAC,UAAkB;IACpD,IAAI,CAAC,iBAAiB,CAAC,UAAU,CAAC,EAAE;QAClC,MAAM,IAAI,KAAK,CAAC,6BAA6B,GAAG,UAAU,GAAG,IAAI,CAAC,CAAC;KACpE;IACD,OAAO,sBAAsB,EAAE,GAAG,UAAU,CAAC;AAC/C,CAAC;AALD,kDAKC;AAED;;;;;;;;;GASG;AACH,SAAgB,mBAAmB,CAAC,UAAkB;IACpD,IAAI,CAAC,iBAAiB,CAAC,UAAU,CAAC,EAAE;QAClC,MAAM,IAAI,KAAK,CAAC,6BAA6B,GAAG,UAAU,GAAG,IAAI,CAAC,CAAC;KACpE;IACD,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,UAAU,CAAC,EAAE;QAC5B,OAAO,CAAC,GAAG,CAAC,UAAU,EAAE,CAAC,CAAC,CAAC;KAC5B;IACD,IAAM,KAAK,GAAG,OAAO,CAAC,GAAG,CAAC,UAAU,CAAC,CAAC;IACtC,OAAO,CAAC,GAAG,CAAC,UAAU,EAAE,OAAO,CAAC,GAAG,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC,CAAC;IAErD,IAAI,KAAK,GAAG,CAAC,EAAE;QACb,IAAM,MAAM,GAAM,UAAU,SAAI,KAAO,CAAC;QACxC,uDAAuD;QACvD,yCAAyC;QACzC,OAAO,CAAC,GAAG,CAAC,MAAM,EAAE,CAAC,CAAC,CAAC;QACvB,OAAO,MAAM,CAAC;KACf;SAAM;QACL,OAAO,UAAU,CAAC;KACnB;AACH,CAAC;AAnBD,kDAmBC;AAED,IAAM,eAAe,GAAG,IAAI,MAAM,CAAC,iCAAiC,CAAC,CAAC;AAEtE;;;;GAIG;AACH,SAAgB,iBAAiB,CAAC,IAAY;IAC5C,OAAO,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,eAAe,CAAC,CAAC;AACvC,CAAC;AAFD,8CAEC","sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n\n/**\n * Common functions for TensorFlow.js Layers.\n */\nimport {VALID_DATA_FORMAT_VALUES, VALID_PADDING_MODE_VALUES, VALID_POOL_MODE_VALUES} from './keras_format/common';\nimport {checkStringTypeUnionValue} from './utils/generic_utils';\n\n// A map from the requested scoped name of a Tensor to the number of Tensors\n// wanting that name so far.  This allows enforcing name uniqueness by appending\n// an incrementing index, e.g. scope/name, scope/name_1, scope/name_2, etc.\nconst nameMap: Map<string, number> = new Map<string, number>();\n\nexport function checkDataFormat(value?: string): void {\n  checkStringTypeUnionValue(VALID_DATA_FORMAT_VALUES, 'DataFormat', value);\n}\n\nexport function checkPaddingMode(value?: string): void {\n  checkStringTypeUnionValue(VALID_PADDING_MODE_VALUES, 'PaddingMode', value);\n}\n\nexport function checkPoolMode(value?: string): void {\n  checkStringTypeUnionValue(VALID_POOL_MODE_VALUES, 'PoolMode', value);\n}\n\nconst _nameScopeStack: string[] = [];\nconst _nameScopeDivider = '/';\n\n/**\n * Enter namescope, which can be nested.\n */\nexport function nameScope<T>(name: string, fn: () => T): T {\n  _nameScopeStack.push(name);\n  try {\n    const val: T = fn();\n    _nameScopeStack.pop();\n    return val;\n  } catch (e) {\n    _nameScopeStack.pop();\n    throw e;\n  }\n}\n\n/**\n * Get the current namescope as a flat, concatenated string.\n */\nfunction currentNameScopePrefix(): string {\n  if (_nameScopeStack.length === 0) {\n    return '';\n  } else {\n    return _nameScopeStack.join(_nameScopeDivider) + _nameScopeDivider;\n  }\n}\n\n/**\n * Get the name a Tensor (or Variable) would have if not uniqueified.\n * @param tensorName\n * @return Scoped name string.\n */\nexport function getScopedTensorName(tensorName: string): string {\n  if (!isValidTensorName(tensorName)) {\n    throw new Error('Not a valid tensor name: \\'' + tensorName + '\\'');\n  }\n  return currentNameScopePrefix() + tensorName;\n}\n\n/**\n * Get unique names for Tensors and Variables.\n * @param scopedName The fully-qualified name of the Tensor, i.e. as produced by\n *  `getScopedTensorName()`.\n * @return A unique version of the given fully scoped name.\n *   If this is the first time that the scoped name is seen in this session,\n *   then the given `scopedName` is returned unaltered.  If the same name is\n *   seen again (producing a collision), an incrementing suffix is added to the\n *   end of the name, so it takes the form 'scope/name_1', 'scope/name_2', etc.\n */\nexport function getUniqueTensorName(scopedName: string): string {\n  if (!isValidTensorName(scopedName)) {\n    throw new Error('Not a valid tensor name: \\'' + scopedName + '\\'');\n  }\n  if (!nameMap.has(scopedName)) {\n    nameMap.set(scopedName, 0);\n  }\n  const index = nameMap.get(scopedName);\n  nameMap.set(scopedName, nameMap.get(scopedName) + 1);\n\n  if (index > 0) {\n    const result = `${scopedName}_${index}`;\n    // Mark the composed name as used in case someone wants\n    // to call getUniqueTensorName(\"name_1\").\n    nameMap.set(result, 1);\n    return result;\n  } else {\n    return scopedName;\n  }\n}\n\nconst tensorNameRegex = new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\\._\\/]*$/);\n\n/**\n * Determine whether a string is a valid tensor name.\n * @param name\n * @returns A Boolean indicating whether `name` is a valid tensor name.\n */\nexport function isValidTensorName(name: string): boolean {\n  return !!name.match(tensorNameRegex);\n}\n"]}},"error":null,"hash":"4b04d2b2796ca31ec092322d0a2b5a7c","cacheData":{"env":{}}}