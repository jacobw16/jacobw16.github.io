{"id":"node_modules/@tensorflow/tfjs-layers/dist/base_callbacks.js","dependencies":[{"name":"C:\\Users\\Jacob\\Documents\\jump(3)\\scripts\\node_modules\\@tensorflow\\tfjs-layers\\dist\\base_callbacks.js.map","includedInParent":true,"mtime":499162500000},{"name":"C:\\Users\\Jacob\\Documents\\jump(3)\\scripts\\node_modules\\@tensorflow\\tfjs-layers\\src\\base_callbacks.ts","includedInParent":true,"mtime":499162500000},{"name":"C:\\Users\\Jacob\\Documents\\jump(3)\\scripts\\package.json","includedInParent":true,"mtime":1581896610560},{"name":"C:\\Users\\Jacob\\Documents\\jump(3)\\scripts\\node_modules\\@tensorflow\\tfjs-layers\\package.json","includedInParent":true,"mtime":1581030261368},{"name":"@tensorflow/tfjs-core","loc":{"line":61,"column":26},"parent":"C:\\Users\\Jacob\\Documents\\jump(3)\\scripts\\node_modules\\@tensorflow\\tfjs-layers\\dist\\base_callbacks.js","resolved":"C:\\Users\\Jacob\\Documents\\jump(3)\\scripts\\node_modules\\@tensorflow\\tfjs-core\\dist\\tf-core.esm.js"},{"name":"./errors","loc":{"line":62,"column":23},"parent":"C:\\Users\\Jacob\\Documents\\jump(3)\\scripts\\node_modules\\@tensorflow\\tfjs-layers\\dist\\base_callbacks.js","resolved":"C:\\Users\\Jacob\\Documents\\jump(3)\\scripts\\node_modules\\@tensorflow\\tfjs-layers\\dist\\errors.js"},{"name":"./logs","loc":{"line":63,"column":21},"parent":"C:\\Users\\Jacob\\Documents\\jump(3)\\scripts\\node_modules\\@tensorflow\\tfjs-layers\\dist\\base_callbacks.js","resolved":"C:\\Users\\Jacob\\Documents\\jump(3)\\scripts\\node_modules\\@tensorflow\\tfjs-layers\\dist\\logs.js"},{"name":"./utils/generic_utils","loc":{"line":64,"column":28},"parent":"C:\\Users\\Jacob\\Documents\\jump(3)\\scripts\\node_modules\\@tensorflow\\tfjs-layers\\dist\\base_callbacks.js","resolved":"C:\\Users\\Jacob\\Documents\\jump(3)\\scripts\\node_modules\\@tensorflow\\tfjs-layers\\dist\\utils\\generic_utils.js"}],"generated":{"js":"\"use strict\";\n/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/* Original source: keras/callbacks.py */\nvar tfjs_core_1 = require(\"@tensorflow/tfjs-core\");\nvar errors_1 = require(\"./errors\");\nvar logs_1 = require(\"./logs\");\nvar generic_utils = require(\"./utils/generic_utils\");\n/** Verbosity logging level when fitting a model. */\nvar ModelLoggingVerbosity;\n(function (ModelLoggingVerbosity) {\n    ModelLoggingVerbosity[ModelLoggingVerbosity[\"SILENT\"] = 0] = \"SILENT\";\n    ModelLoggingVerbosity[ModelLoggingVerbosity[\"VERBOSE\"] = 1] = \"VERBOSE\";\n})(ModelLoggingVerbosity = exports.ModelLoggingVerbosity || (exports.ModelLoggingVerbosity = {}));\n/** How often to yield to the main thread when training (in ms). */\nexports.DEFAULT_YIELD_EVERY_MS = 125;\n/**\n * Abstract base class used to build new callbacks.\n *\n * The `logs` dictionary that callback methods take as argument will contain\n * keys for quantities relevant to the current batch or epoch.\n *\n * Currently, the `.fit()` method of the `Sequential` model class\n * will include the following quantities in the `logs` that\n * it passes to its callbacks:\n *\n * onEpochEnd: Logs include `acc` and `loss`, and optionally include `valLoss`\n *   (if validation is enabled in `fit`), and `valAcc` (if validation and\n *   accuracy monitoring are enabled).\n * onBatchBegin: Logs include `size`, the number of samples in the current\n *   batch.\n * onBatchEnd: Logs include `loss`, and optionally `acc` (if accuracy monitoring\n *   is enabled).\n */\nvar BaseCallback = /** @class */ (function () {\n    function BaseCallback() {\n        // TODO(michaelterry): This type is a best guess.\n        this.validationData = null;\n    }\n    BaseCallback.prototype.setParams = function (params) {\n        this.params = params;\n    };\n    BaseCallback.prototype.onEpochBegin = function (epoch, logs) {\n        return __awaiter(this, void 0, void 0, function () { return __generator(this, function (_a) {\n            return [2 /*return*/];\n        }); });\n    };\n    BaseCallback.prototype.onEpochEnd = function (epoch, logs) {\n        return __awaiter(this, void 0, void 0, function () { return __generator(this, function (_a) {\n            return [2 /*return*/];\n        }); });\n    };\n    BaseCallback.prototype.onBatchBegin = function (batch, logs) {\n        return __awaiter(this, void 0, void 0, function () { return __generator(this, function (_a) {\n            return [2 /*return*/];\n        }); });\n    };\n    BaseCallback.prototype.onBatchEnd = function (batch, logs) {\n        return __awaiter(this, void 0, void 0, function () { return __generator(this, function (_a) {\n            return [2 /*return*/];\n        }); });\n    };\n    BaseCallback.prototype.onTrainBegin = function (logs) {\n        return __awaiter(this, void 0, void 0, function () { return __generator(this, function (_a) {\n            return [2 /*return*/];\n        }); });\n    };\n    BaseCallback.prototype.onTrainEnd = function (logs) {\n        return __awaiter(this, void 0, void 0, function () { return __generator(this, function (_a) {\n            return [2 /*return*/];\n        }); });\n    };\n    // LayersModel needs to call Callback.setModel(), but cannot actually depend\n    // on Callback because that creates a cyclic dependency.  Providing this no-op\n    // method on BaseCallback breaks the cycle: this way LayersModel can depend on\n    // BaseCallback but not on Callback.  The argument is typed as `Container`\n    // (the superclass of LayersModel) to avoid recapitulating the cycle. Callback\n    // overrides this method and enforces that the argument is really a\n    // LayersModel.\n    BaseCallback.prototype.setModel = function (model) {\n        // Do nothing. Use Callback instead of BaseCallback to track the model.\n    };\n    return BaseCallback;\n}());\nexports.BaseCallback = BaseCallback;\n/**\n * Container abstracting a list of callbacks.\n */\nvar CallbackList = /** @class */ (function () {\n    // TODO(cais): When the need arises, uncomment the following lines and\n    // implement the queue for time values.\n    // private deltaTBatch: number;\n    // private deltaTsBatchBegin: Array<number>;\n    // private deltaTsBatchEnd: Array<number>;\n    /**\n     * Constructor of CallbackList.\n     * @param callbacks Array of `Callback` instances.\n     * @param queueLength Queue length for keeping running statistics over\n     *   callback execution time.\n     */\n    function CallbackList(callbacks, queueLength) {\n        if (queueLength === void 0) { queueLength = 10; }\n        // TODO(cais): Make use of queueLength when implementing the queue for time\n        // values.\n        if (callbacks == null) {\n            callbacks = [];\n        }\n        this.callbacks = callbacks;\n        this.queueLength = queueLength;\n    }\n    CallbackList.prototype.append = function (callback) {\n        this.callbacks.push(callback);\n    };\n    CallbackList.prototype.setParams = function (params) {\n        for (var _i = 0, _a = this.callbacks; _i < _a.length; _i++) {\n            var callback = _a[_i];\n            callback.setParams(params);\n        }\n    };\n    CallbackList.prototype.setModel = function (model) {\n        for (var _i = 0, _a = this.callbacks; _i < _a.length; _i++) {\n            var callback = _a[_i];\n            callback.setModel(model);\n        }\n    };\n    /**\n     * Called at the start of an epoch.\n     * @param epoch Index of epoch.\n     * @param logs Dictionary of logs.\n     */\n    CallbackList.prototype.onEpochBegin = function (epoch, logs) {\n        return __awaiter(this, void 0, void 0, function () {\n            var _i, _a, callback;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        if (logs == null) {\n                            logs = {};\n                        }\n                        _i = 0, _a = this.callbacks;\n                        _b.label = 1;\n                    case 1:\n                        if (!(_i < _a.length)) return [3 /*break*/, 4];\n                        callback = _a[_i];\n                        return [4 /*yield*/, callback.onEpochBegin(epoch, logs)];\n                    case 2:\n                        _b.sent();\n                        _b.label = 3;\n                    case 3:\n                        _i++;\n                        return [3 /*break*/, 1];\n                    case 4: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * Called at the end of an epoch.\n     * @param epoch Index of epoch.\n     * @param logs Dictionary of logs.\n     */\n    CallbackList.prototype.onEpochEnd = function (epoch, logs) {\n        return __awaiter(this, void 0, void 0, function () {\n            var _i, _a, callback;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        if (logs == null) {\n                            logs = {};\n                        }\n                        _i = 0, _a = this.callbacks;\n                        _b.label = 1;\n                    case 1:\n                        if (!(_i < _a.length)) return [3 /*break*/, 4];\n                        callback = _a[_i];\n                        return [4 /*yield*/, callback.onEpochEnd(epoch, logs)];\n                    case 2:\n                        _b.sent();\n                        _b.label = 3;\n                    case 3:\n                        _i++;\n                        return [3 /*break*/, 1];\n                    case 4: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * Called  right before processing a batch.\n     * @param batch Index of batch within the current epoch.\n     * @param logs Dictionary of logs.\n     */\n    CallbackList.prototype.onBatchBegin = function (batch, logs) {\n        return __awaiter(this, void 0, void 0, function () {\n            var _i, _a, callback;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        if (logs == null) {\n                            logs = {};\n                        }\n                        _i = 0, _a = this.callbacks;\n                        _b.label = 1;\n                    case 1:\n                        if (!(_i < _a.length)) return [3 /*break*/, 4];\n                        callback = _a[_i];\n                        return [4 /*yield*/, callback.onBatchBegin(batch, logs)];\n                    case 2:\n                        _b.sent();\n                        _b.label = 3;\n                    case 3:\n                        _i++;\n                        return [3 /*break*/, 1];\n                    case 4: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * Called at the end of a batch.\n     * @param batch Index of batch within the current epoch.\n     * @param logs Dictionary of logs.\n     */\n    CallbackList.prototype.onBatchEnd = function (batch, logs) {\n        return __awaiter(this, void 0, void 0, function () {\n            var _i, _a, callback;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        if (logs == null) {\n                            logs = {};\n                        }\n                        _i = 0, _a = this.callbacks;\n                        _b.label = 1;\n                    case 1:\n                        if (!(_i < _a.length)) return [3 /*break*/, 4];\n                        callback = _a[_i];\n                        return [4 /*yield*/, callback.onBatchEnd(batch, logs)];\n                    case 2:\n                        _b.sent();\n                        _b.label = 3;\n                    case 3:\n                        _i++;\n                        return [3 /*break*/, 1];\n                    case 4: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * Called at the beginning of training.\n     * @param logs Dictionary of logs.\n     */\n    CallbackList.prototype.onTrainBegin = function (logs) {\n        return __awaiter(this, void 0, void 0, function () {\n            var _i, _a, callback;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        if (logs == null) {\n                            logs = {};\n                        }\n                        _i = 0, _a = this.callbacks;\n                        _b.label = 1;\n                    case 1:\n                        if (!(_i < _a.length)) return [3 /*break*/, 4];\n                        callback = _a[_i];\n                        return [4 /*yield*/, callback.onTrainBegin(logs)];\n                    case 2:\n                        _b.sent();\n                        _b.label = 3;\n                    case 3:\n                        _i++;\n                        return [3 /*break*/, 1];\n                    case 4: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * Called at the end of training.\n     * @param logs Dictionary of logs.\n     */\n    CallbackList.prototype.onTrainEnd = function (logs) {\n        return __awaiter(this, void 0, void 0, function () {\n            var _i, _a, callback;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        if (logs == null) {\n                            logs = {};\n                        }\n                        _i = 0, _a = this.callbacks;\n                        _b.label = 1;\n                    case 1:\n                        if (!(_i < _a.length)) return [3 /*break*/, 4];\n                        callback = _a[_i];\n                        return [4 /*yield*/, callback.onTrainEnd(logs)];\n                    case 2:\n                        _b.sent();\n                        _b.label = 3;\n                    case 3:\n                        _i++;\n                        return [3 /*break*/, 1];\n                    case 4: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    return CallbackList;\n}());\nexports.CallbackList = CallbackList;\n/**\n * Callback that accumulates epoch averages of metrics.\n *\n * This callback is automatically applied to every LayersModel.\n */\nvar BaseLogger = /** @class */ (function (_super) {\n    __extends(BaseLogger, _super);\n    function BaseLogger() {\n        return _super.call(this) || this;\n    }\n    BaseLogger.prototype.onEpochBegin = function (epoch) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                this.seen = 0;\n                this.totals = {};\n                return [2 /*return*/];\n            });\n        });\n    };\n    BaseLogger.prototype.onBatchEnd = function (batch, logs) {\n        return __awaiter(this, void 0, void 0, function () {\n            var batchSize, _loop_1, this_1, key;\n            var _this = this;\n            return __generator(this, function (_a) {\n                if (logs == null) {\n                    logs = {};\n                }\n                batchSize = logs['size'] == null ? 0 : logs['size'];\n                this.seen += batchSize;\n                _loop_1 = function (key) {\n                    var value = logs[key];\n                    if (typeof value === 'number') {\n                        if (!this_1.totals.hasOwnProperty(key)) {\n                            this_1.totals[key] = 0;\n                        }\n                        this_1.totals[key] = this_1.totals[key] + value * batchSize;\n                    }\n                    else {\n                        var oldTotalsToDispose = void 0;\n                        if (key in this_1.totals) {\n                            oldTotalsToDispose = this_1.totals[key];\n                        }\n                        else {\n                            this_1.totals[key] = 0;\n                        }\n                        var total = tfjs_core_1.tidy(function () { return tfjs_core_1.add((_this.totals[key]), tfjs_core_1.mul(value, batchSize)); });\n                        this_1.totals[key] = total;\n                        if (oldTotalsToDispose != null) {\n                            oldTotalsToDispose.dispose();\n                        }\n                    }\n                };\n                this_1 = this;\n                for (key in logs) {\n                    _loop_1(key);\n                }\n                return [2 /*return*/];\n            });\n        });\n    };\n    BaseLogger.prototype.onEpochEnd = function (epoch, logs) {\n        return __awaiter(this, void 0, void 0, function () {\n            var _loop_2, this_2, _i, _a, key;\n            var _this = this;\n            return __generator(this, function (_b) {\n                if (logs != null) {\n                    _loop_2 = function (key) {\n                        if (this_2.totals[key] == null) {\n                            return \"continue\";\n                        }\n                        if (typeof this_2.totals[key] === 'number') {\n                            logs[key] = this_2.totals[key] / this_2.seen;\n                        }\n                        else {\n                            tfjs_core_1.tidy(function () {\n                                var log = tfjs_core_1.mul(tfjs_core_1.div(1, _this.seen), _this.totals[key]);\n                                logs[key] = log;\n                                _this.totals[key].dispose();\n                                tfjs_core_1.keep(logs[key]);\n                            });\n                        }\n                    };\n                    this_2 = this;\n                    for (_i = 0, _a = this.params['metrics']; _i < _a.length; _i++) {\n                        key = _a[_i];\n                        _loop_2(key);\n                    }\n                }\n                return [2 /*return*/];\n            });\n        });\n    };\n    return BaseLogger;\n}(BaseCallback));\nexports.BaseLogger = BaseLogger;\n/**\n * Callback that records events into a `History` object. This callback is\n * automatically applied to every TF.js Layers model. The `History` object\n * gets returned by the `fit` method of models.\n */\nvar History = /** @class */ (function (_super) {\n    __extends(History, _super);\n    function History() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    History.prototype.onTrainBegin = function (logs) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                this.epoch = [];\n                this.history = {};\n                return [2 /*return*/];\n            });\n        });\n    };\n    History.prototype.onEpochEnd = function (epoch, logs) {\n        return __awaiter(this, void 0, void 0, function () {\n            var key;\n            return __generator(this, function (_a) {\n                if (logs == null) {\n                    logs = {};\n                }\n                this.epoch.push(epoch);\n                for (key in logs) {\n                    if (this.history[key] == null) {\n                        this.history[key] = [];\n                    }\n                    this.history[key].push(logs[key]);\n                }\n                return [2 /*return*/];\n            });\n        });\n    };\n    /**\n     * Await the values of all losses and metrics.\n     */\n    History.prototype.syncData = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var promises, keys, indices, key, valueArray, i, valueScalar, values, n, tensorToDispose;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        promises = [];\n                        keys = [];\n                        indices = [];\n                        for (key in this.history) {\n                            valueArray = this.history[key];\n                            for (i = 0; i < valueArray.length; ++i) {\n                                if (typeof valueArray[i] !== 'number') {\n                                    valueScalar = valueArray[i];\n                                    promises.push(valueScalar.data());\n                                    keys.push(key);\n                                    indices.push(i);\n                                }\n                            }\n                        }\n                        return [4 /*yield*/, Promise.all(promises)];\n                    case 1:\n                        values = _a.sent();\n                        for (n = 0; n < values.length; ++n) {\n                            tensorToDispose = this.history[keys[n]][indices[n]];\n                            tensorToDispose.dispose();\n                            this.history[keys[n]][indices[n]] = values[n][0];\n                        }\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    return History;\n}(BaseCallback));\nexports.History = History;\n/**\n * Custom callback for training.\n */\nvar CustomCallback = /** @class */ (function (_super) {\n    __extends(CustomCallback, _super);\n    function CustomCallback(args, yieldEvery) {\n        var _this = _super.call(this) || this;\n        _this.currentEpoch = 0;\n        _this.yieldEvery = yieldEvery || 'auto';\n        if (_this.yieldEvery === 'auto') {\n            _this.yieldEvery = exports.DEFAULT_YIELD_EVERY_MS;\n        }\n        if (_this.yieldEvery === 'never' && args.onYield != null) {\n            throw new Error('yieldEvery is `never` but you provided an `onYield` callback. ' +\n                'Either change `yieldEvery` or remove the callback');\n        }\n        if (tfjs_core_1.util.isNumber(_this.yieldEvery)) {\n            // Decorate `maybeWait` so it will be called at most once every\n            // `yieldEvery` ms.\n            _this.maybeWait = generic_utils.debounce(_this.maybeWait.bind(_this), _this.yieldEvery);\n        }\n        _this.trainBegin = args.onTrainBegin;\n        _this.trainEnd = args.onTrainEnd;\n        _this.epochBegin = args.onEpochBegin;\n        _this.epochEnd = args.onEpochEnd;\n        _this.batchBegin = args.onBatchBegin;\n        _this.batchEnd = args.onBatchEnd;\n        _this.yield = args.onYield;\n        return _this;\n    }\n    CustomCallback.prototype.maybeWait = function (epoch, batch, logs) {\n        return __awaiter(this, void 0, void 0, function () {\n            var ps;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        ps = [];\n                        if (!(this.yield != null)) return [3 /*break*/, 2];\n                        return [4 /*yield*/, logs_1.resolveScalarsInLogs(logs)];\n                    case 1:\n                        _a.sent();\n                        ps.push(this.yield(epoch, batch, logs));\n                        _a.label = 2;\n                    case 2:\n                        ps.push(tfjs_core_1.nextFrame());\n                        return [4 /*yield*/, Promise.all(ps)];\n                    case 3:\n                        _a.sent();\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    CustomCallback.prototype.onEpochBegin = function (epoch, logs) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        this.currentEpoch = epoch;\n                        if (!(this.epochBegin != null)) return [3 /*break*/, 3];\n                        return [4 /*yield*/, logs_1.resolveScalarsInLogs(logs)];\n                    case 1:\n                        _a.sent();\n                        return [4 /*yield*/, this.epochBegin(epoch, logs)];\n                    case 2:\n                        _a.sent();\n                        _a.label = 3;\n                    case 3: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    CustomCallback.prototype.onEpochEnd = function (epoch, logs) {\n        return __awaiter(this, void 0, void 0, function () {\n            var ps;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        ps = [];\n                        if (!(this.epochEnd != null)) return [3 /*break*/, 2];\n                        return [4 /*yield*/, logs_1.resolveScalarsInLogs(logs)];\n                    case 1:\n                        _a.sent();\n                        ps.push(this.epochEnd(epoch, logs));\n                        _a.label = 2;\n                    case 2:\n                        if (this.yieldEvery === 'epoch') {\n                            ps.push(tfjs_core_1.nextFrame());\n                        }\n                        return [4 /*yield*/, Promise.all(ps)];\n                    case 3:\n                        _a.sent();\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    CustomCallback.prototype.onBatchBegin = function (batch, logs) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (!(this.batchBegin != null)) return [3 /*break*/, 3];\n                        return [4 /*yield*/, logs_1.resolveScalarsInLogs(logs)];\n                    case 1:\n                        _a.sent();\n                        return [4 /*yield*/, this.batchBegin(batch, logs)];\n                    case 2:\n                        _a.sent();\n                        _a.label = 3;\n                    case 3: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    CustomCallback.prototype.onBatchEnd = function (batch, logs) {\n        return __awaiter(this, void 0, void 0, function () {\n            var ps;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        ps = [];\n                        if (!(this.batchEnd != null)) return [3 /*break*/, 2];\n                        return [4 /*yield*/, logs_1.resolveScalarsInLogs(logs)];\n                    case 1:\n                        _a.sent();\n                        ps.push(this.batchEnd(batch, logs));\n                        _a.label = 2;\n                    case 2:\n                        if (this.yieldEvery === 'batch') {\n                            ps.push(tfjs_core_1.nextFrame());\n                        }\n                        else if (tfjs_core_1.util.isNumber(this.yieldEvery)) {\n                            ps.push(this.maybeWait(this.currentEpoch, batch, logs));\n                        }\n                        return [4 /*yield*/, Promise.all(ps)];\n                    case 3:\n                        _a.sent();\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    CustomCallback.prototype.onTrainBegin = function (logs) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (!(this.trainBegin != null)) return [3 /*break*/, 3];\n                        return [4 /*yield*/, logs_1.resolveScalarsInLogs(logs)];\n                    case 1:\n                        _a.sent();\n                        return [4 /*yield*/, this.trainBegin(logs)];\n                    case 2:\n                        _a.sent();\n                        _a.label = 3;\n                    case 3: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    CustomCallback.prototype.onTrainEnd = function (logs) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (!(this.trainEnd != null)) return [3 /*break*/, 3];\n                        return [4 /*yield*/, logs_1.resolveScalarsInLogs(logs)];\n                    case 1:\n                        _a.sent();\n                        return [4 /*yield*/, this.trainEnd(logs)];\n                    case 2:\n                        _a.sent();\n                        _a.label = 3;\n                    case 3: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    return CustomCallback;\n}(BaseCallback));\nexports.CustomCallback = CustomCallback;\n/**\n * Standardize callbacks or configurations of them to an Array of callbacks.\n */\nfunction standardizeCallbacks(callbacks, yieldEvery) {\n    if (callbacks == null) {\n        callbacks = {};\n    }\n    if (callbacks instanceof BaseCallback) {\n        return [callbacks];\n    }\n    if (Array.isArray(callbacks) && callbacks[0] instanceof BaseCallback) {\n        return callbacks;\n    }\n    // Convert custom callback configs to custom callback objects.\n    var callbackConfigs = generic_utils.toList(callbacks);\n    return callbackConfigs.map(function (callbackConfig) { return new CustomCallback(callbackConfig, yieldEvery); });\n}\nexports.standardizeCallbacks = standardizeCallbacks;\n/**\n * A global registry for callback constructors to be used during\n * LayersModel.fit().\n */\nvar CallbackConstructorRegistry = /** @class */ (function () {\n    /**\n     * Blocks public access to constructor.\n     */\n    function CallbackConstructorRegistry() {\n    }\n    /**\n     * Register a tf.LayersModel.fit() callback constructor.\n     *\n     * The registered callback constructor will be used to instantiate\n     * callbacks for every tf.LayersModel.fit() call afterwards.\n     *\n     * @param verbosityLevel Level of verbosity at which the `callbackConstructor`\n     *   is to be reigstered.\n     * @param callbackConstructor A no-arg constructor for `tf.Callback`.\n     * @throws Error, if the same callbackConstructor has been registered before,\n     *   either at the same or a different `verbosityLevel`.\n     */\n    CallbackConstructorRegistry.registerCallbackConstructor = function (verbosityLevel, callbackConstructor) {\n        tfjs_core_1.util.assert(verbosityLevel >= 0 && Number.isInteger(verbosityLevel), function () { return \"Verbosity level is expected to be an integer >= 0, \" +\n            (\"but got \" + verbosityLevel); });\n        CallbackConstructorRegistry.checkForDuplicate(callbackConstructor);\n        if (CallbackConstructorRegistry.constructors[verbosityLevel] == null) {\n            CallbackConstructorRegistry.constructors[verbosityLevel] = [];\n        }\n        CallbackConstructorRegistry.constructors[verbosityLevel].push(callbackConstructor);\n    };\n    CallbackConstructorRegistry.checkForDuplicate = function (callbackConstructor) {\n        for (var levelName in CallbackConstructorRegistry.constructors) {\n            var constructors = CallbackConstructorRegistry.constructors[+levelName];\n            constructors.forEach(function (ctor) {\n                if (ctor === callbackConstructor) {\n                    throw new errors_1.ValueError('Duplicate callback constructor.');\n                }\n            });\n        }\n    };\n    /**\n     * Clear all registered callback constructors.\n     */\n    CallbackConstructorRegistry.clear = function () {\n        CallbackConstructorRegistry.constructors = {};\n    };\n    /**\n     * Create callbacks using the registered callback constructors.\n     *\n     * Given `verbosityLevel`, all constructors registered at that level or above\n     * will be called and the instantiated callbacks will be used.\n     *\n     * @param verbosityLevel: Level of verbosity.\n     */\n    CallbackConstructorRegistry.createCallbacks = function (verbosityLevel) {\n        var constructors = [];\n        for (var levelName in CallbackConstructorRegistry.constructors) {\n            var level = +levelName;\n            if (verbosityLevel >= level) {\n                constructors.push.apply(constructors, CallbackConstructorRegistry.constructors[level]);\n            }\n        }\n        return constructors.map(function (ctor) { return new ctor(); });\n    };\n    CallbackConstructorRegistry.constructors = {};\n    return CallbackConstructorRegistry;\n}());\nexports.CallbackConstructorRegistry = CallbackConstructorRegistry;\nfunction configureCallbacks(callbacks, verbose, epochs, initialEpoch, numTrainSamples, stepsPerEpoch, batchSize, doValidation, callbackMetrics) {\n    var history = new History();\n    var actualCallbacks = [\n        new BaseLogger()\n    ].concat(CallbackConstructorRegistry.createCallbacks(verbose));\n    if (callbacks != null) {\n        actualCallbacks.push.apply(actualCallbacks, callbacks);\n    }\n    actualCallbacks.push(history);\n    var callbackList = new CallbackList(actualCallbacks);\n    // TODO(cais): Figure out when this LayersModel instance can have a\n    // dynamically\n    //   set property called 'callback_model' as in PyKeras.\n    callbackList.setParams({\n        epochs: epochs,\n        initialEpoch: initialEpoch,\n        samples: numTrainSamples,\n        steps: stepsPerEpoch,\n        batchSize: batchSize,\n        verbose: verbose,\n        doValidation: doValidation,\n        metrics: callbackMetrics,\n    });\n    return { callbackList: callbackList, history: history };\n}\nexports.configureCallbacks = configureCallbacks;\n"},"sourceMaps":{"js":{"version":3,"file":"base_callbacks.js","sourceRoot":"","sources":["../src/base_callbacks.ts"],"names":[],"mappings":";AAAA;;;;;;;;GAQG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEH,yCAAyC;AAEzC,mDAAiG;AAGjG,mCAAoC;AACpC,+BAAkE;AAClE,qDAAuD;AAEvD,oDAAoD;AACpD,IAAY,qBAGX;AAHD,WAAY,qBAAqB;IAC/B,qEAAU,CAAA;IACV,uEAAW,CAAA;AACb,CAAC,EAHW,qBAAqB,GAArB,6BAAqB,KAArB,6BAAqB,QAGhC;AAED,mEAAmE;AACtD,QAAA,sBAAsB,GAAG,GAAG,CAAC;AAQ1C;;;;;;;;;;;;;;;;;GAiBG;AACH;IAAA;QACE,iDAAiD;QACjD,mBAAc,GAAoB,IAAI,CAAC;IAgCzC,CAAC;IA1BC,gCAAS,GAAT,UAAU,MAAc;QACtB,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;IACvB,CAAC;IAEK,mCAAY,GAAlB,UAAmB,KAAa,EAAE,IAAqB;;;;KAAI;IAErD,iCAAU,GAAhB,UAAiB,KAAa,EAAE,IAAqB;;;;KAAI;IAEnD,mCAAY,GAAlB,UAAmB,KAAa,EAAE,IAAqB;;;;KAAI;IAErD,iCAAU,GAAhB,UAAiB,KAAa,EAAE,IAAqB;;;;KAAI;IAEnD,mCAAY,GAAlB,UAAmB,IAAqB;;;;KAAI;IAEtC,iCAAU,GAAhB,UAAiB,IAAqB;;;;KAAI;IAE1C,4EAA4E;IAC5E,8EAA8E;IAC9E,8EAA8E;IAC9E,0EAA0E;IAC1E,8EAA8E;IAC9E,mEAAmE;IACnE,eAAe;IACf,+BAAQ,GAAR,UAAS,KAAgB;QACvB,uEAAuE;IACzE,CAAC;IACH,mBAAC;AAAD,CAAC,AAlCD,IAkCC;AAlCqB,oCAAY;AAoClC;;GAEG;AACH;IAIE,sEAAsE;IACtE,uCAAuC;IACvC,+BAA+B;IAC/B,4CAA4C;IAC5C,0CAA0C;IAE1C;;;;;OAKG;IACH,sBAAY,SAA0B,EAAE,WAAgB;QAAhB,4BAAA,EAAA,gBAAgB;QACtD,2EAA2E;QAC3E,UAAU;QACV,IAAI,SAAS,IAAI,IAAI,EAAE;YACrB,SAAS,GAAG,EAAE,CAAC;SAChB;QACD,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;QAC3B,IAAI,CAAC,WAAW,GAAG,WAAW,CAAC;IACjC,CAAC;IAED,6BAAM,GAAN,UAAO,QAAsB;QAC3B,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;IAChC,CAAC;IAED,gCAAS,GAAT,UAAU,MAAc;QACtB,KAAuB,UAAc,EAAd,KAAA,IAAI,CAAC,SAAS,EAAd,cAAc,EAAd,IAAc,EAAE;YAAlC,IAAM,QAAQ,SAAA;YACjB,QAAQ,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC;SAC5B;IACH,CAAC;IAED,+BAAQ,GAAR,UAAS,KAAgB;QACvB,KAAuB,UAAc,EAAd,KAAA,IAAI,CAAC,SAAS,EAAd,cAAc,EAAd,IAAc,EAAE;YAAlC,IAAM,QAAQ,SAAA;YACjB,QAAQ,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;SAC1B;IACH,CAAC;IAED;;;;OAIG;IACG,mCAAY,GAAlB,UAAmB,KAAa,EAAE,IAAqB;;;;;;wBACrD,IAAI,IAAI,IAAI,IAAI,EAAE;4BAChB,IAAI,GAAG,EAAE,CAAC;yBACX;8BACoC,EAAd,KAAA,IAAI,CAAC,SAAS;;;6BAAd,CAAA,cAAc,CAAA;wBAA1B,QAAQ;wBACjB,qBAAM,QAAQ,CAAC,YAAY,CAAC,KAAK,EAAE,IAAI,CAAC,EAAA;;wBAAxC,SAAwC,CAAC;;;wBADpB,IAAc,CAAA;;;;;;KAGtC;IAED;;;;OAIG;IACG,iCAAU,GAAhB,UAAiB,KAAa,EAAE,IAAqB;;;;;;wBACnD,IAAI,IAAI,IAAI,IAAI,EAAE;4BAChB,IAAI,GAAG,EAAE,CAAC;yBACX;8BACoC,EAAd,KAAA,IAAI,CAAC,SAAS;;;6BAAd,CAAA,cAAc,CAAA;wBAA1B,QAAQ;wBACjB,qBAAM,QAAQ,CAAC,UAAU,CAAC,KAAK,EAAE,IAAI,CAAC,EAAA;;wBAAtC,SAAsC,CAAC;;;wBADlB,IAAc,CAAA;;;;;;KAGtC;IAED;;;;OAIG;IACG,mCAAY,GAAlB,UAAmB,KAAa,EAAE,IAAqB;;;;;;wBACrD,IAAI,IAAI,IAAI,IAAI,EAAE;4BAChB,IAAI,GAAG,EAAE,CAAC;yBACX;8BACoC,EAAd,KAAA,IAAI,CAAC,SAAS;;;6BAAd,CAAA,cAAc,CAAA;wBAA1B,QAAQ;wBACjB,qBAAM,QAAQ,CAAC,YAAY,CAAC,KAAK,EAAE,IAAI,CAAC,EAAA;;wBAAxC,SAAwC,CAAC;;;wBADpB,IAAc,CAAA;;;;;;KAGtC;IAED;;;;OAIG;IACG,iCAAU,GAAhB,UAAiB,KAAa,EAAE,IAAqB;;;;;;wBACnD,IAAI,IAAI,IAAI,IAAI,EAAE;4BAChB,IAAI,GAAG,EAAE,CAAC;yBACX;8BACoC,EAAd,KAAA,IAAI,CAAC,SAAS;;;6BAAd,CAAA,cAAc,CAAA;wBAA1B,QAAQ;wBACjB,qBAAM,QAAQ,CAAC,UAAU,CAAC,KAAK,EAAE,IAAI,CAAC,EAAA;;wBAAtC,SAAsC,CAAC;;;wBADlB,IAAc,CAAA;;;;;;KAGtC;IAED;;;OAGG;IACG,mCAAY,GAAlB,UAAmB,IAAqB;;;;;;wBACtC,IAAI,IAAI,IAAI,IAAI,EAAE;4BAChB,IAAI,GAAG,EAAE,CAAC;yBACX;8BACoC,EAAd,KAAA,IAAI,CAAC,SAAS;;;6BAAd,CAAA,cAAc,CAAA;wBAA1B,QAAQ;wBACjB,qBAAM,QAAQ,CAAC,YAAY,CAAC,IAAI,CAAC,EAAA;;wBAAjC,SAAiC,CAAC;;;wBADb,IAAc,CAAA;;;;;;KAGtC;IAED;;;OAGG;IACG,iCAAU,GAAhB,UAAiB,IAAqB;;;;;;wBACpC,IAAI,IAAI,IAAI,IAAI,EAAE;4BAChB,IAAI,GAAG,EAAE,CAAC;yBACX;8BACoC,EAAd,KAAA,IAAI,CAAC,SAAS;;;6BAAd,CAAA,cAAc,CAAA;wBAA1B,QAAQ;wBACjB,qBAAM,QAAQ,CAAC,UAAU,CAAC,IAAI,CAAC,EAAA;;wBAA/B,SAA+B,CAAC;;;wBADX,IAAc,CAAA;;;;;;KAGtC;IACH,mBAAC;AAAD,CAAC,AA3HD,IA2HC;AA3HY,oCAAY;AA6HzB;;;;GAIG;AACH;IAAgC,8BAAY;IAI1C;eACE,iBAAO;IACT,CAAC;IAEK,iCAAY,GAAlB,UAAmB,KAAa;;;gBAC9B,IAAI,CAAC,IAAI,GAAG,CAAC,CAAC;gBACd,IAAI,CAAC,MAAM,GAAG,EAAE,CAAC;;;;KAClB;IAEK,+BAAU,GAAhB,UAAiB,KAAa,EAAE,IAAqB;;;;;gBACnD,IAAI,IAAI,IAAI,IAAI,EAAE;oBAChB,IAAI,GAAG,EAAE,CAAC;iBACX;gBACK,SAAS,GAAG,IAAI,CAAC,MAAM,CAAC,IAAI,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,MAAM,CAAW,CAAC;gBACpE,IAAI,CAAC,IAAI,IAAI,SAAS,CAAC;oCACZ,GAAG;oBACZ,IAAM,KAAK,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC;oBACxB,IAAI,OAAO,KAAK,KAAK,QAAQ,EAAE;wBAC7B,IAAI,CAAC,OAAK,MAAM,CAAC,cAAc,CAAC,GAAG,CAAC,EAAE;4BACpC,OAAK,MAAM,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;yBACtB;wBACD,OAAK,MAAM,CAAC,GAAG,CAAC,GAAG,OAAK,MAAM,CAAC,GAAG,CAAW,GAAG,KAAK,GAAG,SAAS,CAAC;qBACnE;yBAAM;wBACL,IAAI,kBAAkB,SAAQ,CAAC;wBAC/B,IAAI,GAAG,IAAI,OAAK,MAAM,EAAE;4BACtB,kBAAkB,GAAG,OAAK,MAAM,CAAC,GAAG,CAAW,CAAC;yBACjD;6BAAM;4BACL,OAAK,MAAM,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;yBACtB;wBACD,IAAM,KAAK,GACP,gBAAI,CAAC,cAAM,OAAA,eAAG,CAAC,CAAC,KAAI,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,EAAE,eAAG,CAAC,KAAK,EAAE,SAAS,CAAC,CAAC,EAA9C,CAA8C,CAAC,CAAC;wBAC/D,OAAK,MAAM,CAAC,GAAG,CAAC,GAAG,KAAK,CAAC;wBACzB,IAAI,kBAAkB,IAAI,IAAI,EAAE;4BAC9B,kBAAkB,CAAC,OAAO,EAAE,CAAC;yBAC9B;qBACF;;;gBApBH,KAAW,GAAG,IAAI,IAAI;4BAAX,GAAG;iBAqBb;;;;KACF;IAEK,+BAAU,GAAhB,UAAiB,KAAa,EAAE,IAAqB;;;;;gBACnD,IAAI,IAAI,IAAI,IAAI,EAAE;wCACL,GAAG;wBACZ,IAAI,OAAK,MAAM,CAAC,GAAG,CAAC,IAAI,IAAI,EAAE;;yBAE7B;wBACD,IAAI,OAAO,OAAK,MAAM,CAAC,GAAG,CAAC,KAAK,QAAQ,EAAE;4BACxC,IAAI,CAAC,GAAG,CAAC,GAAG,OAAK,MAAM,CAAC,GAAG,CAAW,GAAG,OAAK,IAAI,CAAC;yBACpD;6BAAM;4BACL,gBAAI,CAAC;gCACH,IAAM,GAAG,GAAW,eAAG,CAAC,eAAG,CAAC,CAAC,EAAE,KAAI,CAAC,IAAI,CAAC,EAAE,KAAI,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC;gCAC7D,IAAI,CAAC,GAAG,CAAC,GAAG,GAAG,CAAC;gCACf,KAAI,CAAC,MAAM,CAAC,GAAG,CAAY,CAAC,OAAO,EAAE,CAAC;gCACvC,gBAAI,CAAC,IAAI,CAAC,GAAG,CAAW,CAAC,CAAC;4BAC5B,CAAC,CAAC,CAAC;yBACJ;;;oBAbH,WAAoD,EAAlC,KAAA,IAAI,CAAC,MAAM,CAAC,SAAS,CAAa,EAAlC,cAAkC,EAAlC,IAAkC;wBAAzC,GAAG;gCAAH,GAAG;qBAcb;iBACF;;;;KACF;IACH,iBAAC;AAAD,CAAC,AA9DD,CAAgC,YAAY,GA8D3C;AA9DY,gCAAU;AAgEvB;;;;GAIG;AACH;IAA6B,2BAAY;IAAzC;;IA+CA,CAAC;IA3CO,8BAAY,GAAlB,UAAmB,IAAqB;;;gBACtC,IAAI,CAAC,KAAK,GAAG,EAAE,CAAC;gBAChB,IAAI,CAAC,OAAO,GAAG,EAAE,CAAC;;;;KACnB;IAEK,4BAAU,GAAhB,UAAiB,KAAa,EAAE,IAAqB;;;;gBACnD,IAAI,IAAI,IAAI,IAAI,EAAE;oBAChB,IAAI,GAAG,EAAE,CAAC;iBACX;gBACD,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;gBACvB,KAAW,GAAG,IAAI,IAAI,EAAE;oBACtB,IAAI,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,IAAI,IAAI,EAAE;wBAC7B,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,GAAG,EAAE,CAAC;qBACxB;oBACD,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC;iBACnC;;;;KACF;IAED;;OAEG;IACG,0BAAQ,GAAd;;;;;;wBACQ,QAAQ,GAAuD,EAAE,CAAC;wBAClE,IAAI,GAAa,EAAE,CAAC;wBACpB,OAAO,GAAa,EAAE,CAAC;wBAC7B,KAAW,GAAG,IAAI,IAAI,CAAC,OAAO,EAAE;4BACxB,UAAU,GAAG,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;4BACrC,KAAS,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,UAAU,CAAC,MAAM,EAAE,EAAE,CAAC,EAAE;gCAC1C,IAAI,OAAO,UAAU,CAAC,CAAC,CAAC,KAAK,QAAQ,EAAE;oCAC/B,WAAW,GAAG,UAAU,CAAC,CAAC,CAAW,CAAC;oCAC5C,QAAQ,CAAC,IAAI,CAAC,WAAW,CAAC,IAAI,EAAE,CAAC,CAAC;oCAClC,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;oCACf,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;iCACjB;6BACF;yBACF;wBACc,qBAAM,OAAO,CAAC,GAAG,CAAC,QAAQ,CAAC,EAAA;;wBAApC,MAAM,GAAG,SAA2B;wBAC1C,KAAS,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,CAAC,MAAM,EAAE,EAAE,CAAC,EAAE;4BAChC,eAAe,GAAG,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,CAAW,CAAC;4BACpE,eAAe,CAAC,OAAO,EAAE,CAAC;4BAC1B,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;yBAClD;;;;;KACF;IACH,cAAC;AAAD,CAAC,AA/CD,CAA6B,YAAY,GA+CxC;AA/CY,0BAAO;AA2DpB;;GAEG;AACH;IAAoC,kCAAY;IAiB9C,wBAAY,IAAwB,EAAE,UAA8B;QAApE,YACE,iBAAO,SAuBR;QA1BO,kBAAY,GAAG,CAAC,CAAC;QAIvB,KAAI,CAAC,UAAU,GAAG,UAAU,IAAI,MAAM,CAAC;QACvC,IAAI,KAAI,CAAC,UAAU,KAAK,MAAM,EAAE;YAC9B,KAAI,CAAC,UAAU,GAAG,8BAAsB,CAAC;SAC1C;QACD,IAAI,KAAI,CAAC,UAAU,KAAK,OAAO,IAAI,IAAI,CAAC,OAAO,IAAI,IAAI,EAAE;YACvD,MAAM,IAAI,KAAK,CACX,gEAAgE;gBAChE,mDAAmD,CAAC,CAAC;SAC1D;QACD,IAAI,gBAAI,CAAC,QAAQ,CAAC,KAAI,CAAC,UAAU,CAAC,EAAE;YAClC,+DAA+D;YAC/D,mBAAmB;YACnB,KAAI,CAAC,SAAS,GAAG,aAAa,CAAC,QAAQ,CACnC,KAAI,CAAC,SAAS,CAAC,IAAI,CAAC,KAAI,CAAC,EAAE,KAAI,CAAC,UAAoB,CAAC,CAAC;SAC3D;QACD,KAAI,CAAC,UAAU,GAAG,IAAI,CAAC,YAAY,CAAC;QACpC,KAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,UAAU,CAAC;QAChC,KAAI,CAAC,UAAU,GAAG,IAAI,CAAC,YAAY,CAAC;QACpC,KAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,UAAU,CAAC;QAChC,KAAI,CAAC,UAAU,GAAG,IAAI,CAAC,YAAY,CAAC;QACpC,KAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,UAAU,CAAC;QAChC,KAAI,CAAC,KAAK,GAAG,IAAI,CAAC,OAAO,CAAC;;IAC5B,CAAC;IAEK,kCAAS,GAAf,UAAgB,KAAa,EAAE,KAAa,EAAE,IAAoB;;;;;;wBAC1D,EAAE,GAA8B,EAAE,CAAC;6BACrC,CAAA,IAAI,CAAC,KAAK,IAAI,IAAI,CAAA,EAAlB,wBAAkB;wBACpB,qBAAM,2BAAoB,CAAC,IAAI,CAAC,EAAA;;wBAAhC,SAAgC,CAAC;wBACjC,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,KAAK,EAAE,KAAK,EAAE,IAAY,CAAC,CAAC,CAAC;;;wBAElD,EAAE,CAAC,IAAI,CAAC,qBAAS,EAAE,CAAC,CAAC;wBACrB,qBAAM,OAAO,CAAC,GAAG,CAAC,EAAE,CAAC,EAAA;;wBAArB,SAAqB,CAAC;;;;;KACvB;IAEK,qCAAY,GAAlB,UAAmB,KAAa,EAAE,IAAqB;;;;;wBACrD,IAAI,CAAC,YAAY,GAAG,KAAK,CAAC;6BACtB,CAAA,IAAI,CAAC,UAAU,IAAI,IAAI,CAAA,EAAvB,wBAAuB;wBACzB,qBAAM,2BAAoB,CAAC,IAAI,CAAC,EAAA;;wBAAhC,SAAgC,CAAC;wBACjC,qBAAM,IAAI,CAAC,UAAU,CAAC,KAAK,EAAE,IAAY,CAAC,EAAA;;wBAA1C,SAA0C,CAAC;;;;;;KAE9C;IAEK,mCAAU,GAAhB,UAAiB,KAAa,EAAE,IAAqB;;;;;;wBAC7C,EAAE,GAA8B,EAAE,CAAC;6BACrC,CAAA,IAAI,CAAC,QAAQ,IAAI,IAAI,CAAA,EAArB,wBAAqB;wBACvB,qBAAM,2BAAoB,CAAC,IAAI,CAAC,EAAA;;wBAAhC,SAAgC,CAAC;wBACjC,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,KAAK,EAAE,IAAY,CAAC,CAAC,CAAC;;;wBAE9C,IAAI,IAAI,CAAC,UAAU,KAAK,OAAO,EAAE;4BAC/B,EAAE,CAAC,IAAI,CAAC,qBAAS,EAAE,CAAC,CAAC;yBACtB;wBACD,qBAAM,OAAO,CAAC,GAAG,CAAC,EAAE,CAAC,EAAA;;wBAArB,SAAqB,CAAC;;;;;KACvB;IAEK,qCAAY,GAAlB,UAAmB,KAAa,EAAE,IAAqB;;;;;6BACjD,CAAA,IAAI,CAAC,UAAU,IAAI,IAAI,CAAA,EAAvB,wBAAuB;wBACzB,qBAAM,2BAAoB,CAAC,IAAI,CAAC,EAAA;;wBAAhC,SAAgC,CAAC;wBACjC,qBAAM,IAAI,CAAC,UAAU,CAAC,KAAK,EAAE,IAAY,CAAC,EAAA;;wBAA1C,SAA0C,CAAC;;;;;;KAE9C;IAEK,mCAAU,GAAhB,UAAiB,KAAa,EAAE,IAAqB;;;;;;wBAC7C,EAAE,GAA8B,EAAE,CAAC;6BACrC,CAAA,IAAI,CAAC,QAAQ,IAAI,IAAI,CAAA,EAArB,wBAAqB;wBACvB,qBAAM,2BAAoB,CAAC,IAAI,CAAC,EAAA;;wBAAhC,SAAgC,CAAC;wBACjC,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,KAAK,EAAE,IAAY,CAAC,CAAC,CAAC;;;wBAE9C,IAAI,IAAI,CAAC,UAAU,KAAK,OAAO,EAAE;4BAC/B,EAAE,CAAC,IAAI,CAAC,qBAAS,EAAE,CAAC,CAAC;yBACtB;6BAAM,IAAI,gBAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,UAAU,CAAC,EAAE;4BACzC,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,YAAY,EAAE,KAAK,EAAE,IAAI,CAAC,CAAC,CAAC;yBACzD;wBACD,qBAAM,OAAO,CAAC,GAAG,CAAC,EAAE,CAAC,EAAA;;wBAArB,SAAqB,CAAC;;;;;KACvB;IAEK,qCAAY,GAAlB,UAAmB,IAAqB;;;;;6BAClC,CAAA,IAAI,CAAC,UAAU,IAAI,IAAI,CAAA,EAAvB,wBAAuB;wBACzB,qBAAM,2BAAoB,CAAC,IAAI,CAAC,EAAA;;wBAAhC,SAAgC,CAAC;wBACjC,qBAAM,IAAI,CAAC,UAAU,CAAC,IAAY,CAAC,EAAA;;wBAAnC,SAAmC,CAAC;;;;;;KAEvC;IAEK,mCAAU,GAAhB,UAAiB,IAAqB;;;;;6BAChC,CAAA,IAAI,CAAC,QAAQ,IAAI,IAAI,CAAA,EAArB,wBAAqB;wBACvB,qBAAM,2BAAoB,CAAC,IAAI,CAAC,EAAA;;wBAAhC,SAAgC,CAAC;wBACjC,qBAAM,IAAI,CAAC,QAAQ,CAAC,IAAY,CAAC,EAAA;;wBAAjC,SAAiC,CAAC;;;;;;KAErC;IACH,qBAAC;AAAD,CAAC,AA3GD,CAAoC,YAAY,GA2G/C;AA3GY,wCAAc;AA6G3B;;GAEG;AACH,SAAgB,oBAAoB,CAChC,SACoB,EACpB,UAA6B;IAC/B,IAAI,SAAS,IAAI,IAAI,EAAE;QACrB,SAAS,GAAG,EAAkB,CAAC;KAChC;IACD,IAAI,SAAS,YAAY,YAAY,EAAE;QACrC,OAAO,CAAC,SAAS,CAAC,CAAC;KACpB;IACD,IAAI,KAAK,CAAC,OAAO,CAAC,SAAS,CAAC,IAAI,SAAS,CAAC,CAAC,CAAC,YAAY,YAAY,EAAE;QACpE,OAAO,SAA2B,CAAC;KACpC;IACD,8DAA8D;IAC9D,IAAM,eAAe,GACjB,aAAa,CAAC,MAAM,CAAC,SAAS,CAAyB,CAAC;IAC5D,OAAO,eAAe,CAAC,GAAG,CACtB,UAAA,cAAc,IAAI,OAAA,IAAI,cAAc,CAAC,cAAc,EAAE,UAAU,CAAC,EAA9C,CAA8C,CAAC,CAAC;AACxE,CAAC;AAlBD,oDAkBC;AAMD;;;GAGG;AACH;IAIE;;OAEG;IACH;IAAuB,CAAC;IAExB;;;;;;;;;;;OAWG;IACI,uDAA2B,GAAlC,UACI,cAAsB,EAAE,mBAA4C;QACtE,gBAAI,CAAC,MAAM,CACP,cAAc,IAAI,CAAC,IAAI,MAAM,CAAC,SAAS,CAAC,cAAc,CAAC,EACvD,cAAM,OAAA,qDAAqD;aACvD,aAAW,cAAgB,CAAA,EADzB,CACyB,CAAC,CAAC;QACrC,2BAA2B,CAAC,iBAAiB,CAAC,mBAAmB,CAAC,CAAC;QACnE,IAAI,2BAA2B,CAAC,YAAY,CAAC,cAAc,CAAC,IAAI,IAAI,EAAE;YACpE,2BAA2B,CAAC,YAAY,CAAC,cAAc,CAAC,GAAG,EAAE,CAAC;SAC/D;QACD,2BAA2B,CAAC,YAAY,CAAC,cAAc,CAAC,CAAC,IAAI,CACzD,mBAAmB,CAAC,CAAC;IAC3B,CAAC;IAEc,6CAAiB,GAAhC,UAAiC,mBAC2B;QAC1D,KAAK,IAAM,SAAS,IAAI,2BAA2B,CAAC,YAAY,EAAE;YAChE,IAAM,YAAY,GAAG,2BAA2B,CAAC,YAAY,CAAC,CAAC,SAAS,CAAC,CAAC;YAC1E,YAAY,CAAC,OAAO,CAAC,UAAA,IAAI;gBACvB,IAAI,IAAI,KAAK,mBAAmB,EAAE;oBAChC,MAAM,IAAI,mBAAU,CAAC,iCAAiC,CAAC,CAAC;iBACzD;YACH,CAAC,CAAC,CAAC;SACJ;IACH,CAAC;IAED;;OAEG;IACc,iCAAK,GAAtB;QACE,2BAA2B,CAAC,YAAY,GAAG,EAAE,CAAC;IAChD,CAAC;IAED;;;;;;;OAOG;IACI,2CAAe,GAAtB,UAAuB,cAAsB;QAC3C,IAAM,YAAY,GAA8B,EAAE,CAAC;QACnD,KAAK,IAAM,SAAS,IAAI,2BAA2B,CAAC,YAAY,EAAE;YAChE,IAAM,KAAK,GAAG,CAAC,SAAS,CAAC;YACzB,IAAI,cAAc,IAAI,KAAK,EAAE;gBAC3B,YAAY,CAAC,IAAI,OAAjB,YAAY,EAAS,2BAA2B,CAAC,YAAY,CAAC,KAAK,CAAC,EAAE;aACvE;SACF;QACD,OAAO,YAAY,CAAC,GAAG,CAAC,UAAA,IAAI,IAAI,OAAA,IAAI,IAAI,EAAE,EAAV,CAAU,CAAC,CAAC;IAC9C,CAAC;IAtEc,wCAAY,GACiC,EAAE,CAAC;IAsEjE,kCAAC;CAAA,AAxED,IAwEC;AAxEY,kEAA2B;AA0ExC,SAAgB,kBAAkB,CAC9B,SAAyB,EAAE,OAA8B,EAAE,MAAc,EACzE,YAAoB,EAAE,eAAuB,EAAE,aAAqB,EACpE,SAAiB,EAAE,YAAqB,EACxC,eAAyB;IAC3B,IAAM,OAAO,GAAG,IAAI,OAAO,EAAE,CAAC;IAC9B,IAAM,eAAe;QACnB,IAAI,UAAU,EAAE;aAAK,2BAA2B,CAAC,eAAe,CAAC,OAAO,CAAC,CAC1E,CAAC;IACF,IAAI,SAAS,IAAI,IAAI,EAAE;QACrB,eAAe,CAAC,IAAI,OAApB,eAAe,EAAS,SAAS,EAAE;KACpC;IACD,eAAe,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;IAC9B,IAAM,YAAY,GAAG,IAAI,YAAY,CAAC,eAAe,CAAC,CAAC;IAEvD,mEAAmE;IACnE,cAAc;IACd,wDAAwD;IAExD,YAAY,CAAC,SAAS,CAAC;QACrB,MAAM,QAAA;QACN,YAAY,cAAA;QACZ,OAAO,EAAE,eAAe;QACxB,KAAK,EAAE,aAAa;QACpB,SAAS,WAAA;QACT,OAAO,SAAA;QACP,YAAY,cAAA;QACZ,OAAO,EAAE,eAAe;KACzB,CAAC,CAAC;IACH,OAAO,EAAC,YAAY,cAAA,EAAE,OAAO,SAAA,EAAC,CAAC;AACjC,CAAC;AA9BD,gDA8BC","sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n\n/* Original source: keras/callbacks.py */\n\nimport {add, div, keep, mul, nextFrame, Scalar, Tensor, tidy, util} from '@tensorflow/tfjs-core';\n\nimport {Container} from './engine/container';\nimport {ValueError} from './errors';\nimport {Logs, resolveScalarsInLogs, UnresolvedLogs} from './logs';\nimport * as generic_utils from './utils/generic_utils';\n\n/** Verbosity logging level when fitting a model. */\nexport enum ModelLoggingVerbosity {\n  SILENT = 0,\n  VERBOSE = 1\n}\n\n/** How often to yield to the main thread when training (in ms). */\nexport const DEFAULT_YIELD_EVERY_MS = 125;\n\nexport type Params = {\n  [key: string]: number|string|boolean|number[]|string[]|boolean[];\n};\n\nexport type YieldEveryOptions = 'auto'|'batch'|'epoch'|'never'|number;\n\n/**\n * Abstract base class used to build new callbacks.\n *\n * The `logs` dictionary that callback methods take as argument will contain\n * keys for quantities relevant to the current batch or epoch.\n *\n * Currently, the `.fit()` method of the `Sequential` model class\n * will include the following quantities in the `logs` that\n * it passes to its callbacks:\n *\n * onEpochEnd: Logs include `acc` and `loss`, and optionally include `valLoss`\n *   (if validation is enabled in `fit`), and `valAcc` (if validation and\n *   accuracy monitoring are enabled).\n * onBatchBegin: Logs include `size`, the number of samples in the current\n *   batch.\n * onBatchEnd: Logs include `loss`, and optionally `acc` (if accuracy monitoring\n *   is enabled).\n */\nexport abstract class BaseCallback {\n  // TODO(michaelterry): This type is a best guess.\n  validationData: Tensor|Tensor[] = null;\n  /**\n   * Training parameters (eg. verbosity, batch size, number of epochs...).\n   */\n  params: Params;\n\n  setParams(params: Params): void {\n    this.params = params;\n  }\n\n  async onEpochBegin(epoch: number, logs?: UnresolvedLogs) {}\n\n  async onEpochEnd(epoch: number, logs?: UnresolvedLogs) {}\n\n  async onBatchBegin(batch: number, logs?: UnresolvedLogs) {}\n\n  async onBatchEnd(batch: number, logs?: UnresolvedLogs) {}\n\n  async onTrainBegin(logs?: UnresolvedLogs) {}\n\n  async onTrainEnd(logs?: UnresolvedLogs) {}\n\n  // LayersModel needs to call Callback.setModel(), but cannot actually depend\n  // on Callback because that creates a cyclic dependency.  Providing this no-op\n  // method on BaseCallback breaks the cycle: this way LayersModel can depend on\n  // BaseCallback but not on Callback.  The argument is typed as `Container`\n  // (the superclass of LayersModel) to avoid recapitulating the cycle. Callback\n  // overrides this method and enforces that the argument is really a\n  // LayersModel.\n  setModel(model: Container): void {\n    // Do nothing. Use Callback instead of BaseCallback to track the model.\n  }\n}\n\n/**\n * Container abstracting a list of callbacks.\n */\nexport class CallbackList {\n  callbacks: BaseCallback[];\n  queueLength: number;\n\n  // TODO(cais): When the need arises, uncomment the following lines and\n  // implement the queue for time values.\n  // private deltaTBatch: number;\n  // private deltaTsBatchBegin: Array<number>;\n  // private deltaTsBatchEnd: Array<number>;\n\n  /**\n   * Constructor of CallbackList.\n   * @param callbacks Array of `Callback` instances.\n   * @param queueLength Queue length for keeping running statistics over\n   *   callback execution time.\n   */\n  constructor(callbacks?: BaseCallback[], queueLength = 10) {\n    // TODO(cais): Make use of queueLength when implementing the queue for time\n    // values.\n    if (callbacks == null) {\n      callbacks = [];\n    }\n    this.callbacks = callbacks;\n    this.queueLength = queueLength;\n  }\n\n  append(callback: BaseCallback): void {\n    this.callbacks.push(callback);\n  }\n\n  setParams(params: Params): void {\n    for (const callback of this.callbacks) {\n      callback.setParams(params);\n    }\n  }\n\n  setModel(model: Container): void {\n    for (const callback of this.callbacks) {\n      callback.setModel(model);\n    }\n  }\n\n  /**\n   * Called at the start of an epoch.\n   * @param epoch Index of epoch.\n   * @param logs Dictionary of logs.\n   */\n  async onEpochBegin(epoch: number, logs?: UnresolvedLogs) {\n    if (logs == null) {\n      logs = {};\n    }\n    for (const callback of this.callbacks) {\n      await callback.onEpochBegin(epoch, logs);\n    }\n  }\n\n  /**\n   * Called at the end of an epoch.\n   * @param epoch Index of epoch.\n   * @param logs Dictionary of logs.\n   */\n  async onEpochEnd(epoch: number, logs?: UnresolvedLogs) {\n    if (logs == null) {\n      logs = {};\n    }\n    for (const callback of this.callbacks) {\n      await callback.onEpochEnd(epoch, logs);\n    }\n  }\n\n  /**\n   * Called  right before processing a batch.\n   * @param batch Index of batch within the current epoch.\n   * @param logs Dictionary of logs.\n   */\n  async onBatchBegin(batch: number, logs?: UnresolvedLogs) {\n    if (logs == null) {\n      logs = {};\n    }\n    for (const callback of this.callbacks) {\n      await callback.onBatchBegin(batch, logs);\n    }\n  }\n\n  /**\n   * Called at the end of a batch.\n   * @param batch Index of batch within the current epoch.\n   * @param logs Dictionary of logs.\n   */\n  async onBatchEnd(batch: number, logs?: UnresolvedLogs) {\n    if (logs == null) {\n      logs = {};\n    }\n    for (const callback of this.callbacks) {\n      await callback.onBatchEnd(batch, logs);\n    }\n  }\n\n  /**\n   * Called at the beginning of training.\n   * @param logs Dictionary of logs.\n   */\n  async onTrainBegin(logs?: UnresolvedLogs) {\n    if (logs == null) {\n      logs = {};\n    }\n    for (const callback of this.callbacks) {\n      await callback.onTrainBegin(logs);\n    }\n  }\n\n  /**\n   * Called at the end of training.\n   * @param logs Dictionary of logs.\n   */\n  async onTrainEnd(logs?: UnresolvedLogs) {\n    if (logs == null) {\n      logs = {};\n    }\n    for (const callback of this.callbacks) {\n      await callback.onTrainEnd(logs);\n    }\n  }\n}\n\n/**\n * Callback that accumulates epoch averages of metrics.\n *\n * This callback is automatically applied to every LayersModel.\n */\nexport class BaseLogger extends BaseCallback {\n  private seen: number;\n  private totals: UnresolvedLogs;\n\n  constructor() {\n    super();\n  }\n\n  async onEpochBegin(epoch: number) {\n    this.seen = 0;\n    this.totals = {};\n  }\n\n  async onBatchEnd(batch: number, logs?: UnresolvedLogs) {\n    if (logs == null) {\n      logs = {};\n    }\n    const batchSize = logs['size'] == null ? 0 : logs['size'] as number;\n    this.seen += batchSize;\n    for (const key in logs) {\n      const value = logs[key];\n      if (typeof value === 'number') {\n        if (!this.totals.hasOwnProperty(key)) {\n          this.totals[key] = 0;\n        }\n        this.totals[key] = this.totals[key] as number + value * batchSize;\n      } else {\n        let oldTotalsToDispose: Scalar;\n        if (key in this.totals) {\n          oldTotalsToDispose = this.totals[key] as Scalar;\n        } else {\n          this.totals[key] = 0;\n        }\n        const total: Scalar =\n            tidy(() => add((this.totals[key]), mul(value, batchSize)));\n        this.totals[key] = total;\n        if (oldTotalsToDispose != null) {\n          oldTotalsToDispose.dispose();\n        }\n      }\n    }\n  }\n\n  async onEpochEnd(epoch: number, logs?: UnresolvedLogs) {\n    if (logs != null) {\n      for (const key of this.params['metrics'] as string[]) {\n        if (this.totals[key] == null) {\n          continue;\n        }\n        if (typeof this.totals[key] === 'number') {\n          logs[key] = this.totals[key] as number / this.seen;\n        } else {\n          tidy(() => {\n            const log: Scalar = mul(div(1, this.seen), this.totals[key]);\n            logs[key] = log;\n            (this.totals[key] as Tensor).dispose();\n            keep(logs[key] as Scalar);\n          });\n        }\n      }\n    }\n  }\n}\n\n/**\n * Callback that records events into a `History` object. This callback is\n * automatically applied to every TF.js Layers model. The `History` object\n * gets returned by the `fit` method of models.\n */\nexport class History extends BaseCallback {\n  epoch: number[];\n  history: {[key: string]: Array<number|Tensor>};\n\n  async onTrainBegin(logs?: UnresolvedLogs) {\n    this.epoch = [];\n    this.history = {};\n  }\n\n  async onEpochEnd(epoch: number, logs?: UnresolvedLogs) {\n    if (logs == null) {\n      logs = {};\n    }\n    this.epoch.push(epoch);\n    for (const key in logs) {\n      if (this.history[key] == null) {\n        this.history[key] = [];\n      }\n      this.history[key].push(logs[key]);\n    }\n  }\n\n  /**\n   * Await the values of all losses and metrics.\n   */\n  async syncData() {\n    const promises: Array<Promise<Float32Array|Int32Array|Uint8Array>> = [];\n    const keys: string[] = [];\n    const indices: number[] = [];\n    for (const key in this.history) {\n      const valueArray = this.history[key];\n      for (let i = 0; i < valueArray.length; ++i) {\n        if (typeof valueArray[i] !== 'number') {\n          const valueScalar = valueArray[i] as Tensor;\n          promises.push(valueScalar.data());\n          keys.push(key);\n          indices.push(i);\n        }\n      }\n    }\n    const values = await Promise.all(promises);\n    for (let n = 0; n < values.length; ++n) {\n      const tensorToDispose = this.history[keys[n]][indices[n]] as Tensor;\n      tensorToDispose.dispose();\n      this.history[keys[n]][indices[n]] = values[n][0];\n    }\n  }\n}\n\nexport interface CustomCallbackArgs {\n  onTrainBegin?: (logs?: Logs) => void | Promise<void>;\n  onTrainEnd?: (logs?: Logs) => void | Promise<void>;\n  onEpochBegin?: (epoch: number, logs?: Logs) => void | Promise<void>;\n  onEpochEnd?: (epoch: number, logs?: Logs) => void | Promise<void>;\n  onBatchBegin?: (batch: number, logs?: Logs) => void | Promise<void>;\n  onBatchEnd?: (batch: number, logs?: Logs) => void | Promise<void>;\n  onYield?: (epoch: number, batch: number, logs: Logs) => void | Promise<void>;\n}\n\n/**\n * Custom callback for training.\n */\nexport class CustomCallback extends BaseCallback {\n  protected readonly trainBegin: (logs?: Logs) => void | Promise<void>;\n  protected readonly trainEnd: (logs?: Logs) => void | Promise<void>;\n  protected readonly epochBegin:\n      (epoch: number, logs?: Logs) => void | Promise<void>;\n  protected readonly epochEnd:\n      (epoch: number, logs?: Logs) => void | Promise<void>;\n  protected readonly batchBegin:\n      (batch: number, logs?: Logs) => void | Promise<void>;\n  protected readonly batchEnd:\n      (batch: number, logs?: Logs) => void | Promise<void>;\n  protected readonly yield:\n      (epoch: number, batch: number, logs: Logs) => void | Promise<void>;\n\n  private yieldEvery: YieldEveryOptions;\n  private currentEpoch = 0;\n\n  constructor(args: CustomCallbackArgs, yieldEvery?: YieldEveryOptions) {\n    super();\n    this.yieldEvery = yieldEvery || 'auto';\n    if (this.yieldEvery === 'auto') {\n      this.yieldEvery = DEFAULT_YIELD_EVERY_MS;\n    }\n    if (this.yieldEvery === 'never' && args.onYield != null) {\n      throw new Error(\n          'yieldEvery is `never` but you provided an `onYield` callback. ' +\n          'Either change `yieldEvery` or remove the callback');\n    }\n    if (util.isNumber(this.yieldEvery)) {\n      // Decorate `maybeWait` so it will be called at most once every\n      // `yieldEvery` ms.\n      this.maybeWait = generic_utils.debounce(\n          this.maybeWait.bind(this), this.yieldEvery as number);\n    }\n    this.trainBegin = args.onTrainBegin;\n    this.trainEnd = args.onTrainEnd;\n    this.epochBegin = args.onEpochBegin;\n    this.epochEnd = args.onEpochEnd;\n    this.batchBegin = args.onBatchBegin;\n    this.batchEnd = args.onBatchEnd;\n    this.yield = args.onYield;\n  }\n\n  async maybeWait(epoch: number, batch: number, logs: UnresolvedLogs) {\n    const ps: Array<void|Promise<void>> = [];\n    if (this.yield != null) {\n      await resolveScalarsInLogs(logs);\n      ps.push(this.yield(epoch, batch, logs as Logs));\n    }\n    ps.push(nextFrame());\n    await Promise.all(ps);\n  }\n\n  async onEpochBegin(epoch: number, logs?: UnresolvedLogs): Promise<void> {\n    this.currentEpoch = epoch;\n    if (this.epochBegin != null) {\n      await resolveScalarsInLogs(logs);\n      await this.epochBegin(epoch, logs as Logs);\n    }\n  }\n\n  async onEpochEnd(epoch: number, logs?: UnresolvedLogs): Promise<void> {\n    const ps: Array<void|Promise<void>> = [];\n    if (this.epochEnd != null) {\n      await resolveScalarsInLogs(logs);\n      ps.push(this.epochEnd(epoch, logs as Logs));\n    }\n    if (this.yieldEvery === 'epoch') {\n      ps.push(nextFrame());\n    }\n    await Promise.all(ps);\n  }\n\n  async onBatchBegin(batch: number, logs?: UnresolvedLogs): Promise<void> {\n    if (this.batchBegin != null) {\n      await resolveScalarsInLogs(logs);\n      await this.batchBegin(batch, logs as Logs);\n    }\n  }\n\n  async onBatchEnd(batch: number, logs?: UnresolvedLogs): Promise<void> {\n    const ps: Array<void|Promise<void>> = [];\n    if (this.batchEnd != null) {\n      await resolveScalarsInLogs(logs);\n      ps.push(this.batchEnd(batch, logs as Logs));\n    }\n    if (this.yieldEvery === 'batch') {\n      ps.push(nextFrame());\n    } else if (util.isNumber(this.yieldEvery)) {\n      ps.push(this.maybeWait(this.currentEpoch, batch, logs));\n    }\n    await Promise.all(ps);\n  }\n\n  async onTrainBegin(logs?: UnresolvedLogs): Promise<void> {\n    if (this.trainBegin != null) {\n      await resolveScalarsInLogs(logs);\n      await this.trainBegin(logs as Logs);\n    }\n  }\n\n  async onTrainEnd(logs?: UnresolvedLogs): Promise<void> {\n    if (this.trainEnd != null) {\n      await resolveScalarsInLogs(logs);\n      await this.trainEnd(logs as Logs);\n    }\n  }\n}\n\n/**\n * Standardize callbacks or configurations of them to an Array of callbacks.\n */\nexport function standardizeCallbacks(\n    callbacks: BaseCallback|BaseCallback[]|CustomCallbackArgs|\n    CustomCallbackArgs[],\n    yieldEvery: YieldEveryOptions): BaseCallback[] {\n  if (callbacks == null) {\n    callbacks = {} as BaseCallback;\n  }\n  if (callbacks instanceof BaseCallback) {\n    return [callbacks];\n  }\n  if (Array.isArray(callbacks) && callbacks[0] instanceof BaseCallback) {\n    return callbacks as BaseCallback[];\n  }\n  // Convert custom callback configs to custom callback objects.\n  const callbackConfigs =\n      generic_utils.toList(callbacks) as CustomCallbackArgs[];\n  return callbackConfigs.map(\n      callbackConfig => new CustomCallback(callbackConfig, yieldEvery));\n}\n\nexport declare type BaseCallbackConstructor = {\n  new (): BaseCallback\n};\n\n/**\n * A global registry for callback constructors to be used during\n * LayersModel.fit().\n */\nexport class CallbackConstructorRegistry {\n  private static constructors:\n      {[verbosityLevel: number]: BaseCallbackConstructor[]} = {};\n\n  /**\n   * Blocks public access to constructor.\n   */\n  private constructor() {}\n\n  /**\n   * Register a tf.LayersModel.fit() callback constructor.\n   *\n   * The registered callback constructor will be used to instantiate\n   * callbacks for every tf.LayersModel.fit() call afterwards.\n   *\n   * @param verbosityLevel Level of verbosity at which the `callbackConstructor`\n   *   is to be reigstered.\n   * @param callbackConstructor A no-arg constructor for `tf.Callback`.\n   * @throws Error, if the same callbackConstructor has been registered before,\n   *   either at the same or a different `verbosityLevel`.\n   */\n  static registerCallbackConstructor(\n      verbosityLevel: number, callbackConstructor: BaseCallbackConstructor) {\n    util.assert(\n        verbosityLevel >= 0 && Number.isInteger(verbosityLevel),\n        () => `Verbosity level is expected to be an integer >= 0, ` +\n            `but got ${verbosityLevel}`);\n    CallbackConstructorRegistry.checkForDuplicate(callbackConstructor);\n    if (CallbackConstructorRegistry.constructors[verbosityLevel] == null) {\n      CallbackConstructorRegistry.constructors[verbosityLevel] = [];\n    }\n    CallbackConstructorRegistry.constructors[verbosityLevel].push(\n        callbackConstructor);\n  }\n\n  private static checkForDuplicate(callbackConstructor:\n                                       BaseCallbackConstructor) {\n    for (const levelName in CallbackConstructorRegistry.constructors) {\n      const constructors = CallbackConstructorRegistry.constructors[+levelName];\n      constructors.forEach(ctor => {\n        if (ctor === callbackConstructor) {\n          throw new ValueError('Duplicate callback constructor.');\n        }\n      });\n    }\n  }\n\n  /**\n   * Clear all registered callback constructors.\n   */\n  protected static clear() {\n    CallbackConstructorRegistry.constructors = {};\n  }\n\n  /**\n   * Create callbacks using the registered callback constructors.\n   *\n   * Given `verbosityLevel`, all constructors registered at that level or above\n   * will be called and the instantiated callbacks will be used.\n   *\n   * @param verbosityLevel: Level of verbosity.\n   */\n  static createCallbacks(verbosityLevel: number): BaseCallback[] {\n    const constructors: BaseCallbackConstructor[] = [];\n    for (const levelName in CallbackConstructorRegistry.constructors) {\n      const level = +levelName;\n      if (verbosityLevel >= level) {\n        constructors.push(...CallbackConstructorRegistry.constructors[level]);\n      }\n    }\n    return constructors.map(ctor => new ctor());\n  }\n}\n\nexport function configureCallbacks(\n    callbacks: BaseCallback[], verbose: ModelLoggingVerbosity, epochs: number,\n    initialEpoch: number, numTrainSamples: number, stepsPerEpoch: number,\n    batchSize: number, doValidation: boolean,\n    callbackMetrics: string[]): {callbackList: CallbackList, history: History} {\n  const history = new History();\n  const actualCallbacks: BaseCallback[] = [\n    new BaseLogger(), ...CallbackConstructorRegistry.createCallbacks(verbose)\n  ];\n  if (callbacks != null) {\n    actualCallbacks.push(...callbacks);\n  }\n  actualCallbacks.push(history);\n  const callbackList = new CallbackList(actualCallbacks);\n\n  // TODO(cais): Figure out when this LayersModel instance can have a\n  // dynamically\n  //   set property called 'callback_model' as in PyKeras.\n\n  callbackList.setParams({\n    epochs,\n    initialEpoch,\n    samples: numTrainSamples,\n    steps: stepsPerEpoch,\n    batchSize,\n    verbose,\n    doValidation,\n    metrics: callbackMetrics,\n  });\n  return {callbackList, history};\n}\n"]}},"error":null,"hash":"677f6b3a696120b2987f0d7c810248fb","cacheData":{"env":{}}}