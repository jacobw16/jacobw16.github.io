{"id":"node_modules/@tensorflow/tfjs-layers/dist/keras_format/initializer_config.js","dependencies":[{"name":"C:\\Users\\Jacob\\Documents\\jump(3)\\scripts\\node_modules\\@tensorflow\\tfjs-layers\\dist\\keras_format\\initializer_config.js.map","includedInParent":true,"mtime":499162500000},{"name":"C:\\Users\\Jacob\\Documents\\jump(3)\\scripts\\node_modules\\@tensorflow\\tfjs-layers\\src\\keras_format\\initializer_config.ts","includedInParent":true,"mtime":499162500000},{"name":"C:\\Users\\Jacob\\Documents\\jump(3)\\scripts\\package.json","includedInParent":true,"mtime":1581030063848},{"name":"C:\\Users\\Jacob\\Documents\\jump(3)\\scripts\\node_modules\\@tensorflow\\tfjs-layers\\package.json","includedInParent":true,"mtime":1581030261368}],"generated":{"js":"\"use strict\";\n/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.VALID_FAN_MODE_VALUES = ['fanIn', 'fanOut', 'fanAvg'];\nexports.VALID_DISTRIBUTION_VALUES = ['normal', 'uniform', 'truncatedNormal'];\n// We can't easily extract a string[] from the string union type, but we can\n// recapitulate the list, enforcing at compile time that the values are valid\n// and that we have the right number of them.\n/**\n * A string array of valid Initializer class names.\n *\n * This is guaranteed to match the `InitializerClassName` union type.\n */\nexports.initializerClassNames = [\n    'Zeros', 'Ones', 'Constant', 'RandomNormal', 'RandomUniform',\n    'TruncatedNormal', 'VarianceScaling', 'Orthogonal', 'Identity'\n];\n"},"sourceMaps":{"js":{"version":3,"file":"initializer_config.js","sourceRoot":"","sources":["../../src/keras_format/initializer_config.ts"],"names":[],"mappings":";AAAA;;;;;;;;GAQG;;AAQU,QAAA,qBAAqB,GAAG,CAAC,OAAO,EAAE,QAAQ,EAAE,QAAQ,CAAC,CAAC;AAOtD,QAAA,yBAAyB,GAClC,CAAC,QAAQ,EAAE,SAAS,EAAE,iBAAiB,CAAC,CAAC;AA4E7C,4EAA4E;AAC5E,6EAA6E;AAC7E,6CAA6C;AAE7C;;;;GAIG;AACU,QAAA,qBAAqB,GAA2B;IAC3D,OAAO,EAAE,MAAM,EAAE,UAAU,EAAE,cAAc,EAAE,eAAe;IAC5D,iBAAiB,EAAE,iBAAiB,EAAE,YAAY,EAAE,UAAU;CAC/D,CAAC","sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n\nimport {BaseSerialization} from './types';\n\n// TODO(soergel): Move the CamelCase versions back out of keras_format\n// e.g. to src/common.ts.  Maybe even duplicate *all* of these to be pedantic?\n/** @docinline */\nexport type FanMode = 'fanIn'|'fanOut'|'fanAvg';\nexport const VALID_FAN_MODE_VALUES = ['fanIn', 'fanOut', 'fanAvg'];\n\n// These constants have a snake vs. camel distinction.\nexport type FanModeSerialization = 'fan_in'|'fan_out'|'fan_avg';\n\n/** @docinline */\nexport type Distribution = 'normal'|'uniform'|'truncatedNormal';\nexport const VALID_DISTRIBUTION_VALUES =\n    ['normal', 'uniform', 'truncatedNormal'];\n// These constants have a snake vs. camel distinction.\nexport type DistributionSerialization = 'normal'|'uniform'|'truncated_normal';\n\nexport type ZerosSerialization = BaseSerialization<'Zeros', {}>;\n\nexport type OnesSerialization = BaseSerialization<'Ones', {}>;\n\nexport type ConstantConfig = {\n  value: number;\n};\n\nexport type ConstantSerialization =\n    BaseSerialization<'Constant', ConstantConfig>;\n\nexport type RandomNormalConfig = {\n  mean?: number;\n  stddev?: number;\n  seed?: number;\n};\n\nexport type RandomNormalSerialization =\n    BaseSerialization<'RandomNormal', RandomNormalConfig>;\n\nexport type RandomUniformConfig = {\n  minval?: number;\n  maxval?: number;\n  seed?: number;\n};\n\nexport type RandomUniformSerialization =\n    BaseSerialization<'RandomUniform', RandomUniformConfig>;\n\nexport type TruncatedNormalConfig = {\n  mean?: number;\n  stddev?: number;\n  seed?: number;\n};\n\nexport type TruncatedNormalSerialization =\n    BaseSerialization<'TruncatedNormal', TruncatedNormalConfig>;\n\nexport type VarianceScalingConfig = {\n  scale?: number;\n\n  mode?: FanModeSerialization;\n  distribution?: DistributionSerialization;\n  seed?: number;\n};\n\nexport type VarianceScalingSerialization =\n    BaseSerialization<'VarianceScaling', VarianceScalingConfig>;\n\nexport type OrthogonalConfig = {\n  seed?: number;\n  gain?: number;\n};\n\nexport type OrthogonalSerialization =\n    BaseSerialization<'Orthogonal', OrthogonalConfig>;\n\nexport type IdentityConfig = {\n  gain?: number;\n};\n\nexport type IdentitySerialization =\n    BaseSerialization<'Identity', IdentityConfig>;\n\n// Update initializerClassNames below in concert with this.\nexport type InitializerSerialization = ZerosSerialization|OnesSerialization|\n    ConstantSerialization|RandomUniformSerialization|RandomNormalSerialization|\n    TruncatedNormalSerialization|IdentitySerialization|\n    VarianceScalingSerialization|OrthogonalSerialization;\n\nexport type InitializerClassName = InitializerSerialization['class_name'];\n\n// We can't easily extract a string[] from the string union type, but we can\n// recapitulate the list, enforcing at compile time that the values are valid\n// and that we have the right number of them.\n\n/**\n * A string array of valid Initializer class names.\n *\n * This is guaranteed to match the `InitializerClassName` union type.\n */\nexport const initializerClassNames: InitializerClassName[] = [\n  'Zeros', 'Ones', 'Constant', 'RandomNormal', 'RandomUniform',\n  'TruncatedNormal', 'VarianceScaling', 'Orthogonal', 'Identity'\n];\n"]}},"error":null,"hash":"647baf86eda40fe037597ab2d8ba6527","cacheData":{"env":{}}}