{"id":"node_modules/@tensorflow/tfjs-layers/dist/backend/state.js","dependencies":[{"name":"C:\\Users\\Jacob\\Documents\\jump(3)\\scripts\\node_modules\\@tensorflow\\tfjs-layers\\dist\\backend\\state.js.map","includedInParent":true,"mtime":499162500000},{"name":"C:\\Users\\Jacob\\Documents\\jump(3)\\scripts\\node_modules\\@tensorflow\\tfjs-layers\\src\\backend\\state.ts","includedInParent":true,"mtime":499162500000},{"name":"C:\\Users\\Jacob\\Documents\\jump(3)\\scripts\\package.json","includedInParent":true,"mtime":1582861032163},{"name":"C:\\Users\\Jacob\\Documents\\jump(3)\\scripts\\node_modules\\@tensorflow\\tfjs-layers\\package.json","includedInParent":true,"mtime":1581030261368}],"generated":{"js":"\"use strict\";\n/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Utilities related to persistent state in the backend.\n */\n/**\n * An ID to track `tf.SymbolicTensor`s and derived classes.\n * Required in different places in engine/topology.ts to identify unique\n * tensors.\n */\nvar _nextUniqueTensorId = 0;\nfunction getNextUniqueTensorId() {\n    return _nextUniqueTensorId++;\n}\nexports.getNextUniqueTensorId = getNextUniqueTensorId;\nvar _uidPrefixes = {};\n/**\n * Provides a unique UID given a string prefix.\n *\n * @param prefix\n */\nfunction getUid(prefix) {\n    if (prefix === void 0) { prefix = ''; }\n    if (!(prefix in _uidPrefixes)) {\n        _uidPrefixes[prefix] = 0;\n    }\n    _uidPrefixes[prefix] += 1;\n    return prefix + _uidPrefixes[prefix].toString();\n}\nexports.getUid = getUid;\n"},"sourceMaps":{"js":{"version":3,"file":"state.js","sourceRoot":"","sources":["../../src/backend/state.ts"],"names":[],"mappings":";AAAA;;;;;;;;GAQG;;AAEH;;GAEG;AAEH;;;;GAIG;AACH,IAAI,mBAAmB,GAAG,CAAC,CAAC;AAE5B,SAAgB,qBAAqB;IACnC,OAAO,mBAAmB,EAAE,CAAC;AAC/B,CAAC;AAFD,sDAEC;AAED,IAAM,YAAY,GAA+B,EAAE,CAAC;AAEpD;;;;GAIG;AACH,SAAgB,MAAM,CAAC,MAAW;IAAX,uBAAA,EAAA,WAAW;IAChC,IAAI,CAAC,CAAC,MAAM,IAAI,YAAY,CAAC,EAAE;QAC7B,YAAY,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;KAC1B;IACD,YAAY,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;IAC1B,OAAO,MAAM,GAAG,YAAY,CAAC,MAAM,CAAC,CAAC,QAAQ,EAAE,CAAC;AAClD,CAAC;AAND,wBAMC","sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n\n/**\n * Utilities related to persistent state in the backend.\n */\n\n/**\n * An ID to track `tf.SymbolicTensor`s and derived classes.\n * Required in different places in engine/topology.ts to identify unique\n * tensors.\n */\nlet _nextUniqueTensorId = 0;\n\nexport function getNextUniqueTensorId(): number {\n  return _nextUniqueTensorId++;\n}\n\nconst _uidPrefixes: {[prefix: string]: number} = {};\n\n/**\n * Provides a unique UID given a string prefix.\n *\n * @param prefix\n */\nexport function getUid(prefix = ''): string {\n  if (!(prefix in _uidPrefixes)) {\n    _uidPrefixes[prefix] = 0;\n  }\n  _uidPrefixes[prefix] += 1;\n  return prefix + _uidPrefixes[prefix].toString();\n}\n"]}},"error":null,"hash":"3bc94c5ecd92a111c1691fa3987a77bb","cacheData":{"env":{}}}