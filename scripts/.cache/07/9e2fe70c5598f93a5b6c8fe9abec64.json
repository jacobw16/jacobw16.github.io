{"id":"node_modules/@tensorflow/tfjs-layers/dist/layers/recurrent.js","dependencies":[{"name":"C:\\Users\\Jacob\\Documents\\jump(3)\\scripts\\node_modules\\@tensorflow\\tfjs-layers\\dist\\layers\\recurrent.js.map","includedInParent":true,"mtime":499162500000},{"name":"C:\\Users\\Jacob\\Documents\\jump(3)\\scripts\\node_modules\\@tensorflow\\tfjs-layers\\src\\layers\\recurrent.ts","includedInParent":true,"mtime":499162500000},{"name":"C:\\Users\\Jacob\\Documents\\jump(3)\\scripts\\package.json","includedInParent":true,"mtime":1582861032163},{"name":"C:\\Users\\Jacob\\Documents\\jump(3)\\scripts\\node_modules\\@tensorflow\\tfjs-layers\\package.json","includedInParent":true,"mtime":1581030261368},{"name":"@tensorflow/tfjs-core","loc":{"line":29,"column":26},"parent":"C:\\Users\\Jacob\\Documents\\jump(3)\\scripts\\node_modules\\@tensorflow\\tfjs-layers\\dist\\layers\\recurrent.js","resolved":"C:\\Users\\Jacob\\Documents\\jump(3)\\scripts\\node_modules\\@tensorflow\\tfjs-core\\dist\\tf-core.esm.js"},{"name":"../activations","loc":{"line":30,"column":28},"parent":"C:\\Users\\Jacob\\Documents\\jump(3)\\scripts\\node_modules\\@tensorflow\\tfjs-layers\\dist\\layers\\recurrent.js","resolved":"C:\\Users\\Jacob\\Documents\\jump(3)\\scripts\\node_modules\\@tensorflow\\tfjs-layers\\dist\\activations.js"},{"name":"../backend/tfjs_backend","loc":{"line":31,"column":16},"parent":"C:\\Users\\Jacob\\Documents\\jump(3)\\scripts\\node_modules\\@tensorflow\\tfjs-layers\\dist\\layers\\recurrent.js","resolved":"C:\\Users\\Jacob\\Documents\\jump(3)\\scripts\\node_modules\\@tensorflow\\tfjs-layers\\dist\\backend\\tfjs_backend.js"},{"name":"../common","loc":{"line":32,"column":23},"parent":"C:\\Users\\Jacob\\Documents\\jump(3)\\scripts\\node_modules\\@tensorflow\\tfjs-layers\\dist\\layers\\recurrent.js","resolved":"C:\\Users\\Jacob\\Documents\\jump(3)\\scripts\\node_modules\\@tensorflow\\tfjs-layers\\dist\\common.js"},{"name":"../constraints","loc":{"line":33,"column":28},"parent":"C:\\Users\\Jacob\\Documents\\jump(3)\\scripts\\node_modules\\@tensorflow\\tfjs-layers\\dist\\layers\\recurrent.js","resolved":"C:\\Users\\Jacob\\Documents\\jump(3)\\scripts\\node_modules\\@tensorflow\\tfjs-layers\\dist\\constraints.js"},{"name":"../engine/topology","loc":{"line":35,"column":25},"parent":"C:\\Users\\Jacob\\Documents\\jump(3)\\scripts\\node_modules\\@tensorflow\\tfjs-layers\\dist\\layers\\recurrent.js","resolved":"C:\\Users\\Jacob\\Documents\\jump(3)\\scripts\\node_modules\\@tensorflow\\tfjs-layers\\dist\\engine\\topology.js"},{"name":"../errors","loc":{"line":36,"column":23},"parent":"C:\\Users\\Jacob\\Documents\\jump(3)\\scripts\\node_modules\\@tensorflow\\tfjs-layers\\dist\\layers\\recurrent.js","resolved":"C:\\Users\\Jacob\\Documents\\jump(3)\\scripts\\node_modules\\@tensorflow\\tfjs-layers\\dist\\errors.js"},{"name":"../initializers","loc":{"line":37,"column":29},"parent":"C:\\Users\\Jacob\\Documents\\jump(3)\\scripts\\node_modules\\@tensorflow\\tfjs-layers\\dist\\layers\\recurrent.js","resolved":"C:\\Users\\Jacob\\Documents\\jump(3)\\scripts\\node_modules\\@tensorflow\\tfjs-layers\\dist\\initializers.js"},{"name":"../regularizers","loc":{"line":38,"column":29},"parent":"C:\\Users\\Jacob\\Documents\\jump(3)\\scripts\\node_modules\\@tensorflow\\tfjs-layers\\dist\\layers\\recurrent.js","resolved":"C:\\Users\\Jacob\\Documents\\jump(3)\\scripts\\node_modules\\@tensorflow\\tfjs-layers\\dist\\regularizers.js"},{"name":"../utils/generic_utils","loc":{"line":39,"column":30},"parent":"C:\\Users\\Jacob\\Documents\\jump(3)\\scripts\\node_modules\\@tensorflow\\tfjs-layers\\dist\\layers\\recurrent.js","resolved":"C:\\Users\\Jacob\\Documents\\jump(3)\\scripts\\node_modules\\@tensorflow\\tfjs-layers\\dist\\utils\\generic_utils.js"},{"name":"../utils/math_utils","loc":{"line":40,"column":25},"parent":"C:\\Users\\Jacob\\Documents\\jump(3)\\scripts\\node_modules\\@tensorflow\\tfjs-layers\\dist\\layers\\recurrent.js","resolved":"C:\\Users\\Jacob\\Documents\\jump(3)\\scripts\\node_modules\\@tensorflow\\tfjs-layers\\dist\\utils\\math_utils.js"},{"name":"../utils/types_utils","loc":{"line":41,"column":28},"parent":"C:\\Users\\Jacob\\Documents\\jump(3)\\scripts\\node_modules\\@tensorflow\\tfjs-layers\\dist\\layers\\recurrent.js","resolved":"C:\\Users\\Jacob\\Documents\\jump(3)\\scripts\\node_modules\\@tensorflow\\tfjs-layers\\dist\\utils\\types_utils.js"},{"name":"../variables","loc":{"line":42,"column":26},"parent":"C:\\Users\\Jacob\\Documents\\jump(3)\\scripts\\node_modules\\@tensorflow\\tfjs-layers\\dist\\layers\\recurrent.js","resolved":"C:\\Users\\Jacob\\Documents\\jump(3)\\scripts\\node_modules\\@tensorflow\\tfjs-layers\\dist\\variables.js"},{"name":"./serialization","loc":{"line":43,"column":30},"parent":"C:\\Users\\Jacob\\Documents\\jump(3)\\scripts\\node_modules\\@tensorflow\\tfjs-layers\\dist\\layers\\recurrent.js","resolved":"C:\\Users\\Jacob\\Documents\\jump(3)\\scripts\\node_modules\\@tensorflow\\tfjs-layers\\dist\\layers\\serialization.js"}],"generated":{"js":"\"use strict\";\n/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * TensorFlow.js Layers: Recurrent Neural Network Layers.\n */\nvar tfc = require(\"@tensorflow/tfjs-core\");\nvar tfjs_core_1 = require(\"@tensorflow/tfjs-core\");\nvar activations_1 = require(\"../activations\");\nvar K = require(\"../backend/tfjs_backend\");\nvar common_1 = require(\"../common\");\nvar constraints_1 = require(\"../constraints\");\nvar topology_1 = require(\"../engine/topology\");\nvar topology_2 = require(\"../engine/topology\");\nvar errors_1 = require(\"../errors\");\nvar initializers_1 = require(\"../initializers\");\nvar regularizers_1 = require(\"../regularizers\");\nvar generic_utils_1 = require(\"../utils/generic_utils\");\nvar math_utils = require(\"../utils/math_utils\");\nvar types_utils_1 = require(\"../utils/types_utils\");\nvar variables_1 = require(\"../variables\");\nvar serialization_1 = require(\"./serialization\");\n/**\n * Standardize `apply()` args to a single list of tensor inputs.\n *\n * When running a model loaded from file, the input tensors `initialState` and\n * `constants` are passed to `RNN.apply()` as part of `inputs` instead of the\n * dedicated kwargs fields. `inputs` consists of\n * `[inputs, initialState0, initialState1, ..., constant0, constant1]` in this\n * case.\n * This method makes sure that arguments are\n * separated and that `initialState` and `constants` are `Array`s of tensors\n * (or None).\n *\n * @param inputs Tensor or `Array` of  tensors.\n * @param initialState Tensor or `Array` of tensors or `null`/`undefined`.\n * @param constants Tensor or `Array` of tensors or `null`/`undefined`.\n * @returns An object consisting of\n *   inputs: A tensor.\n *   initialState: `Array` of tensors or `null`.\n *   constants: `Array` of tensors or `null`.\n * @throws ValueError, if `inputs` is an `Array` but either `initialState` or\n *   `constants` is provided.\n */\nfunction standardizeArgs(inputs, initialState, constants, numConstants) {\n    if (Array.isArray(inputs)) {\n        if (initialState != null || constants != null) {\n            throw new errors_1.ValueError('When inputs is an array, neither initialState or constants ' +\n                'should be provided');\n        }\n        if (numConstants != null) {\n            constants = inputs.slice(inputs.length - numConstants, inputs.length);\n            inputs = inputs.slice(0, inputs.length - numConstants);\n        }\n        if (inputs.length > 1) {\n            initialState = inputs.slice(1, inputs.length);\n        }\n        inputs = inputs[0];\n    }\n    function toListOrNull(x) {\n        if (x == null || Array.isArray(x)) {\n            return x;\n        }\n        else {\n            return [x];\n        }\n    }\n    initialState = toListOrNull(initialState);\n    constants = toListOrNull(constants);\n    return { inputs: inputs, initialState: initialState, constants: constants };\n}\nexports.standardizeArgs = standardizeArgs;\n/**\n * Iterates over the time dimension of a tensor.\n *\n * @param stepFunction RNN step function.\n *   Parameters:\n *     inputs: tensor with shape `[samples, ...]` (no time dimension),\n *       representing input for the batch of samples at a certain time step.\n *     states: an Array of tensors.\n *   Returns:\n *     outputs: tensor with shape `[samples, outputDim]` (no time dimension).\n *     newStates: list of tensors, same length and shapes as `states`. The first\n *       state in the list must be the output tensor at the previous timestep.\n * @param inputs Tensor of temporal data of shape `[samples, time, ...]` (at\n *   least 3D).\n * @param initialStates Tensor with shape `[samples, outputDim]` (no time\n *   dimension), containing the initial values of the states used in the step\n *   function.\n * @param goBackwards If `true`, do the iteration over the time dimension in\n *   reverse order and return the reversed sequence.\n * @param mask Binary tensor with shape `[sample, time, 1]`, with a zero for\n *   every element that is masked.\n * @param constants An Array of constant values passed at each step.\n * @param unroll Whether to unroll the RNN or to use a symbolic loop. *Not*\n *   applicable to this imperative deeplearn.js backend. Its value is ignored.\n * @param needPerStepOutputs Whether the per-step outputs are to be\n *   concatenated into a single tensor and returned (as the second return\n *   value). Default: `false`. This arg is included so that the relatively\n *   expensive concatenation of the stepwise outputs can be omitted unless\n *   the stepwise outputs need to be kept (e.g., for an LSTM layer of which\n *   `returnSequence` is `true`.)\n * @returns An Array: `[lastOutput, outputs, newStates]`.\n *   lastOutput: the lastest output of the RNN, of shape `[samples, ...]`.\n *   outputs: tensor with shape `[samples, time, ...]` where each entry\n *     `output[s, t]` is the output of the step function at time `t` for sample\n *     `s`. This return value is provided if and only if the\n *     `needPerStepOutputs` is set as `true`. If it is set as `false`, this\n *     return value will be `undefined`.\n *   newStates: Array of tensors, latest states returned by the step function,\n *      of shape `(samples, ...)`.\n * @throws ValueError If input dimension is less than 3.\n *\n * TODO(nielsene): This needs to be tidy-ed.\n */\nfunction rnn(stepFunction, inputs, initialStates, goBackwards, mask, constants, unroll, needPerStepOutputs) {\n    if (goBackwards === void 0) { goBackwards = false; }\n    if (unroll === void 0) { unroll = false; }\n    if (needPerStepOutputs === void 0) { needPerStepOutputs = false; }\n    return tfc.tidy(function () {\n        var ndim = inputs.shape.length;\n        if (ndim < 3) {\n            throw new errors_1.ValueError(\"Input should be at least 3D, but is \" + ndim + \"D.\");\n        }\n        // Transpose to time-major, i.e., from [batch, time, ...] to [time, batch,\n        // ...].\n        var axes = [1, 0].concat(math_utils.range(2, ndim));\n        inputs = tfc.transpose(inputs, axes);\n        if (constants != null) {\n            throw new errors_1.NotImplementedError('The rnn() functoin of the deeplearn.js backend does not support ' +\n                'constants yet.');\n        }\n        // Porting Note: the unroll option is ignored by the imperative backend.\n        if (unroll) {\n            console.warn('Backend rnn(): the unroll = true option is not applicable to the ' +\n                'imperative deeplearn.js backend.');\n        }\n        if (mask != null) {\n            mask = mask.asType('bool').asType('float32');\n            if (mask.rank === ndim - 1) {\n                mask = tfc.expandDims(mask, -1);\n            }\n            mask = tfc.transpose(mask, axes);\n        }\n        if (goBackwards) {\n            inputs = tfc.reverse(inputs, 0);\n            if (mask != null) {\n                mask = tfc.reverse(mask, 0);\n            }\n        }\n        // Porting Note: PyKeras with TensorFlow backend uses a symbolic loop\n        //   (tf.while_loop). But for the imperative deeplearn.js backend, we just\n        //   use the usual TypeScript control flow to iterate over the time steps in\n        //   the inputs.\n        // Porting Note: PyKeras patches a \"_use_learning_phase\" attribute to\n        // outputs.\n        //   This is not idiomatic in TypeScript. The info regarding whether we are\n        //   in a learning (i.e., training) phase for RNN is passed in a different\n        //   way.\n        var perStepOutputs = [];\n        var lastOutput;\n        var states = initialStates;\n        var timeSteps = inputs.shape[0];\n        var perStepInputs = tfc.unstack(inputs);\n        var perStepMasks;\n        if (mask != null) {\n            perStepMasks = tfc.unstack(mask);\n        }\n        var _loop_1 = function (t) {\n            var currentInput = perStepInputs[t];\n            var stepOutputs = tfc.tidy(function () { return stepFunction(currentInput, states); });\n            if (mask == null) {\n                lastOutput = stepOutputs[0];\n                states = stepOutputs[1];\n            }\n            else {\n                var maskedOutputs = tfc.tidy(function () {\n                    var stepMask = perStepMasks[t];\n                    var negStepMask = tfc.onesLike(stepMask).sub(stepMask);\n                    // TODO(cais): Would tfc.where() be better for performance?\n                    var output = stepOutputs[0].mul(stepMask).addStrict(states[0].mul(negStepMask));\n                    var newStates = states.map(function (state, i) {\n                        return stepOutputs[1][i].mul(stepMask).addStrict(state.mul(negStepMask));\n                    });\n                    return { output: output, newStates: newStates };\n                });\n                lastOutput = maskedOutputs.output;\n                states = maskedOutputs.newStates;\n            }\n            if (needPerStepOutputs) {\n                perStepOutputs.push(lastOutput);\n            }\n        };\n        for (var t = 0; t < timeSteps; ++t) {\n            _loop_1(t);\n        }\n        var outputs;\n        if (needPerStepOutputs) {\n            var axis = 1;\n            outputs = tfc.stack(perStepOutputs, axis);\n        }\n        return [lastOutput, outputs, states];\n    });\n}\nexports.rnn = rnn;\nvar RNN = /** @class */ (function (_super) {\n    __extends(RNN, _super);\n    function RNN(args) {\n        var _this = _super.call(this, args) || this;\n        var cell;\n        if (args.cell == null) {\n            throw new errors_1.ValueError('cell property is missing for the constructor of RNN.');\n        }\n        else if (Array.isArray(args.cell)) {\n            cell = new StackedRNNCells({ cells: args.cell });\n        }\n        else {\n            cell = args.cell;\n        }\n        if (cell.stateSize == null) {\n            throw new errors_1.ValueError('The RNN cell should have an attribute `stateSize` (tuple of ' +\n                'integers, one integer per RNN state).');\n        }\n        _this.cell = cell;\n        _this.returnSequences =\n            args.returnSequences == null ? false : args.returnSequences;\n        _this.returnState = args.returnState == null ? false : args.returnState;\n        _this.goBackwards = args.goBackwards == null ? false : args.goBackwards;\n        _this._stateful = args.stateful == null ? false : args.stateful;\n        _this.unroll = args.unroll == null ? false : args.unroll;\n        _this.supportsMasking = true;\n        _this.inputSpec = [new topology_1.InputSpec({ ndim: 3 })];\n        _this.stateSpec = null;\n        _this.states_ = null;\n        // TODO(cais): Add constantsSpec and numConstants.\n        _this.numConstants = null;\n        // TODO(cais): Look into the use of initial_state in the kwargs of the\n        //   constructor.\n        _this.keptStates = [];\n        return _this;\n    }\n    // Porting Note: This is the equivalent of `RNN.states` property getter in\n    //   PyKeras.\n    RNN.prototype.getStates = function () {\n        if (this.states_ == null) {\n            var numStates = Array.isArray(this.cell.stateSize) ? this.cell.stateSize.length : 1;\n            return math_utils.range(0, numStates).map(function (x) { return null; });\n        }\n        else {\n            return this.states_;\n        }\n    };\n    // Porting Note: This is the equivalent of the `RNN.states` property setter in\n    //   PyKeras.\n    RNN.prototype.setStates = function (states) {\n        this.states_ = states;\n    };\n    RNN.prototype.computeOutputShape = function (inputShape) {\n        if (types_utils_1.isArrayOfShapes(inputShape)) {\n            inputShape = inputShape[0];\n        }\n        inputShape = inputShape;\n        // TODO(cais): Remove the casting once stacked RNN cells become supported.\n        var stateSize = this.cell.stateSize;\n        if (!Array.isArray(stateSize)) {\n            stateSize = [stateSize];\n        }\n        var outputDim = stateSize[0];\n        var outputShape;\n        if (this.returnSequences) {\n            outputShape = [inputShape[0], inputShape[1], outputDim];\n        }\n        else {\n            outputShape = [inputShape[0], outputDim];\n        }\n        if (this.returnState) {\n            var stateShape = [];\n            for (var _i = 0, stateSize_1 = stateSize; _i < stateSize_1.length; _i++) {\n                var dim = stateSize_1[_i];\n                stateShape.push([inputShape[0], dim]);\n            }\n            return [outputShape].concat(stateShape);\n        }\n        else {\n            return outputShape;\n        }\n    };\n    RNN.prototype.computeMask = function (inputs, mask) {\n        var _this = this;\n        return tfc.tidy(function () {\n            if (Array.isArray(mask)) {\n                mask = mask[0];\n            }\n            var outputMask = _this.returnSequences ? mask : null;\n            if (_this.returnState) {\n                var stateMask = _this.states.map(function (s) { return null; });\n                return [outputMask].concat(stateMask);\n            }\n            else {\n                return outputMask;\n            }\n        });\n    };\n    Object.defineProperty(RNN.prototype, \"states\", {\n        /**\n         * Get the current state tensors of the RNN.\n         *\n         * If the state hasn't been set, return an array of `null`s of the correct\n         * length.\n         */\n        get: function () {\n            if (this.states_ == null) {\n                var numStates = Array.isArray(this.cell.stateSize) ? this.cell.stateSize.length : 1;\n                var output = [];\n                for (var i = 0; i < numStates; ++i) {\n                    output.push(null);\n                }\n                return output;\n            }\n            else {\n                return this.states_;\n            }\n        },\n        set: function (s) {\n            this.states_ = s;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    RNN.prototype.build = function (inputShape) {\n        // Note inputShape will be an Array of Shapes of initial states and\n        // constants if these are passed in apply().\n        var constantShape = null;\n        if (this.numConstants != null) {\n            throw new errors_1.NotImplementedError('Constants support is not implemented in RNN yet.');\n        }\n        if (types_utils_1.isArrayOfShapes(inputShape)) {\n            inputShape = inputShape[0];\n        }\n        inputShape = inputShape;\n        var batchSize = this.stateful ? inputShape[0] : null;\n        var inputDim = inputShape[inputShape.length - 1];\n        this.inputSpec[0] = new topology_1.InputSpec({ shape: [batchSize, null, inputDim] });\n        // Allow cell (if RNNCell Layer) to build before we set or validate\n        // stateSpec.\n        var stepInputShape = [inputShape[0]].concat(inputShape.slice(2));\n        if (constantShape != null) {\n            throw new errors_1.NotImplementedError('Constants support is not implemented in RNN yet.');\n        }\n        else {\n            this.cell.build(stepInputShape);\n        }\n        // Set or validate stateSpec.\n        var stateSize;\n        if (Array.isArray(this.cell.stateSize)) {\n            stateSize = this.cell.stateSize;\n        }\n        else {\n            stateSize = [this.cell.stateSize];\n        }\n        if (this.stateSpec != null) {\n            if (!tfjs_core_1.util.arraysEqual(this.stateSpec.map(function (spec) { return spec.shape[spec.shape.length - 1]; }), stateSize)) {\n                throw new errors_1.ValueError(\"An initialState was passed that is not compatible with \" +\n                    (\"cell.stateSize. Received stateSpec=\" + this.stateSpec + \"; \") +\n                    (\"However cell.stateSize is \" + this.cell.stateSize));\n            }\n        }\n        else {\n            this.stateSpec =\n                stateSize.map(function (dim) { return new topology_1.InputSpec({ shape: [null, dim] }); });\n        }\n        if (this.stateful) {\n            this.resetStates();\n        }\n    };\n    /**\n     * Reset the state tensors of the RNN.\n     *\n     * If the `states` argument is `undefined` or `null`, will set the\n     * state tensor(s) of the RNN to all-zero tensors of the appropriate\n     * shape(s).\n     *\n     * If `states` is provided, will set the state tensors of the RNN to its\n     * value.\n     *\n     * @param states Optional externally-provided initial states.\n     * @param training Whether this call is done during training. For stateful\n     *   RNNs, this affects whether the old states are kept or discarded. In\n     *   particular, if `training` is `true`, the old states will be kept so\n     *   that subsequent backpropgataion through time (BPTT) may work properly.\n     *   Else, the old states will be discarded.\n     */\n    RNN.prototype.resetStates = function (states, training) {\n        var _this = this;\n        if (training === void 0) { training = false; }\n        tfjs_core_1.tidy(function () {\n            if (!_this.stateful) {\n                throw new errors_1.AttributeError('Cannot call resetStates() on an RNN Layer that is not stateful.');\n            }\n            var batchSize = _this.inputSpec[0].shape[0];\n            if (batchSize == null) {\n                throw new errors_1.ValueError('If an RNN is stateful, it needs to know its batch size. Specify ' +\n                    'the batch size of your input tensors: \\n' +\n                    '- If using a Sequential model, specify the batch size by ' +\n                    'passing a `batchInputShape` option to your first layer.\\n' +\n                    '- If using the functional API, specify the batch size by ' +\n                    'passing a `batchShape` option to your Input layer.');\n            }\n            // Initialize state if null.\n            if (_this.states_ == null) {\n                if (Array.isArray(_this.cell.stateSize)) {\n                    _this.states_ =\n                        _this.cell.stateSize.map(function (dim) { return tfc.zeros([batchSize, dim]); });\n                }\n                else {\n                    _this.states_ = [tfc.zeros([batchSize, _this.cell.stateSize])];\n                }\n            }\n            else if (states == null) {\n                // Dispose old state tensors.\n                tfc.dispose(_this.states_);\n                // For stateful RNNs, fully dispose kept old states.\n                if (_this.keptStates != null) {\n                    tfc.dispose(_this.keptStates);\n                    _this.keptStates = [];\n                }\n                if (Array.isArray(_this.cell.stateSize)) {\n                    _this.states_ =\n                        _this.cell.stateSize.map(function (dim) { return tfc.zeros([batchSize, dim]); });\n                }\n                else {\n                    _this.states_[0] = tfc.zeros([batchSize, _this.cell.stateSize]);\n                }\n            }\n            else {\n                if (!Array.isArray(states)) {\n                    states = [states];\n                }\n                if (states.length !== _this.states_.length) {\n                    throw new errors_1.ValueError(\"Layer \" + _this.name + \" expects \" + _this.states_.length + \" state(s), \" +\n                        (\"but it received \" + states.length + \" state value(s). Input \") +\n                        (\"received: \" + states));\n                }\n                if (training === true) {\n                    // Store old state tensors for complete disposal later, i.e., during\n                    // the next no-arg call to this method. We do not dispose the old\n                    // states immediately because that BPTT (among other things) require\n                    // them.\n                    _this.keptStates.push(_this.states_.slice());\n                }\n                else {\n                    tfc.dispose(_this.states_);\n                }\n                for (var index = 0; index < _this.states_.length; ++index) {\n                    var value = states[index];\n                    var dim = Array.isArray(_this.cell.stateSize) ?\n                        _this.cell.stateSize[index] :\n                        _this.cell.stateSize;\n                    var expectedShape = [batchSize, dim];\n                    if (!tfjs_core_1.util.arraysEqual(value.shape, expectedShape)) {\n                        throw new errors_1.ValueError(\"State \" + index + \" is incompatible with layer \" + _this.name + \": \" +\n                            (\"expected shape=\" + expectedShape + \", received shape=\" + value.shape));\n                    }\n                    _this.states_[index] = value;\n                }\n            }\n            _this.states_ = _this.states_.map(function (state) { return tfc.keep(state.clone()); });\n        });\n    };\n    RNN.prototype.apply = function (inputs, kwargs) {\n        // TODO(cais): Figure out whether initialState is in kwargs or inputs.\n        var initialState = kwargs == null ? null : kwargs['initialState'];\n        var constants = kwargs == null ? null : kwargs['constants'];\n        if (kwargs == null) {\n            kwargs = {};\n        }\n        var standardized = standardizeArgs(inputs, initialState, constants, this.numConstants);\n        inputs = standardized.inputs;\n        initialState = standardized.initialState;\n        constants = standardized.constants;\n        // If any of `initial_state` or `constants` are specified and are\n        // `tf.SymbolicTensor`s, then add them to the inputs and temporarily modify\n        // the input_spec to include them.\n        var additionalInputs = [];\n        var additionalSpecs = [];\n        if (initialState != null) {\n            kwargs['initialState'] = initialState;\n            additionalInputs = additionalInputs.concat(initialState);\n            this.stateSpec = [];\n            for (var _i = 0, initialState_1 = initialState; _i < initialState_1.length; _i++) {\n                var state = initialState_1[_i];\n                this.stateSpec.push(new topology_1.InputSpec({ shape: state.shape }));\n            }\n            // TODO(cais): Use the following instead.\n            // this.stateSpec = initialState.map(state => new InputSpec({shape:\n            // state.shape}));\n            additionalSpecs = additionalSpecs.concat(this.stateSpec);\n        }\n        if (constants != null) {\n            kwargs['constants'] = constants;\n            additionalInputs = additionalInputs.concat(constants);\n            // TODO(cais): Add this.constantsSpec.\n            this.numConstants = constants.length;\n        }\n        var isTensor = additionalInputs[0] instanceof topology_1.SymbolicTensor;\n        if (isTensor) {\n            // Compute full input spec, including state and constants.\n            var fullInput = [inputs].concat(additionalInputs);\n            var fullInputSpec = this.inputSpec.concat(additionalSpecs);\n            // Perform the call with temporarily replaced inputSpec.\n            var originalInputSpec = this.inputSpec;\n            this.inputSpec = fullInputSpec;\n            var output = _super.prototype.apply.call(this, fullInput, kwargs);\n            this.inputSpec = originalInputSpec;\n            return output;\n        }\n        else {\n            return _super.prototype.apply.call(this, inputs, kwargs);\n        }\n    };\n    // tslint:disable-next-line:no-any\n    RNN.prototype.call = function (inputs, kwargs) {\n        var _this = this;\n        // Input shape: `[samples, time (padded with zeros), input_dim]`.\n        // Note that the .build() method of subclasses **must** define\n        // this.inputSpec and this.stateSpec owith complete input shapes.\n        return tfjs_core_1.tidy(function () {\n            var mask = kwargs == null ? null : kwargs['mask'];\n            var training = kwargs == null ? null : kwargs['training'];\n            var initialState = kwargs == null ? null : kwargs['initialState'];\n            inputs = types_utils_1.getExactlyOneTensor(inputs);\n            if (initialState == null) {\n                if (_this.stateful) {\n                    initialState = _this.states_;\n                }\n                else {\n                    initialState = _this.getInitialState(inputs);\n                }\n            }\n            var numStates = Array.isArray(_this.cell.stateSize) ? _this.cell.stateSize.length : 1;\n            if (initialState.length !== numStates) {\n                throw new errors_1.ValueError(\"RNN Layer has \" + numStates + \" state(s) but was passed \" +\n                    (initialState.length + \" initial state(s).\"));\n            }\n            if (_this.unroll) {\n                console.warn('Ignoring unroll = true for RNN layer, due to imperative backend.');\n            }\n            var cellCallKwargs = { training: training };\n            // TODO(cais): Add support for constants.\n            var step = function (inputs, states) {\n                // `inputs` and `states` are concatenated to form a single `Array` of\n                // `tf.Tensor`s as the input to `cell.call()`.\n                var outputs = _this.cell.call([inputs].concat(states), cellCallKwargs);\n                // Marshall the return value into output and new states.\n                return [outputs[0], outputs.slice(1)];\n            };\n            // TODO(cais): Add support for constants.\n            var rnnOutputs = rnn(step, inputs, initialState, _this.goBackwards, mask, null, _this.unroll, _this.returnSequences);\n            var lastOutput = rnnOutputs[0];\n            var outputs = rnnOutputs[1];\n            var states = rnnOutputs[2];\n            if (_this.stateful) {\n                _this.resetStates(states, training);\n            }\n            var output = _this.returnSequences ? outputs : lastOutput;\n            // TODO(cais): Porperty set learning phase flag.\n            if (_this.returnState) {\n                return [output].concat(states);\n            }\n            else {\n                return output;\n            }\n        });\n    };\n    RNN.prototype.getInitialState = function (inputs) {\n        var _this = this;\n        return tfjs_core_1.tidy(function () {\n            // Build an all-zero tensor of shape [samples, outputDim].\n            // [Samples, timeSteps, inputDim].\n            var initialState = tfc.zeros(inputs.shape);\n            // [Samples].\n            initialState = tfc.sum(initialState, [1, 2]);\n            initialState = K.expandDims(initialState); // [Samples, 1].\n            if (Array.isArray(_this.cell.stateSize)) {\n                return _this.cell.stateSize.map(function (dim) { return dim > 1 ? K.tile(initialState, [1, dim]) : initialState; });\n            }\n            else {\n                return _this.cell.stateSize > 1 ?\n                    [K.tile(initialState, [1, _this.cell.stateSize])] :\n                    [initialState];\n            }\n        });\n    };\n    Object.defineProperty(RNN.prototype, \"trainableWeights\", {\n        get: function () {\n            if (!this.trainable) {\n                return [];\n            }\n            // Porting Note: In TypeScript, `this` is always an instance of `Layer`.\n            return this.cell.trainableWeights;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(RNN.prototype, \"nonTrainableWeights\", {\n        get: function () {\n            // Porting Note: In TypeScript, `this` is always an instance of `Layer`.\n            if (!this.trainable) {\n                return this.cell.weights;\n            }\n            return this.cell.nonTrainableWeights;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    RNN.prototype.setFastWeightInitDuringBuild = function (value) {\n        _super.prototype.setFastWeightInitDuringBuild.call(this, value);\n        if (this.cell != null) {\n            this.cell.setFastWeightInitDuringBuild(value);\n        }\n    };\n    RNN.prototype.getConfig = function () {\n        var config = {\n            returnSequences: this.returnSequences,\n            returnState: this.returnState,\n            goBackwards: this.goBackwards,\n            stateful: this.stateful,\n            unroll: this.unroll,\n        };\n        if (this.numConstants != null) {\n            config['numConstants'] = this.numConstants;\n        }\n        var cellConfig = this.cell.getConfig();\n        config['cell'] = {\n            'className': this.cell.getClassName(),\n            'config': cellConfig,\n        };\n        var baseConfig = _super.prototype.getConfig.call(this);\n        Object.assign(config, baseConfig);\n        return config;\n    };\n    /** @nocollapse */\n    RNN.fromConfig = function (cls, config, customObjects) {\n        if (customObjects === void 0) { customObjects = {}; }\n        var cellConfig = config['cell'];\n        var cell = serialization_1.deserialize(cellConfig, customObjects);\n        return new cls(Object.assign(config, { cell: cell }));\n    };\n    /** @nocollapse */\n    RNN.className = 'RNN';\n    return RNN;\n}(topology_2.Layer));\nexports.RNN = RNN;\ntfjs_core_1.serialization.registerClass(RNN);\n/**\n * An RNNCell layer.\n */\n// Porting Note: This is a common parent class for RNN cells. There is no\n// equivalent of this in PyKeras. Having a common parent class forgoes the\n//  need for `has_attr(cell, ...)` checks or its TypeScript equivalent.\n/** @doc {heading: 'Layers', subheading: 'Classes'} */\nvar RNNCell = /** @class */ (function (_super) {\n    __extends(RNNCell, _super);\n    function RNNCell() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return RNNCell;\n}(topology_2.Layer));\nexports.RNNCell = RNNCell;\nvar SimpleRNNCell = /** @class */ (function (_super) {\n    __extends(SimpleRNNCell, _super);\n    function SimpleRNNCell(args) {\n        var _this = _super.call(this, args) || this;\n        _this.DEFAULT_ACTIVATION = 'tanh';\n        _this.DEFAULT_KERNEL_INITIALIZER = 'glorotNormal';\n        _this.DEFAULT_RECURRENT_INITIALIZER = 'orthogonal';\n        _this.DEFAULT_BIAS_INITIALIZER = 'zeros';\n        _this.units = args.units;\n        generic_utils_1.assertPositiveInteger(_this.units, \"units\");\n        _this.activation = activations_1.getActivation(args.activation == null ? _this.DEFAULT_ACTIVATION : args.activation);\n        _this.useBias = args.useBias == null ? true : args.useBias;\n        _this.kernelInitializer = initializers_1.getInitializer(args.kernelInitializer || _this.DEFAULT_KERNEL_INITIALIZER);\n        _this.recurrentInitializer = initializers_1.getInitializer(args.recurrentInitializer || _this.DEFAULT_RECURRENT_INITIALIZER);\n        _this.biasInitializer =\n            initializers_1.getInitializer(args.biasInitializer || _this.DEFAULT_BIAS_INITIALIZER);\n        _this.kernelRegularizer = regularizers_1.getRegularizer(args.kernelRegularizer);\n        _this.recurrentRegularizer = regularizers_1.getRegularizer(args.recurrentRegularizer);\n        _this.biasRegularizer = regularizers_1.getRegularizer(args.biasRegularizer);\n        _this.kernelConstraint = constraints_1.getConstraint(args.kernelConstraint);\n        _this.recurrentConstraint = constraints_1.getConstraint(args.recurrentConstraint);\n        _this.biasConstraint = constraints_1.getConstraint(args.biasConstraint);\n        _this.dropout = math_utils.min([1, math_utils.max([0, args.dropout == null ? 0 : args.dropout])]);\n        _this.recurrentDropout = math_utils.min([\n            1,\n            math_utils.max([0, args.recurrentDropout == null ? 0 : args.recurrentDropout])\n        ]);\n        _this.stateSize = _this.units;\n        _this.dropoutMask = null;\n        _this.recurrentDropoutMask = null;\n        return _this;\n    }\n    SimpleRNNCell.prototype.build = function (inputShape) {\n        inputShape = types_utils_1.getExactlyOneShape(inputShape);\n        // TODO(cais): Use regularizer.\n        this.kernel = this.addWeight('kernel', [inputShape[inputShape.length - 1], this.units], null, this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint);\n        this.recurrentKernel = this.addWeight('recurrent_kernel', [this.units, this.units], null, this.recurrentInitializer, this.recurrentRegularizer, true, this.recurrentConstraint);\n        if (this.useBias) {\n            this.bias = this.addWeight('bias', [this.units], null, this.biasInitializer, this.biasRegularizer, true, this.biasConstraint);\n        }\n        else {\n            this.bias = null;\n        }\n        this.built = true;\n    };\n    // Porting Note: PyKeras' equivalent of this method takes two tensor inputs:\n    //   `inputs` and `states`. Here, the two tensors are combined into an\n    //   `Tensor[]` Array as the first input argument.\n    //   Similarly, PyKeras' equivalent of this method returns two values:\n    //    `output` and `[output]`. Here the two are combined into one length-2\n    //    `Tensor[]`, consisting of `output` repeated.\n    SimpleRNNCell.prototype.call = function (inputs, kwargs) {\n        var _this = this;\n        return tfjs_core_1.tidy(function () {\n            inputs = inputs;\n            if (inputs.length !== 2) {\n                throw new errors_1.ValueError(\"SimpleRNNCell expects 2 input Tensors, got \" + inputs.length + \".\");\n            }\n            var prevOutput = inputs[1];\n            inputs = inputs[0];\n            var training = kwargs['training'] == null ? false : kwargs['training'];\n            if (0 < _this.dropout && _this.dropout < 1 && _this.dropoutMask == null) {\n                _this.dropoutMask = generateDropoutMask(function () { return tfc.onesLike(inputs); }, _this.dropout, training);\n            }\n            if (0 < _this.recurrentDropout && _this.recurrentDropout < 1 &&\n                _this.recurrentDropoutMask == null) {\n                _this.recurrentDropoutMask =\n                    generateDropoutMask(function () { return tfc.onesLike(prevOutput); }, _this.recurrentDropout, training);\n            }\n            var h;\n            var dpMask = _this.dropoutMask;\n            var recDpMask = _this.recurrentDropoutMask;\n            if (dpMask != null) {\n                h = K.dot(tfc.mul(inputs, dpMask), _this.kernel.read());\n            }\n            else {\n                h = K.dot(inputs, _this.kernel.read());\n            }\n            if (_this.bias != null) {\n                h = K.biasAdd(h, _this.bias.read());\n            }\n            if (recDpMask != null) {\n                prevOutput = tfc.mul(prevOutput, recDpMask);\n            }\n            var output = tfc.add(h, K.dot(prevOutput, _this.recurrentKernel.read()));\n            if (_this.activation != null) {\n                output = _this.activation.apply(output);\n            }\n            // TODO(cais): Properly set learning phase on output tensor?\n            return [output, output];\n        });\n    };\n    SimpleRNNCell.prototype.getConfig = function () {\n        var config = {\n            units: this.units,\n            activation: activations_1.serializeActivation(this.activation),\n            useBias: this.useBias,\n            kernelInitializer: initializers_1.serializeInitializer(this.kernelInitializer),\n            recurrentInitializer: initializers_1.serializeInitializer(this.recurrentInitializer),\n            biasInitializer: initializers_1.serializeInitializer(this.biasInitializer),\n            kernelRegularizer: regularizers_1.serializeRegularizer(this.kernelRegularizer),\n            recurrentRegularizer: regularizers_1.serializeRegularizer(this.recurrentRegularizer),\n            biasRegularizer: regularizers_1.serializeRegularizer(this.biasRegularizer),\n            activityRegularizer: regularizers_1.serializeRegularizer(this.activityRegularizer),\n            kernelConstraint: constraints_1.serializeConstraint(this.kernelConstraint),\n            recurrentConstraint: constraints_1.serializeConstraint(this.recurrentConstraint),\n            biasConstraint: constraints_1.serializeConstraint(this.biasConstraint),\n            dropout: this.dropout,\n            recurrentDropout: this.recurrentDropout,\n        };\n        var baseConfig = _super.prototype.getConfig.call(this);\n        Object.assign(config, baseConfig);\n        return config;\n    };\n    /** @nocollapse */\n    SimpleRNNCell.className = 'SimpleRNNCell';\n    return SimpleRNNCell;\n}(RNNCell));\nexports.SimpleRNNCell = SimpleRNNCell;\ntfjs_core_1.serialization.registerClass(SimpleRNNCell);\nvar SimpleRNN = /** @class */ (function (_super) {\n    __extends(SimpleRNN, _super);\n    function SimpleRNN(args) {\n        var _this = this;\n        args.cell = new SimpleRNNCell(args);\n        _this = _super.call(this, args) || this;\n        return _this;\n        // TODO(cais): Add activityRegularizer.\n    }\n    SimpleRNN.prototype.call = function (inputs, kwargs) {\n        var _this = this;\n        return tfjs_core_1.tidy(function () {\n            if (_this.cell.dropoutMask != null) {\n                tfc.dispose(_this.cell.dropoutMask);\n                _this.cell.dropoutMask = null;\n            }\n            if (_this.cell.recurrentDropoutMask != null) {\n                tfc.dispose(_this.cell.recurrentDropoutMask);\n                _this.cell.recurrentDropoutMask = null;\n            }\n            var mask = kwargs == null ? null : kwargs['mask'];\n            var training = kwargs == null ? null : kwargs['training'];\n            var initialState = kwargs == null ? null : kwargs['initialState'];\n            return _super.prototype.call.call(_this, inputs, { mask: mask, training: training, initialState: initialState });\n        });\n    };\n    Object.defineProperty(SimpleRNN.prototype, \"units\", {\n        // TODO(cais): Research possibility of refactoring out the tedious all\n        //   the getters that delegate to `this.cell` below.\n        get: function () {\n            return this.cell.units;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SimpleRNN.prototype, \"activation\", {\n        get: function () {\n            return this.cell.activation;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SimpleRNN.prototype, \"useBias\", {\n        get: function () {\n            return this.cell.useBias;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SimpleRNN.prototype, \"kernelInitializer\", {\n        get: function () {\n            return this.cell.kernelInitializer;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SimpleRNN.prototype, \"recurrentInitializer\", {\n        get: function () {\n            return this.cell.recurrentInitializer;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SimpleRNN.prototype, \"biasInitializer\", {\n        get: function () {\n            return this.cell.biasInitializer;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SimpleRNN.prototype, \"kernelRegularizer\", {\n        get: function () {\n            return this.cell.kernelRegularizer;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SimpleRNN.prototype, \"recurrentRegularizer\", {\n        get: function () {\n            return this.cell.recurrentRegularizer;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SimpleRNN.prototype, \"biasRegularizer\", {\n        get: function () {\n            return this.cell.biasRegularizer;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SimpleRNN.prototype, \"kernelConstraint\", {\n        get: function () {\n            return this.cell.kernelConstraint;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SimpleRNN.prototype, \"recurrentConstraint\", {\n        get: function () {\n            return this.cell.recurrentConstraint;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SimpleRNN.prototype, \"biasConstraint\", {\n        get: function () {\n            return this.cell.biasConstraint;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SimpleRNN.prototype, \"dropout\", {\n        get: function () {\n            return this.cell.dropout;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SimpleRNN.prototype, \"recurrentDropout\", {\n        get: function () {\n            return this.cell.recurrentDropout;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    SimpleRNN.prototype.getConfig = function () {\n        var config = {\n            units: this.units,\n            activation: activations_1.serializeActivation(this.activation),\n            useBias: this.useBias,\n            kernelInitializer: initializers_1.serializeInitializer(this.kernelInitializer),\n            recurrentInitializer: initializers_1.serializeInitializer(this.recurrentInitializer),\n            biasInitializer: initializers_1.serializeInitializer(this.biasInitializer),\n            kernelRegularizer: regularizers_1.serializeRegularizer(this.kernelRegularizer),\n            recurrentRegularizer: regularizers_1.serializeRegularizer(this.recurrentRegularizer),\n            biasRegularizer: regularizers_1.serializeRegularizer(this.biasRegularizer),\n            activityRegularizer: regularizers_1.serializeRegularizer(this.activityRegularizer),\n            kernelConstraint: constraints_1.serializeConstraint(this.kernelConstraint),\n            recurrentConstraint: constraints_1.serializeConstraint(this.recurrentConstraint),\n            biasConstraint: constraints_1.serializeConstraint(this.biasConstraint),\n            dropout: this.dropout,\n            recurrentDropout: this.recurrentDropout,\n        };\n        var baseConfig = _super.prototype.getConfig.call(this);\n        delete baseConfig['cell'];\n        Object.assign(config, baseConfig);\n        return config;\n    };\n    /** @nocollapse */\n    SimpleRNN.fromConfig = function (cls, config) {\n        return new cls(config);\n    };\n    /** @nocollapse */\n    SimpleRNN.className = 'SimpleRNN';\n    return SimpleRNN;\n}(RNN));\nexports.SimpleRNN = SimpleRNN;\ntfjs_core_1.serialization.registerClass(SimpleRNN);\nvar GRUCell = /** @class */ (function (_super) {\n    __extends(GRUCell, _super);\n    function GRUCell(args) {\n        var _this = _super.call(this, args) || this;\n        _this.DEFAULT_ACTIVATION = 'tanh';\n        _this.DEFAULT_RECURRENT_ACTIVATION = 'hardSigmoid';\n        _this.DEFAULT_KERNEL_INITIALIZER = 'glorotNormal';\n        _this.DEFAULT_RECURRENT_INITIALIZER = 'orthogonal';\n        _this.DEFAULT_BIAS_INITIALIZER = 'zeros';\n        _this.units = args.units;\n        generic_utils_1.assertPositiveInteger(_this.units, 'units');\n        _this.activation = activations_1.getActivation(args.activation === undefined ? _this.DEFAULT_ACTIVATION :\n            args.activation);\n        _this.recurrentActivation = activations_1.getActivation(args.recurrentActivation === undefined ?\n            _this.DEFAULT_RECURRENT_ACTIVATION :\n            args.recurrentActivation);\n        _this.useBias = args.useBias == null ? true : args.useBias;\n        _this.kernelInitializer = initializers_1.getInitializer(args.kernelInitializer || _this.DEFAULT_KERNEL_INITIALIZER);\n        _this.recurrentInitializer = initializers_1.getInitializer(args.recurrentInitializer || _this.DEFAULT_RECURRENT_INITIALIZER);\n        _this.biasInitializer =\n            initializers_1.getInitializer(args.biasInitializer || _this.DEFAULT_BIAS_INITIALIZER);\n        _this.kernelRegularizer = regularizers_1.getRegularizer(args.kernelRegularizer);\n        _this.recurrentRegularizer = regularizers_1.getRegularizer(args.recurrentRegularizer);\n        _this.biasRegularizer = regularizers_1.getRegularizer(args.biasRegularizer);\n        _this.kernelConstraint = constraints_1.getConstraint(args.kernelConstraint);\n        _this.recurrentConstraint = constraints_1.getConstraint(args.recurrentConstraint);\n        _this.biasConstraint = constraints_1.getConstraint(args.biasConstraint);\n        _this.dropout = math_utils.min([1, math_utils.max([0, args.dropout == null ? 0 : args.dropout])]);\n        _this.recurrentDropout = math_utils.min([\n            1,\n            math_utils.max([0, args.recurrentDropout == null ? 0 : args.recurrentDropout])\n        ]);\n        _this.implementation = args.implementation;\n        _this.stateSize = _this.units;\n        _this.dropoutMask = null;\n        _this.recurrentDropoutMask = null;\n        return _this;\n    }\n    GRUCell.prototype.build = function (inputShape) {\n        inputShape = types_utils_1.getExactlyOneShape(inputShape);\n        var inputDim = inputShape[inputShape.length - 1];\n        this.kernel = this.addWeight('kernel', [inputDim, this.units * 3], null, this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint);\n        this.recurrentKernel = this.addWeight('recurrent_kernel', [this.units, this.units * 3], null, this.recurrentInitializer, this.recurrentRegularizer, true, this.recurrentConstraint);\n        if (this.useBias) {\n            this.bias = this.addWeight('bias', [this.units * 3], null, this.biasInitializer, this.biasRegularizer, true, this.biasConstraint);\n        }\n        else {\n            this.bias = null;\n        }\n        // Porting Notes: Unlike the PyKeras implementation, we perform slicing\n        //   of the weights and bias in the call() method, at execution time.\n        this.built = true;\n    };\n    GRUCell.prototype.call = function (inputs, kwargs) {\n        var _this = this;\n        return tfjs_core_1.tidy(function () {\n            inputs = inputs;\n            if (inputs.length !== 2) {\n                throw new errors_1.ValueError(\"GRUCell expects 2 input Tensors (inputs, h, c), got \" +\n                    (inputs.length + \".\"));\n            }\n            var training = kwargs['training'] == null ? false : kwargs['training'];\n            var hTMinus1 = inputs[1]; // Previous memory state.\n            inputs = inputs[0];\n            // Note: For superior performance, TensorFlow.js always uses\n            // implementation 2, regardless of the actual value of\n            // config.implementation.\n            if (0 < _this.dropout && _this.dropout < 1 && _this.dropoutMask == null) {\n                _this.dropoutMask = generateDropoutMask(function () { return tfc.onesLike(inputs); }, _this.dropout, training, 3);\n            }\n            if (0 < _this.recurrentDropout && _this.recurrentDropout < 1 &&\n                _this.recurrentDropoutMask == null) {\n                _this.recurrentDropoutMask =\n                    generateDropoutMask(function () { return tfc.onesLike(hTMinus1); }, _this.recurrentDropout, training, 3);\n            }\n            var dpMask = _this.dropoutMask;\n            var recDpMask = _this.recurrentDropoutMask;\n            var z;\n            var r;\n            var hh;\n            if (0 < _this.dropout && _this.dropout < 1) {\n                inputs = tfc.mul(inputs, dpMask[0]);\n            }\n            var matrixX = K.dot(inputs, _this.kernel.read());\n            if (_this.useBias) {\n                matrixX = K.biasAdd(matrixX, _this.bias.read());\n            }\n            if (0 < _this.recurrentDropout && _this.recurrentDropout < 1) {\n                hTMinus1 = tfc.mul(hTMinus1, recDpMask[0]);\n            }\n            var recurrentKernelValue = _this.recurrentKernel.read();\n            var _a = tfc.split(recurrentKernelValue, [2 * _this.units, _this.units], recurrentKernelValue.rank - 1), rk1 = _a[0], rk2 = _a[1];\n            var matrixInner = K.dot(hTMinus1, rk1);\n            var _b = tfc.split(matrixX, 3, matrixX.rank - 1), xZ = _b[0], xR = _b[1], xH = _b[2];\n            var _c = tfc.split(matrixInner, 2, matrixInner.rank - 1), recurrentZ = _c[0], recurrentR = _c[1];\n            z = _this.recurrentActivation.apply(tfc.add(xZ, recurrentZ));\n            r = _this.recurrentActivation.apply(tfc.add(xR, recurrentR));\n            var recurrentH = K.dot(tfc.mul(r, hTMinus1), rk2);\n            hh = _this.activation.apply(tfc.add(xH, recurrentH));\n            var h = tfc.add(tfc.mul(z, hTMinus1), tfc.mul(tfc.add(1, tfc.neg(z)), hh));\n            // TODO(cais): Add use_learning_phase flag properly.\n            return [h, h];\n        });\n    };\n    GRUCell.prototype.getConfig = function () {\n        var config = {\n            units: this.units,\n            activation: activations_1.serializeActivation(this.activation),\n            recurrentActivation: activations_1.serializeActivation(this.recurrentActivation),\n            useBias: this.useBias,\n            kernelInitializer: initializers_1.serializeInitializer(this.kernelInitializer),\n            recurrentInitializer: initializers_1.serializeInitializer(this.recurrentInitializer),\n            biasInitializer: initializers_1.serializeInitializer(this.biasInitializer),\n            kernelRegularizer: regularizers_1.serializeRegularizer(this.kernelRegularizer),\n            recurrentRegularizer: regularizers_1.serializeRegularizer(this.recurrentRegularizer),\n            biasRegularizer: regularizers_1.serializeRegularizer(this.biasRegularizer),\n            activityRegularizer: regularizers_1.serializeRegularizer(this.activityRegularizer),\n            kernelConstraint: constraints_1.serializeConstraint(this.kernelConstraint),\n            recurrentConstraint: constraints_1.serializeConstraint(this.recurrentConstraint),\n            biasConstraint: constraints_1.serializeConstraint(this.biasConstraint),\n            dropout: this.dropout,\n            recurrentDropout: this.recurrentDropout,\n            implementation: this.implementation,\n        };\n        var baseConfig = _super.prototype.getConfig.call(this);\n        Object.assign(config, baseConfig);\n        return config;\n    };\n    /** @nocollapse */\n    GRUCell.className = 'GRUCell';\n    return GRUCell;\n}(RNNCell));\nexports.GRUCell = GRUCell;\ntfjs_core_1.serialization.registerClass(GRUCell);\nvar GRU = /** @class */ (function (_super) {\n    __extends(GRU, _super);\n    function GRU(args) {\n        var _this = this;\n        if (args.implementation === 0) {\n            console.warn('`implementation=0` has been deprecated, and now defaults to ' +\n                '`implementation=1`. Please update your layer call.');\n        }\n        args.cell = new GRUCell(args);\n        _this = _super.call(this, args) || this;\n        return _this;\n        // TODO(cais): Add activityRegularizer.\n    }\n    GRU.prototype.call = function (inputs, kwargs) {\n        var _this = this;\n        return tfjs_core_1.tidy(function () {\n            if (_this.cell.dropoutMask != null) {\n                tfc.dispose(_this.cell.dropoutMask);\n                _this.cell.dropoutMask = null;\n            }\n            if (_this.cell.recurrentDropoutMask != null) {\n                tfc.dispose(_this.cell.recurrentDropoutMask);\n                _this.cell.recurrentDropoutMask = null;\n            }\n            var mask = kwargs == null ? null : kwargs['mask'];\n            var training = kwargs == null ? null : kwargs['training'];\n            var initialState = kwargs == null ? null : kwargs['initialState'];\n            return _super.prototype.call.call(_this, inputs, { mask: mask, training: training, initialState: initialState });\n        });\n    };\n    Object.defineProperty(GRU.prototype, \"units\", {\n        get: function () {\n            return this.cell.units;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(GRU.prototype, \"activation\", {\n        get: function () {\n            return this.cell.activation;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(GRU.prototype, \"recurrentActivation\", {\n        get: function () {\n            return this.cell.recurrentActivation;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(GRU.prototype, \"useBias\", {\n        get: function () {\n            return this.cell.useBias;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(GRU.prototype, \"kernelInitializer\", {\n        get: function () {\n            return this.cell.kernelInitializer;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(GRU.prototype, \"recurrentInitializer\", {\n        get: function () {\n            return this.cell.recurrentInitializer;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(GRU.prototype, \"biasInitializer\", {\n        get: function () {\n            return this.cell.biasInitializer;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(GRU.prototype, \"kernelRegularizer\", {\n        get: function () {\n            return this.cell.kernelRegularizer;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(GRU.prototype, \"recurrentRegularizer\", {\n        get: function () {\n            return this.cell.recurrentRegularizer;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(GRU.prototype, \"biasRegularizer\", {\n        get: function () {\n            return this.cell.biasRegularizer;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(GRU.prototype, \"kernelConstraint\", {\n        get: function () {\n            return this.cell.kernelConstraint;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(GRU.prototype, \"recurrentConstraint\", {\n        get: function () {\n            return this.cell.recurrentConstraint;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(GRU.prototype, \"biasConstraint\", {\n        get: function () {\n            return this.cell.biasConstraint;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(GRU.prototype, \"dropout\", {\n        get: function () {\n            return this.cell.dropout;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(GRU.prototype, \"recurrentDropout\", {\n        get: function () {\n            return this.cell.recurrentDropout;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(GRU.prototype, \"implementation\", {\n        get: function () {\n            return this.cell.implementation;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    GRU.prototype.getConfig = function () {\n        var config = {\n            units: this.units,\n            activation: activations_1.serializeActivation(this.activation),\n            recurrentActivation: activations_1.serializeActivation(this.recurrentActivation),\n            useBias: this.useBias,\n            kernelInitializer: initializers_1.serializeInitializer(this.kernelInitializer),\n            recurrentInitializer: initializers_1.serializeInitializer(this.recurrentInitializer),\n            biasInitializer: initializers_1.serializeInitializer(this.biasInitializer),\n            kernelRegularizer: regularizers_1.serializeRegularizer(this.kernelRegularizer),\n            recurrentRegularizer: regularizers_1.serializeRegularizer(this.recurrentRegularizer),\n            biasRegularizer: regularizers_1.serializeRegularizer(this.biasRegularizer),\n            activityRegularizer: regularizers_1.serializeRegularizer(this.activityRegularizer),\n            kernelConstraint: constraints_1.serializeConstraint(this.kernelConstraint),\n            recurrentConstraint: constraints_1.serializeConstraint(this.recurrentConstraint),\n            biasConstraint: constraints_1.serializeConstraint(this.biasConstraint),\n            dropout: this.dropout,\n            recurrentDropout: this.recurrentDropout,\n            implementation: this.implementation,\n        };\n        var baseConfig = _super.prototype.getConfig.call(this);\n        delete baseConfig['cell'];\n        Object.assign(config, baseConfig);\n        return config;\n    };\n    /** @nocollapse */\n    GRU.fromConfig = function (cls, config) {\n        if (config['implmentation'] === 0) {\n            config['implementation'] = 1;\n        }\n        return new cls(config);\n    };\n    /** @nocollapse */\n    GRU.className = 'GRU';\n    return GRU;\n}(RNN));\nexports.GRU = GRU;\ntfjs_core_1.serialization.registerClass(GRU);\nvar LSTMCell = /** @class */ (function (_super) {\n    __extends(LSTMCell, _super);\n    function LSTMCell(args) {\n        var _this = _super.call(this, args) || this;\n        _this.DEFAULT_ACTIVATION = 'tanh';\n        _this.DEFAULT_RECURRENT_ACTIVATION = 'hardSigmoid';\n        _this.DEFAULT_KERNEL_INITIALIZER = 'glorotNormal';\n        _this.DEFAULT_RECURRENT_INITIALIZER = 'orthogonal';\n        _this.DEFAULT_BIAS_INITIALIZER = 'zeros';\n        _this.units = args.units;\n        generic_utils_1.assertPositiveInteger(_this.units, 'units');\n        _this.activation = activations_1.getActivation(args.activation === undefined ? _this.DEFAULT_ACTIVATION :\n            args.activation);\n        _this.recurrentActivation = activations_1.getActivation(args.recurrentActivation === undefined ?\n            _this.DEFAULT_RECURRENT_ACTIVATION :\n            args.recurrentActivation);\n        _this.useBias = args.useBias == null ? true : args.useBias;\n        _this.kernelInitializer = initializers_1.getInitializer(args.kernelInitializer || _this.DEFAULT_KERNEL_INITIALIZER);\n        _this.recurrentInitializer = initializers_1.getInitializer(args.recurrentInitializer || _this.DEFAULT_RECURRENT_INITIALIZER);\n        _this.biasInitializer =\n            initializers_1.getInitializer(args.biasInitializer || _this.DEFAULT_BIAS_INITIALIZER);\n        _this.unitForgetBias = args.unitForgetBias;\n        _this.kernelRegularizer = regularizers_1.getRegularizer(args.kernelRegularizer);\n        _this.recurrentRegularizer = regularizers_1.getRegularizer(args.recurrentRegularizer);\n        _this.biasRegularizer = regularizers_1.getRegularizer(args.biasRegularizer);\n        _this.kernelConstraint = constraints_1.getConstraint(args.kernelConstraint);\n        _this.recurrentConstraint = constraints_1.getConstraint(args.recurrentConstraint);\n        _this.biasConstraint = constraints_1.getConstraint(args.biasConstraint);\n        _this.dropout = math_utils.min([1, math_utils.max([0, args.dropout == null ? 0 : args.dropout])]);\n        _this.recurrentDropout = math_utils.min([\n            1,\n            math_utils.max([0, args.recurrentDropout == null ? 0 : args.recurrentDropout])\n        ]);\n        _this.implementation = args.implementation;\n        _this.stateSize = [_this.units, _this.units];\n        _this.dropoutMask = null;\n        _this.recurrentDropoutMask = null;\n        return _this;\n    }\n    LSTMCell.prototype.build = function (inputShape) {\n        var _a;\n        inputShape = types_utils_1.getExactlyOneShape(inputShape);\n        var inputDim = inputShape[inputShape.length - 1];\n        this.kernel = this.addWeight('kernel', [inputDim, this.units * 4], null, this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint);\n        this.recurrentKernel = this.addWeight('recurrent_kernel', [this.units, this.units * 4], null, this.recurrentInitializer, this.recurrentRegularizer, true, this.recurrentConstraint);\n        var biasInitializer;\n        if (this.useBias) {\n            if (this.unitForgetBias) {\n                var capturedBiasInit_1 = this.biasInitializer;\n                var capturedUnits_1 = this.units;\n                biasInitializer = new (_a = /** @class */ (function (_super) {\n                        __extends(CustomInit, _super);\n                        function CustomInit() {\n                            return _super !== null && _super.apply(this, arguments) || this;\n                        }\n                        CustomInit.prototype.apply = function (shape, dtype) {\n                            // TODO(cais): More informative variable names?\n                            var bI = capturedBiasInit_1.apply([capturedUnits_1]);\n                            var bF = (new initializers_1.Ones()).apply([capturedUnits_1]);\n                            var bCAndH = capturedBiasInit_1.apply([capturedUnits_1 * 2]);\n                            return K.concatAlongFirstAxis(K.concatAlongFirstAxis(bI, bF), bCAndH);\n                        };\n                        return CustomInit;\n                    }(initializers_1.Initializer)),\n                    /** @nocollapse */\n                    _a.className = 'CustomInit',\n                    _a)();\n            }\n            else {\n                biasInitializer = this.biasInitializer;\n            }\n            this.bias = this.addWeight('bias', [this.units * 4], null, biasInitializer, this.biasRegularizer, true, this.biasConstraint);\n        }\n        else {\n            this.bias = null;\n        }\n        // Porting Notes: Unlike the PyKeras implementation, we perform slicing\n        //   of the weights and bias in the call() method, at execution time.\n        this.built = true;\n    };\n    LSTMCell.prototype.call = function (inputs, kwargs) {\n        var _this = this;\n        return tfjs_core_1.tidy(function () {\n            var training = kwargs['training'] == null ? false : kwargs['training'];\n            inputs = inputs;\n            if (inputs.length !== 3) {\n                throw new errors_1.ValueError(\"LSTMCell expects 3 input Tensors (inputs, h, c), got \" +\n                    (inputs.length + \".\"));\n            }\n            var hTMinus1 = inputs[1]; // Previous memory state.\n            var cTMinus1 = inputs[2]; // Previous carry state.\n            inputs = inputs[0];\n            if (0 < _this.dropout && _this.dropout < 1 && _this.dropoutMask == null) {\n                _this.dropoutMask = generateDropoutMask(function () { return tfc.onesLike(inputs); }, _this.dropout, training, 4);\n            }\n            if (0 < _this.recurrentDropout && _this.recurrentDropout < 1 &&\n                _this.recurrentDropoutMask == null) {\n                _this.recurrentDropoutMask =\n                    generateDropoutMask(function () { return tfc.onesLike(hTMinus1); }, _this.recurrentDropout, training, 4);\n            }\n            var dpMask = _this.dropoutMask;\n            var recDpMask = _this.recurrentDropoutMask;\n            // Note: For superior performance, TensorFlow.js always uses\n            // implementation 2 regardless of the actual value of\n            // config.implementation.\n            var i;\n            var f;\n            var c;\n            var o;\n            if (0 < _this.dropout && _this.dropout < 1) {\n                inputs = tfc.mul(inputs, dpMask[0]);\n            }\n            var z = K.dot(inputs, _this.kernel.read());\n            if (0 < _this.recurrentDropout && _this.recurrentDropout < 1) {\n                hTMinus1 = tfc.mul(hTMinus1, recDpMask[0]);\n            }\n            z = tfc.add(z, K.dot(hTMinus1, _this.recurrentKernel.read()));\n            if (_this.useBias) {\n                z = K.biasAdd(z, _this.bias.read());\n            }\n            var _a = tfc.split(z, 4, z.rank - 1), z0 = _a[0], z1 = _a[1], z2 = _a[2], z3 = _a[3];\n            i = _this.recurrentActivation.apply(z0);\n            f = _this.recurrentActivation.apply(z1);\n            c = tfc.add(tfc.mul(f, cTMinus1), tfc.mul(i, _this.activation.apply(z2)));\n            o = _this.recurrentActivation.apply(z3);\n            var h = tfc.mul(o, _this.activation.apply(c));\n            // TODO(cais): Add use_learning_phase flag properly.\n            return [h, h, c];\n        });\n    };\n    LSTMCell.prototype.getConfig = function () {\n        var config = {\n            units: this.units,\n            activation: activations_1.serializeActivation(this.activation),\n            recurrentActivation: activations_1.serializeActivation(this.recurrentActivation),\n            useBias: this.useBias,\n            kernelInitializer: initializers_1.serializeInitializer(this.kernelInitializer),\n            recurrentInitializer: initializers_1.serializeInitializer(this.recurrentInitializer),\n            biasInitializer: initializers_1.serializeInitializer(this.biasInitializer),\n            unitForgetBias: this.unitForgetBias,\n            kernelRegularizer: regularizers_1.serializeRegularizer(this.kernelRegularizer),\n            recurrentRegularizer: regularizers_1.serializeRegularizer(this.recurrentRegularizer),\n            biasRegularizer: regularizers_1.serializeRegularizer(this.biasRegularizer),\n            activityRegularizer: regularizers_1.serializeRegularizer(this.activityRegularizer),\n            kernelConstraint: constraints_1.serializeConstraint(this.kernelConstraint),\n            recurrentConstraint: constraints_1.serializeConstraint(this.recurrentConstraint),\n            biasConstraint: constraints_1.serializeConstraint(this.biasConstraint),\n            dropout: this.dropout,\n            recurrentDropout: this.recurrentDropout,\n            implementation: this.implementation,\n        };\n        var baseConfig = _super.prototype.getConfig.call(this);\n        Object.assign(config, baseConfig);\n        return config;\n    };\n    /** @nocollapse */\n    LSTMCell.className = 'LSTMCell';\n    return LSTMCell;\n}(RNNCell));\nexports.LSTMCell = LSTMCell;\ntfjs_core_1.serialization.registerClass(LSTMCell);\nvar LSTM = /** @class */ (function (_super) {\n    __extends(LSTM, _super);\n    function LSTM(args) {\n        var _this = this;\n        if (args.implementation === 0) {\n            console.warn('`implementation=0` has been deprecated, and now defaults to ' +\n                '`implementation=1`. Please update your layer call.');\n        }\n        args.cell = new LSTMCell(args);\n        _this = _super.call(this, args) || this;\n        return _this;\n        // TODO(cais): Add activityRegularizer.\n    }\n    LSTM.prototype.call = function (inputs, kwargs) {\n        var _this = this;\n        return tfjs_core_1.tidy(function () {\n            if (_this.cell.dropoutMask != null) {\n                tfc.dispose(_this.cell.dropoutMask);\n                _this.cell.dropoutMask = null;\n            }\n            if (_this.cell.recurrentDropoutMask != null) {\n                tfc.dispose(_this.cell.recurrentDropoutMask);\n                _this.cell.recurrentDropoutMask = null;\n            }\n            var mask = kwargs == null ? null : kwargs['mask'];\n            var training = kwargs == null ? null : kwargs['training'];\n            var initialState = kwargs == null ? null : kwargs['initialState'];\n            return _super.prototype.call.call(_this, inputs, { mask: mask, training: training, initialState: initialState });\n        });\n    };\n    Object.defineProperty(LSTM.prototype, \"units\", {\n        get: function () {\n            return this.cell.units;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(LSTM.prototype, \"activation\", {\n        get: function () {\n            return this.cell.activation;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(LSTM.prototype, \"recurrentActivation\", {\n        get: function () {\n            return this.cell.recurrentActivation;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(LSTM.prototype, \"useBias\", {\n        get: function () {\n            return this.cell.useBias;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(LSTM.prototype, \"kernelInitializer\", {\n        get: function () {\n            return this.cell.kernelInitializer;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(LSTM.prototype, \"recurrentInitializer\", {\n        get: function () {\n            return this.cell.recurrentInitializer;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(LSTM.prototype, \"biasInitializer\", {\n        get: function () {\n            return this.cell.biasInitializer;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(LSTM.prototype, \"unitForgetBias\", {\n        get: function () {\n            return this.cell.unitForgetBias;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(LSTM.prototype, \"kernelRegularizer\", {\n        get: function () {\n            return this.cell.kernelRegularizer;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(LSTM.prototype, \"recurrentRegularizer\", {\n        get: function () {\n            return this.cell.recurrentRegularizer;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(LSTM.prototype, \"biasRegularizer\", {\n        get: function () {\n            return this.cell.biasRegularizer;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(LSTM.prototype, \"kernelConstraint\", {\n        get: function () {\n            return this.cell.kernelConstraint;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(LSTM.prototype, \"recurrentConstraint\", {\n        get: function () {\n            return this.cell.recurrentConstraint;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(LSTM.prototype, \"biasConstraint\", {\n        get: function () {\n            return this.cell.biasConstraint;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(LSTM.prototype, \"dropout\", {\n        get: function () {\n            return this.cell.dropout;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(LSTM.prototype, \"recurrentDropout\", {\n        get: function () {\n            return this.cell.recurrentDropout;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(LSTM.prototype, \"implementation\", {\n        get: function () {\n            return this.cell.implementation;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    LSTM.prototype.getConfig = function () {\n        var config = {\n            units: this.units,\n            activation: activations_1.serializeActivation(this.activation),\n            recurrentActivation: activations_1.serializeActivation(this.recurrentActivation),\n            useBias: this.useBias,\n            kernelInitializer: initializers_1.serializeInitializer(this.kernelInitializer),\n            recurrentInitializer: initializers_1.serializeInitializer(this.recurrentInitializer),\n            biasInitializer: initializers_1.serializeInitializer(this.biasInitializer),\n            unitForgetBias: this.unitForgetBias,\n            kernelRegularizer: regularizers_1.serializeRegularizer(this.kernelRegularizer),\n            recurrentRegularizer: regularizers_1.serializeRegularizer(this.recurrentRegularizer),\n            biasRegularizer: regularizers_1.serializeRegularizer(this.biasRegularizer),\n            activityRegularizer: regularizers_1.serializeRegularizer(this.activityRegularizer),\n            kernelConstraint: constraints_1.serializeConstraint(this.kernelConstraint),\n            recurrentConstraint: constraints_1.serializeConstraint(this.recurrentConstraint),\n            biasConstraint: constraints_1.serializeConstraint(this.biasConstraint),\n            dropout: this.dropout,\n            recurrentDropout: this.recurrentDropout,\n            implementation: this.implementation,\n        };\n        var baseConfig = _super.prototype.getConfig.call(this);\n        delete baseConfig['cell'];\n        Object.assign(config, baseConfig);\n        return config;\n    };\n    /** @nocollapse */\n    LSTM.fromConfig = function (cls, config) {\n        if (config['implmentation'] === 0) {\n            config['implementation'] = 1;\n        }\n        return new cls(config);\n    };\n    /** @nocollapse */\n    LSTM.className = 'LSTM';\n    return LSTM;\n}(RNN));\nexports.LSTM = LSTM;\ntfjs_core_1.serialization.registerClass(LSTM);\nvar StackedRNNCells = /** @class */ (function (_super) {\n    __extends(StackedRNNCells, _super);\n    function StackedRNNCells(args) {\n        var _this = _super.call(this, args) || this;\n        _this.cells = args.cells;\n        return _this;\n    }\n    Object.defineProperty(StackedRNNCells.prototype, \"stateSize\", {\n        get: function () {\n            // States are a flat list in reverse order of the cell stack.\n            // This allows perserving the requirement `stack.statesize[0] ===\n            // outputDim`. E.g., states of a 2-layer LSTM would be `[h2, c2, h1, c1]`,\n            // assuming one LSTM has states `[h, c]`.\n            var stateSize = [];\n            for (var _i = 0, _a = this.cells.slice().reverse(); _i < _a.length; _i++) {\n                var cell = _a[_i];\n                if (Array.isArray(cell.stateSize)) {\n                    stateSize.push.apply(stateSize, cell.stateSize);\n                }\n                else {\n                    stateSize.push(cell.stateSize);\n                }\n            }\n            return stateSize;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    StackedRNNCells.prototype.call = function (inputs, kwargs) {\n        var _this = this;\n        return tfjs_core_1.tidy(function () {\n            inputs = inputs;\n            var states = inputs.slice(1);\n            // Recover per-cell states.\n            var nestedStates = [];\n            for (var _i = 0, _a = _this.cells.slice().reverse(); _i < _a.length; _i++) {\n                var cell = _a[_i];\n                if (Array.isArray(cell.stateSize)) {\n                    nestedStates.push(states.splice(0, cell.stateSize.length));\n                }\n                else {\n                    nestedStates.push(states.splice(0, 1));\n                }\n            }\n            nestedStates.reverse();\n            // Call the cells in order and store the returned states.\n            var newNestedStates = [];\n            var callInputs;\n            for (var i = 0; i < _this.cells.length; ++i) {\n                var cell = _this.cells[i];\n                states = nestedStates[i];\n                // TODO(cais): Take care of constants.\n                if (i === 0) {\n                    callInputs = [inputs[0]].concat(states);\n                }\n                else {\n                    callInputs = [callInputs[0]].concat(states);\n                }\n                callInputs = cell.call(callInputs, kwargs);\n                newNestedStates.push(callInputs.slice(1));\n            }\n            // Format the new states as a flat list in reverse cell order.\n            states = [];\n            for (var _b = 0, _c = newNestedStates.slice().reverse(); _b < _c.length; _b++) {\n                var cellStates = _c[_b];\n                states.push.apply(states, cellStates);\n            }\n            return [callInputs[0]].concat(states);\n        });\n    };\n    StackedRNNCells.prototype.build = function (inputShape) {\n        if (types_utils_1.isArrayOfShapes(inputShape)) {\n            // TODO(cais): Take care of input constants.\n            // const constantShape = inputShape.slice(1);\n            inputShape = inputShape[0];\n        }\n        inputShape = inputShape;\n        var outputDim;\n        this.cells.forEach(function (cell, i) {\n            common_1.nameScope(\"RNNCell_\" + i, function () {\n                // TODO(cais): Take care of input constants.\n                cell.build(inputShape);\n                if (Array.isArray(cell.stateSize)) {\n                    outputDim = cell.stateSize[0];\n                }\n                else {\n                    outputDim = cell.stateSize;\n                }\n                inputShape = [inputShape[0], outputDim];\n            });\n        });\n        this.built = true;\n    };\n    StackedRNNCells.prototype.getConfig = function () {\n        var cellConfigs = [];\n        for (var _i = 0, _a = this.cells; _i < _a.length; _i++) {\n            var cell = _a[_i];\n            cellConfigs.push({\n                'className': cell.getClassName(),\n                'config': cell.getConfig(),\n            });\n        }\n        var config = { 'cells': cellConfigs };\n        var baseConfig = _super.prototype.getConfig.call(this);\n        Object.assign(config, baseConfig);\n        return config;\n    };\n    /** @nocollapse */\n    StackedRNNCells.fromConfig = function (cls, config, customObjects) {\n        if (customObjects === void 0) { customObjects = {}; }\n        var cells = [];\n        for (var _i = 0, _a = config['cells']; _i < _a.length; _i++) {\n            var cellConfig = _a[_i];\n            cells.push(serialization_1.deserialize(cellConfig, customObjects));\n        }\n        return new cls({ cells: cells });\n    };\n    Object.defineProperty(StackedRNNCells.prototype, \"trainableWeights\", {\n        get: function () {\n            if (!this.trainable) {\n                return [];\n            }\n            var weights = [];\n            for (var _i = 0, _a = this.cells; _i < _a.length; _i++) {\n                var cell = _a[_i];\n                weights.push.apply(weights, cell.trainableWeights);\n            }\n            return weights;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(StackedRNNCells.prototype, \"nonTrainableWeights\", {\n        get: function () {\n            var weights = [];\n            for (var _i = 0, _a = this.cells; _i < _a.length; _i++) {\n                var cell = _a[_i];\n                weights.push.apply(weights, cell.nonTrainableWeights);\n            }\n            if (!this.trainable) {\n                var trainableWeights = [];\n                for (var _b = 0, _c = this.cells; _b < _c.length; _b++) {\n                    var cell = _c[_b];\n                    trainableWeights.push.apply(trainableWeights, cell.trainableWeights);\n                }\n                return trainableWeights.concat(weights);\n            }\n            return weights;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Retrieve the weights of a the model.\n     *\n     * @returns A flat `Array` of `tf.Tensor`s.\n     */\n    StackedRNNCells.prototype.getWeights = function () {\n        var weights = [];\n        for (var _i = 0, _a = this.cells; _i < _a.length; _i++) {\n            var cell = _a[_i];\n            weights.push.apply(weights, cell.weights);\n        }\n        return variables_1.batchGetValue(weights);\n    };\n    /**\n     * Set the weights of the model.\n     *\n     * @param weights An `Array` of `tf.Tensor`s with shapes and types matching\n     *     the output of `getWeights()`.\n     */\n    StackedRNNCells.prototype.setWeights = function (weights) {\n        var tuples = [];\n        for (var _i = 0, _a = this.cells; _i < _a.length; _i++) {\n            var cell = _a[_i];\n            var numParams = cell.weights.length;\n            var inputWeights = weights.splice(numParams);\n            for (var i = 0; i < cell.weights.length; ++i) {\n                tuples.push([cell.weights[i], inputWeights[i]]);\n            }\n        }\n        variables_1.batchSetValue(tuples);\n    };\n    /** @nocollapse */\n    StackedRNNCells.className = 'StackedRNNCells';\n    return StackedRNNCells;\n}(RNNCell));\nexports.StackedRNNCells = StackedRNNCells;\ntfjs_core_1.serialization.registerClass(StackedRNNCells);\nfunction generateDropoutMask(ones, rate, training, count) {\n    if (training === void 0) { training = null; }\n    if (count === void 0) { count = 1; }\n    function droppedInputs() {\n        return K.dropout(ones(), rate);\n    }\n    if (count > 1) {\n        var mask = [];\n        for (var i = 0; i < count; i++) {\n            mask.push(K.inTrainPhase(droppedInputs, ones, training));\n        }\n        return mask.map(function (m) { return tfc.keep(m.clone()); });\n    }\n    else {\n        return tfc.keep(K.inTrainPhase(droppedInputs, ones, training).clone());\n    }\n}\n"},"sourceMaps":{"js":{"version":3,"file":"recurrent.js","sourceRoot":"","sources":["../../src/layers/recurrent.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n\n/**\n * TensorFlow.js Layers: Recurrent Neural Network Layers.\n */\n\nimport * as tfc from '@tensorflow/tfjs-core';\nimport {DataType, serialization, Tensor, tidy, util} from '@tensorflow/tfjs-core';\n\nimport {Activation, getActivation, serializeActivation} from '../activations';\nimport * as K from '../backend/tfjs_backend';\nimport {nameScope} from '../common';\nimport {Constraint, ConstraintIdentifier, getConstraint, serializeConstraint} from '../constraints';\nimport {InputSpec, SymbolicTensor} from '../engine/topology';\nimport {Layer, LayerArgs} from '../engine/topology';\nimport {AttributeError, NotImplementedError, ValueError} from '../errors';\nimport {getInitializer, Initializer, InitializerIdentifier, Ones, serializeInitializer} from '../initializers';\nimport {ActivationIdentifier} from '../keras_format/activation_config';\nimport {Shape} from '../keras_format/common';\nimport {getRegularizer, Regularizer, RegularizerIdentifier, serializeRegularizer} from '../regularizers';\nimport {Kwargs, RnnStepFunction} from '../types';\nimport {assertPositiveInteger} from '../utils/generic_utils';\nimport * as math_utils from '../utils/math_utils';\nimport {getExactlyOneShape, getExactlyOneTensor, isArrayOfShapes} from '../utils/types_utils';\nimport {batchGetValue, batchSetValue, LayerVariable} from '../variables';\nimport {deserialize} from './serialization';\n\n/**\n * Standardize `apply()` args to a single list of tensor inputs.\n *\n * When running a model loaded from file, the input tensors `initialState` and\n * `constants` are passed to `RNN.apply()` as part of `inputs` instead of the\n * dedicated kwargs fields. `inputs` consists of\n * `[inputs, initialState0, initialState1, ..., constant0, constant1]` in this\n * case.\n * This method makes sure that arguments are\n * separated and that `initialState` and `constants` are `Array`s of tensors\n * (or None).\n *\n * @param inputs Tensor or `Array` of  tensors.\n * @param initialState Tensor or `Array` of tensors or `null`/`undefined`.\n * @param constants Tensor or `Array` of tensors or `null`/`undefined`.\n * @returns An object consisting of\n *   inputs: A tensor.\n *   initialState: `Array` of tensors or `null`.\n *   constants: `Array` of tensors or `null`.\n * @throws ValueError, if `inputs` is an `Array` but either `initialState` or\n *   `constants` is provided.\n */\nexport function standardizeArgs(\n    inputs: Tensor|Tensor[]|SymbolicTensor|SymbolicTensor[],\n    initialState: Tensor|Tensor[]|SymbolicTensor|SymbolicTensor[],\n    constants: Tensor|Tensor[]|SymbolicTensor|SymbolicTensor[],\n    numConstants?: number): {\n  inputs: Tensor|SymbolicTensor,\n  initialState: Tensor[]|SymbolicTensor[],\n  constants: Tensor[]|SymbolicTensor[]\n} {\n  if (Array.isArray(inputs)) {\n    if (initialState != null || constants != null) {\n      throw new ValueError(\n          'When inputs is an array, neither initialState or constants ' +\n          'should be provided');\n    }\n    if (numConstants != null) {\n      constants = inputs.slice(inputs.length - numConstants, inputs.length);\n      inputs = inputs.slice(0, inputs.length - numConstants);\n    }\n    if (inputs.length > 1) {\n      initialState = inputs.slice(1, inputs.length);\n    }\n    inputs = inputs[0];\n  }\n\n  function toListOrNull(x: Tensor|Tensor[]|SymbolicTensor|\n                        SymbolicTensor[]): Tensor[]|SymbolicTensor[] {\n    if (x == null || Array.isArray(x)) {\n      return x as Tensor[] | SymbolicTensor[];\n    } else {\n      return [x] as Tensor[] | SymbolicTensor[];\n    }\n  }\n\n  initialState = toListOrNull(initialState);\n  constants = toListOrNull(constants);\n\n  return {inputs, initialState, constants};\n}\n\n/**\n * Iterates over the time dimension of a tensor.\n *\n * @param stepFunction RNN step function.\n *   Parameters:\n *     inputs: tensor with shape `[samples, ...]` (no time dimension),\n *       representing input for the batch of samples at a certain time step.\n *     states: an Array of tensors.\n *   Returns:\n *     outputs: tensor with shape `[samples, outputDim]` (no time dimension).\n *     newStates: list of tensors, same length and shapes as `states`. The first\n *       state in the list must be the output tensor at the previous timestep.\n * @param inputs Tensor of temporal data of shape `[samples, time, ...]` (at\n *   least 3D).\n * @param initialStates Tensor with shape `[samples, outputDim]` (no time\n *   dimension), containing the initial values of the states used in the step\n *   function.\n * @param goBackwards If `true`, do the iteration over the time dimension in\n *   reverse order and return the reversed sequence.\n * @param mask Binary tensor with shape `[sample, time, 1]`, with a zero for\n *   every element that is masked.\n * @param constants An Array of constant values passed at each step.\n * @param unroll Whether to unroll the RNN or to use a symbolic loop. *Not*\n *   applicable to this imperative deeplearn.js backend. Its value is ignored.\n * @param needPerStepOutputs Whether the per-step outputs are to be\n *   concatenated into a single tensor and returned (as the second return\n *   value). Default: `false`. This arg is included so that the relatively\n *   expensive concatenation of the stepwise outputs can be omitted unless\n *   the stepwise outputs need to be kept (e.g., for an LSTM layer of which\n *   `returnSequence` is `true`.)\n * @returns An Array: `[lastOutput, outputs, newStates]`.\n *   lastOutput: the lastest output of the RNN, of shape `[samples, ...]`.\n *   outputs: tensor with shape `[samples, time, ...]` where each entry\n *     `output[s, t]` is the output of the step function at time `t` for sample\n *     `s`. This return value is provided if and only if the\n *     `needPerStepOutputs` is set as `true`. If it is set as `false`, this\n *     return value will be `undefined`.\n *   newStates: Array of tensors, latest states returned by the step function,\n *      of shape `(samples, ...)`.\n * @throws ValueError If input dimension is less than 3.\n *\n * TODO(nielsene): This needs to be tidy-ed.\n */\nexport function rnn(\n    stepFunction: RnnStepFunction, inputs: Tensor, initialStates: Tensor[],\n    goBackwards = false, mask?: Tensor, constants?: Tensor[], unroll = false,\n    needPerStepOutputs = false): [Tensor, Tensor, Tensor[]] {\n  return tfc.tidy(() => {\n    const ndim = inputs.shape.length;\n    if (ndim < 3) {\n      throw new ValueError(`Input should be at least 3D, but is ${ndim}D.`);\n    }\n\n    // Transpose to time-major, i.e., from [batch, time, ...] to [time, batch,\n    // ...].\n    const axes = [1, 0].concat(math_utils.range(2, ndim));\n    inputs = tfc.transpose(inputs, axes);\n\n    if (constants != null) {\n      throw new NotImplementedError(\n          'The rnn() functoin of the deeplearn.js backend does not support ' +\n          'constants yet.');\n    }\n\n    // Porting Note: the unroll option is ignored by the imperative backend.\n    if (unroll) {\n      console.warn(\n          'Backend rnn(): the unroll = true option is not applicable to the ' +\n          'imperative deeplearn.js backend.');\n    }\n\n    if (mask != null) {\n      mask = mask.asType('bool').asType('float32');\n      if (mask.rank === ndim - 1) {\n        mask = tfc.expandDims(mask, -1);\n      }\n      mask = tfc.transpose(mask, axes);\n    }\n\n    if (goBackwards) {\n      inputs = tfc.reverse(inputs, 0);\n      if (mask != null) {\n        mask = tfc.reverse(mask, 0);\n      }\n    }\n\n    // Porting Note: PyKeras with TensorFlow backend uses a symbolic loop\n    //   (tf.while_loop). But for the imperative deeplearn.js backend, we just\n    //   use the usual TypeScript control flow to iterate over the time steps in\n    //   the inputs.\n    // Porting Note: PyKeras patches a \"_use_learning_phase\" attribute to\n    // outputs.\n    //   This is not idiomatic in TypeScript. The info regarding whether we are\n    //   in a learning (i.e., training) phase for RNN is passed in a different\n    //   way.\n\n    const perStepOutputs: Tensor[] = [];\n    let lastOutput: Tensor;\n    let states = initialStates;\n    const timeSteps = inputs.shape[0];\n    const perStepInputs = tfc.unstack(inputs);\n    let perStepMasks: Tensor[];\n    if (mask != null) {\n      perStepMasks = tfc.unstack(mask);\n    }\n\n    for (let t = 0; t < timeSteps; ++t) {\n      const currentInput = perStepInputs[t];\n      const stepOutputs = tfc.tidy(() => stepFunction(currentInput, states));\n\n      if (mask == null) {\n        lastOutput = stepOutputs[0];\n        states = stepOutputs[1];\n      } else {\n        const maskedOutputs = tfc.tidy(() => {\n          const stepMask = perStepMasks[t];\n          const negStepMask = tfc.onesLike(stepMask).sub(stepMask);\n          // TODO(cais): Would tfc.where() be better for performance?\n          const output = stepOutputs[0].mul(stepMask).addStrict(\n              states[0].mul(negStepMask));\n          const newStates = states.map((state, i) => {\n            return stepOutputs[1][i].mul(stepMask).addStrict(\n                state.mul(negStepMask));\n          });\n          return {output, newStates};\n        });\n        lastOutput = maskedOutputs.output;\n        states = maskedOutputs.newStates;\n      }\n\n      if (needPerStepOutputs) {\n        perStepOutputs.push(lastOutput);\n      }\n    }\n    let outputs: Tensor;\n    if (needPerStepOutputs) {\n      const axis = 1;\n      outputs = tfc.stack(perStepOutputs, axis);\n    }\n    return [lastOutput, outputs, states] as [Tensor, Tensor, Tensor[]];\n  });\n}\n\nexport declare interface BaseRNNLayerArgs extends LayerArgs {\n  /**\n   * A RNN cell instance. A RNN cell is a class that has:\n   *   - a `call()` method, which takes `[Tensor, Tensor]` as the\n   *     first input argument. The first item is the input at time t, and\n   *     second item is the cell state at time t.\n   *     The `call()` method returns `[outputAtT, statesAtTPlus1]`.\n   *     The `call()` method of the cell can also take the argument `constants`,\n   *     see section \"Note on passing external constants\" below.\n   *     Porting Node: PyKeras overrides the `call()` signature of RNN cells,\n   *       which are Layer subtypes, to accept two arguments. tfjs-layers does\n   *       not do such overriding. Instead we preseve the `call()` signature,\n   *       which due to its `Tensor|Tensor[]` argument and return value, is\n   *       flexible enough to handle the inputs and states.\n   *   - a `stateSize` attribute. This can be a single integer (single state)\n   *     in which case it is the size of the recurrent state (which should be\n   *     the same as the size of the cell output). This can also be an Array of\n   *     integers (one size per state). In this case, the first entry\n   *     (`stateSize[0]`) should be the same as the size of the cell output.\n   * It is also possible for `cell` to be a list of RNN cell instances, in which\n   * case the cells get stacked on after the other in the RNN, implementing an\n   * efficient stacked RNN.\n   */\n  cell?: RNNCell|RNNCell[];\n\n  /**\n   * Whether to return the last output in the output sequence, or the full\n   * sequence.\n   */\n  returnSequences?: boolean;\n\n  /**\n   * Whether to return the last state in addition to the output.\n   */\n  returnState?: boolean;\n\n  /**\n   * If `true`, process the input sequence backwards and return the reversed\n   * sequence (default: `false`).\n   */\n  goBackwards?: boolean;\n\n  /**\n   * If `true`, the last state for each sample at index i in a batch will be\n   * used as initial state of the sample of index i in the following batch\n   * (default: `false`).\n   *\n   * You can set RNN layers to be \"stateful\", which means that the states\n   * computed for the samples in one batch will be reused as initial states\n   * for the samples in the next batch. This assumes a one-to-one mapping\n   * between samples in different successive batches.\n   *\n   * To enable \"statefulness\":\n   *   - specify `stateful: true` in the layer constructor.\n   *   - specify a fixed batch size for your model, by passing\n   *     - if sequential model:\n   *       `batchInputShape: [...]` to the first layer in your model.\n   *     - else for functional model with 1 or more Input layers:\n   *       `batchShape: [...]` to all the first layers in your model.\n   *     This is the expected shape of your inputs\n   *     *including the batch size*.\n   *     It should be a tuple of integers, e.g., `[32, 10, 100]`.\n   *   - specify `shuffle: false` when calling `LayersModel.fit()`.\n   *\n   * To reset the state of your model, call `resetStates()` on either the\n   * specific layer or on the entire model.\n   */\n  stateful?: boolean;\n  // TODO(cais): Explore whether we can warn users when they fail to set\n  //   `shuffle: false` when training a model consisting of stateful RNNs\n  //   and any stateful Layers in general.\n\n  /**\n   * If `true`, the network will be unrolled, else a symbolic loop will be\n   * used. Unrolling can speed-up a RNN, although it tends to be more memory-\n   * intensive. Unrolling is only suitable for short sequences (default:\n   * `false`).\n   * Porting Note: tfjs-layers has an imperative backend. RNNs are executed with\n   *   normal TypeScript control flow. Hence this property is inapplicable and\n   *   ignored in tfjs-layers.\n   */\n  unroll?: boolean;\n\n  /**\n   * Dimensionality of the input (integer).\n   *   This option (or alternatively, the option `inputShape`) is required when\n   *   this layer is used as the first layer in a model.\n   */\n  inputDim?: number;\n\n  /**\n   * Length of the input sequences, to be specified when it is constant.\n   * This argument is required if you are going to connect `Flatten` then\n   * `Dense` layers upstream (without it, the shape of the dense outputs cannot\n   * be computed). Note that if the recurrent layer is not the first layer in\n   * your model, you would need to specify the input length at the level of the\n   * first layer (e.g., via the `inputShape` option).\n   */\n  inputLength?: number;\n}\n\nexport class RNN extends Layer {\n  /** @nocollapse */\n  static className = 'RNN';\n  public readonly cell: RNNCell;\n  public readonly returnSequences: boolean;\n  public readonly returnState: boolean;\n  public readonly goBackwards: boolean;\n  public readonly unroll: boolean;\n\n  public stateSpec: InputSpec[];\n  private states_: Tensor[];\n\n  // NOTE(cais): For stateful RNNs, the old states cannot be disposed right\n  // away when new states are set, because the old states may need to be used\n  // later for backpropagation through time (BPTT) and other purposes. So we\n  // keep them here for final disposal when the state is reset completely\n  // (i.e., through no-arg call to `resetStates()`).\n  private keptStates: Tensor[][];\n\n  private numConstants: number;\n\n  constructor(args: RNNLayerArgs) {\n    super(args);\n    let cell: RNNCell;\n    if (args.cell == null) {\n      throw new ValueError(\n          'cell property is missing for the constructor of RNN.');\n    } else if (Array.isArray(args.cell)) {\n      cell = new StackedRNNCells({cells: args.cell});\n    } else {\n      cell = args.cell;\n    }\n    if (cell.stateSize == null) {\n      throw new ValueError(\n          'The RNN cell should have an attribute `stateSize` (tuple of ' +\n          'integers, one integer per RNN state).');\n    }\n    this.cell = cell;\n    this.returnSequences =\n        args.returnSequences == null ? false : args.returnSequences;\n    this.returnState = args.returnState == null ? false : args.returnState;\n    this.goBackwards = args.goBackwards == null ? false : args.goBackwards;\n    this._stateful = args.stateful == null ? false : args.stateful;\n    this.unroll = args.unroll == null ? false : args.unroll;\n\n    this.supportsMasking = true;\n    this.inputSpec = [new InputSpec({ndim: 3})];\n    this.stateSpec = null;\n    this.states_ = null;\n    // TODO(cais): Add constantsSpec and numConstants.\n    this.numConstants = null;\n    // TODO(cais): Look into the use of initial_state in the kwargs of the\n    //   constructor.\n\n    this.keptStates = [];\n  }\n\n  // Porting Note: This is the equivalent of `RNN.states` property getter in\n  //   PyKeras.\n  getStates(): Tensor[] {\n    if (this.states_ == null) {\n      const numStates =\n          Array.isArray(this.cell.stateSize) ? this.cell.stateSize.length : 1;\n      return math_utils.range(0, numStates).map(x => null);\n    } else {\n      return this.states_;\n    }\n  }\n\n  // Porting Note: This is the equivalent of the `RNN.states` property setter in\n  //   PyKeras.\n  setStates(states: Tensor[]): void {\n    this.states_ = states;\n  }\n\n  computeOutputShape(inputShape: Shape|Shape[]): Shape|Shape[] {\n    if (isArrayOfShapes(inputShape)) {\n      inputShape = (inputShape as Shape[])[0];\n    }\n    inputShape = inputShape as Shape;\n\n    // TODO(cais): Remove the casting once stacked RNN cells become supported.\n    let stateSize = this.cell.stateSize;\n    if (!Array.isArray(stateSize)) {\n      stateSize = [stateSize];\n    }\n    const outputDim = stateSize[0];\n    let outputShape: Shape|Shape[];\n    if (this.returnSequences) {\n      outputShape = [inputShape[0], inputShape[1], outputDim];\n    } else {\n      outputShape = [inputShape[0], outputDim];\n    }\n\n    if (this.returnState) {\n      const stateShape: Shape[] = [];\n      for (const dim of stateSize) {\n        stateShape.push([inputShape[0], dim]);\n      }\n      return [outputShape].concat(stateShape);\n    } else {\n      return outputShape;\n    }\n  }\n\n  computeMask(inputs: Tensor|Tensor[], mask?: Tensor|Tensor[]): Tensor\n      |Tensor[] {\n    return tfc.tidy(() => {\n      if (Array.isArray(mask)) {\n        mask = mask[0];\n      }\n      const outputMask = this.returnSequences ? mask : null;\n\n      if (this.returnState) {\n        const stateMask = this.states.map(s => null);\n        return [outputMask].concat(stateMask);\n      } else {\n        return outputMask;\n      }\n    });\n  }\n\n  /**\n   * Get the current state tensors of the RNN.\n   *\n   * If the state hasn't been set, return an array of `null`s of the correct\n   * length.\n   */\n  get states(): Tensor[] {\n    if (this.states_ == null) {\n      const numStates =\n          Array.isArray(this.cell.stateSize) ? this.cell.stateSize.length : 1;\n      const output: Tensor[] = [];\n      for (let i = 0; i < numStates; ++i) {\n        output.push(null);\n      }\n      return output;\n    } else {\n      return this.states_;\n    }\n  }\n\n  set states(s: Tensor[]) {\n    this.states_ = s;\n  }\n\n  public build(inputShape: Shape|Shape[]): void {\n    // Note inputShape will be an Array of Shapes of initial states and\n    // constants if these are passed in apply().\n    const constantShape: Shape[] = null;\n    if (this.numConstants != null) {\n      throw new NotImplementedError(\n          'Constants support is not implemented in RNN yet.');\n    }\n\n    if (isArrayOfShapes(inputShape)) {\n      inputShape = (inputShape as Shape[])[0];\n    }\n    inputShape = inputShape as Shape;\n\n    const batchSize: number = this.stateful ? inputShape[0] : null;\n    const inputDim = inputShape[inputShape.length - 1];\n    this.inputSpec[0] = new InputSpec({shape: [batchSize, null, inputDim]});\n\n    // Allow cell (if RNNCell Layer) to build before we set or validate\n    // stateSpec.\n    const stepInputShape = [inputShape[0]].concat(inputShape.slice(2));\n    if (constantShape != null) {\n      throw new NotImplementedError(\n          'Constants support is not implemented in RNN yet.');\n    } else {\n      this.cell.build(stepInputShape);\n    }\n\n    // Set or validate stateSpec.\n    let stateSize: number[];\n    if (Array.isArray(this.cell.stateSize)) {\n      stateSize = this.cell.stateSize;\n    } else {\n      stateSize = [this.cell.stateSize];\n    }\n\n    if (this.stateSpec != null) {\n      if (!util.arraysEqual(\n              this.stateSpec.map(spec => spec.shape[spec.shape.length - 1]),\n              stateSize)) {\n        throw new ValueError(\n            `An initialState was passed that is not compatible with ` +\n            `cell.stateSize. Received stateSpec=${this.stateSpec}; ` +\n            `However cell.stateSize is ${this.cell.stateSize}`);\n      }\n    } else {\n      this.stateSpec =\n          stateSize.map(dim => new InputSpec({shape: [null, dim]}));\n    }\n    if (this.stateful) {\n      this.resetStates();\n    }\n  }\n\n  /**\n   * Reset the state tensors of the RNN.\n   *\n   * If the `states` argument is `undefined` or `null`, will set the\n   * state tensor(s) of the RNN to all-zero tensors of the appropriate\n   * shape(s).\n   *\n   * If `states` is provided, will set the state tensors of the RNN to its\n   * value.\n   *\n   * @param states Optional externally-provided initial states.\n   * @param training Whether this call is done during training. For stateful\n   *   RNNs, this affects whether the old states are kept or discarded. In\n   *   particular, if `training` is `true`, the old states will be kept so\n   *   that subsequent backpropgataion through time (BPTT) may work properly.\n   *   Else, the old states will be discarded.\n   */\n  resetStates(states?: Tensor|Tensor[], training = false): void {\n    tidy(() => {\n      if (!this.stateful) {\n        throw new AttributeError(\n            'Cannot call resetStates() on an RNN Layer that is not stateful.');\n      }\n      const batchSize = this.inputSpec[0].shape[0];\n      if (batchSize == null) {\n        throw new ValueError(\n            'If an RNN is stateful, it needs to know its batch size. Specify ' +\n            'the batch size of your input tensors: \\n' +\n            '- If using a Sequential model, specify the batch size by ' +\n            'passing a `batchInputShape` option to your first layer.\\n' +\n            '- If using the functional API, specify the batch size by ' +\n            'passing a `batchShape` option to your Input layer.');\n      }\n      // Initialize state if null.\n      if (this.states_ == null) {\n        if (Array.isArray(this.cell.stateSize)) {\n          this.states_ =\n              this.cell.stateSize.map(dim => tfc.zeros([batchSize, dim]));\n        } else {\n          this.states_ = [tfc.zeros([batchSize, this.cell.stateSize])];\n        }\n      } else if (states == null) {\n        // Dispose old state tensors.\n        tfc.dispose(this.states_);\n        // For stateful RNNs, fully dispose kept old states.\n        if (this.keptStates != null) {\n          tfc.dispose(this.keptStates);\n          this.keptStates = [];\n        }\n\n        if (Array.isArray(this.cell.stateSize)) {\n          this.states_ =\n              this.cell.stateSize.map(dim => tfc.zeros([batchSize, dim]));\n        } else {\n          this.states_[0] = tfc.zeros([batchSize, this.cell.stateSize]);\n        }\n      } else {\n        if (!Array.isArray(states)) {\n          states = [states];\n        }\n        if (states.length !== this.states_.length) {\n          throw new ValueError(\n              `Layer ${this.name} expects ${this.states_.length} state(s), ` +\n              `but it received ${states.length} state value(s). Input ` +\n              `received: ${states}`);\n        }\n\n        if (training === true) {\n          // Store old state tensors for complete disposal later, i.e., during\n          // the next no-arg call to this method. We do not dispose the old\n          // states immediately because that BPTT (among other things) require\n          // them.\n          this.keptStates.push(this.states_.slice());\n        } else {\n          tfc.dispose(this.states_);\n        }\n\n        for (let index = 0; index < this.states_.length; ++index) {\n          const value = states[index];\n          const dim = Array.isArray(this.cell.stateSize) ?\n              this.cell.stateSize[index] :\n              this.cell.stateSize;\n          const expectedShape = [batchSize, dim];\n          if (!util.arraysEqual(value.shape, expectedShape)) {\n            throw new ValueError(\n                `State ${index} is incompatible with layer ${this.name}: ` +\n                `expected shape=${expectedShape}, received shape=${\n                    value.shape}`);\n          }\n          this.states_[index] = value;\n        }\n      }\n      this.states_ = this.states_.map(state => tfc.keep(state.clone()));\n    });\n  }\n\n  apply(\n      inputs: Tensor|Tensor[]|SymbolicTensor|SymbolicTensor[],\n      kwargs?: Kwargs): Tensor|Tensor[]|SymbolicTensor|SymbolicTensor[] {\n    // TODO(cais): Figure out whether initialState is in kwargs or inputs.\n    let initialState: Tensor[]|SymbolicTensor[] =\n        kwargs == null ? null : kwargs['initialState'];\n    let constants: Tensor[]|SymbolicTensor[] =\n        kwargs == null ? null : kwargs['constants'];\n    if (kwargs == null) {\n      kwargs = {};\n    }\n\n    const standardized =\n        standardizeArgs(inputs, initialState, constants, this.numConstants);\n    inputs = standardized.inputs;\n    initialState = standardized.initialState;\n    constants = standardized.constants;\n\n    // If any of `initial_state` or `constants` are specified and are\n    // `tf.SymbolicTensor`s, then add them to the inputs and temporarily modify\n    // the input_spec to include them.\n\n    let additionalInputs: Array<Tensor|SymbolicTensor> = [];\n    let additionalSpecs: InputSpec[] = [];\n    if (initialState != null) {\n      kwargs['initialState'] = initialState;\n      additionalInputs = additionalInputs.concat(initialState);\n      this.stateSpec = [];\n      for (const state of initialState) {\n        this.stateSpec.push(new InputSpec({shape: state.shape}));\n      }\n      // TODO(cais): Use the following instead.\n      // this.stateSpec = initialState.map(state => new InputSpec({shape:\n      // state.shape}));\n      additionalSpecs = additionalSpecs.concat(this.stateSpec);\n    }\n    if (constants != null) {\n      kwargs['constants'] = constants;\n      additionalInputs = additionalInputs.concat(constants);\n      // TODO(cais): Add this.constantsSpec.\n      this.numConstants = constants.length;\n    }\n\n    const isTensor = additionalInputs[0] instanceof SymbolicTensor;\n    if (isTensor) {\n      // Compute full input spec, including state and constants.\n      const fullInput =\n          [inputs].concat(additionalInputs) as Tensor[] | SymbolicTensor[];\n      const fullInputSpec = this.inputSpec.concat(additionalSpecs);\n      // Perform the call with temporarily replaced inputSpec.\n      const originalInputSpec = this.inputSpec;\n      this.inputSpec = fullInputSpec;\n      const output = super.apply(fullInput, kwargs);\n      this.inputSpec = originalInputSpec;\n      return output;\n    } else {\n      return super.apply(inputs, kwargs);\n    }\n  }\n\n  // tslint:disable-next-line:no-any\n  call(inputs: Tensor|Tensor[], kwargs: Kwargs): Tensor|Tensor[] {\n    // Input shape: `[samples, time (padded with zeros), input_dim]`.\n    // Note that the .build() method of subclasses **must** define\n    // this.inputSpec and this.stateSpec owith complete input shapes.\n    return tidy(() => {\n      const mask = kwargs == null ? null : kwargs['mask'] as Tensor;\n      const training = kwargs == null ? null : kwargs['training'];\n      let initialState: Tensor[] =\n          kwargs == null ? null : kwargs['initialState'];\n\n      inputs = getExactlyOneTensor(inputs);\n      if (initialState == null) {\n        if (this.stateful) {\n          initialState = this.states_;\n        } else {\n          initialState = this.getInitialState(inputs);\n        }\n      }\n\n      const numStates =\n          Array.isArray(this.cell.stateSize) ? this.cell.stateSize.length : 1;\n      if (initialState.length !== numStates) {\n        throw new ValueError(\n            `RNN Layer has ${numStates} state(s) but was passed ` +\n            `${initialState.length} initial state(s).`);\n      }\n      if (this.unroll) {\n        console.warn(\n            'Ignoring unroll = true for RNN layer, due to imperative backend.');\n      }\n\n      const cellCallKwargs: Kwargs = {training};\n\n      // TODO(cais): Add support for constants.\n      const step = (inputs: Tensor, states: Tensor[]) => {\n        // `inputs` and `states` are concatenated to form a single `Array` of\n        // `tf.Tensor`s as the input to `cell.call()`.\n        const outputs =\n            this.cell.call([inputs].concat(states), cellCallKwargs) as Tensor[];\n        // Marshall the return value into output and new states.\n        return [outputs[0], outputs.slice(1)] as [Tensor, Tensor[]];\n      };\n\n      // TODO(cais): Add support for constants.\n\n      const rnnOutputs =\n          rnn(step, inputs, initialState, this.goBackwards, mask, null,\n              this.unroll, this.returnSequences);\n      const lastOutput = rnnOutputs[0];\n      const outputs = rnnOutputs[1];\n      const states = rnnOutputs[2];\n\n      if (this.stateful) {\n        this.resetStates(states, training);\n      }\n\n      const output = this.returnSequences ? outputs : lastOutput;\n\n      // TODO(cais): Porperty set learning phase flag.\n\n      if (this.returnState) {\n        return [output].concat(states);\n      } else {\n        return output;\n      }\n    });\n  }\n\n  getInitialState(inputs: Tensor): Tensor[] {\n    return tidy(() => {\n      // Build an all-zero tensor of shape [samples, outputDim].\n      // [Samples, timeSteps, inputDim].\n      let initialState = tfc.zeros(inputs.shape);\n      // [Samples].\n      initialState = tfc.sum(initialState, [1, 2]);\n      initialState = K.expandDims(initialState);  // [Samples, 1].\n\n      if (Array.isArray(this.cell.stateSize)) {\n        return this.cell.stateSize.map(\n            dim => dim > 1 ? K.tile(initialState, [1, dim]) : initialState);\n      } else {\n        return this.cell.stateSize > 1 ?\n            [K.tile(initialState, [1, this.cell.stateSize])] :\n            [initialState];\n      }\n    });\n  }\n\n  get trainableWeights(): LayerVariable[] {\n    if (!this.trainable) {\n      return [];\n    }\n    // Porting Note: In TypeScript, `this` is always an instance of `Layer`.\n    return this.cell.trainableWeights;\n  }\n\n  get nonTrainableWeights(): LayerVariable[] {\n    // Porting Note: In TypeScript, `this` is always an instance of `Layer`.\n    if (!this.trainable) {\n      return this.cell.weights;\n    }\n    return this.cell.nonTrainableWeights;\n  }\n\n  setFastWeightInitDuringBuild(value: boolean) {\n    super.setFastWeightInitDuringBuild(value);\n    if (this.cell != null) {\n      this.cell.setFastWeightInitDuringBuild(value);\n    }\n  }\n\n  getConfig(): serialization.ConfigDict {\n    const config: serialization.ConfigDict = {\n      returnSequences: this.returnSequences,\n      returnState: this.returnState,\n      goBackwards: this.goBackwards,\n      stateful: this.stateful,\n      unroll: this.unroll,\n    };\n    if (this.numConstants != null) {\n      config['numConstants'] = this.numConstants;\n    }\n    const cellConfig = this.cell.getConfig();\n    config['cell'] = {\n      'className': this.cell.getClassName(),\n      'config': cellConfig,\n    } as serialization.ConfigDictValue;\n    const baseConfig = super.getConfig();\n    Object.assign(config, baseConfig);\n    return config;\n  }\n\n  /** @nocollapse */\n  static fromConfig<T extends serialization.Serializable>(\n      cls: serialization.SerializableConstructor<T>,\n      config: serialization.ConfigDict,\n      customObjects = {} as serialization.ConfigDict): T {\n    const cellConfig = config['cell'] as serialization.ConfigDict;\n    const cell = deserialize(cellConfig, customObjects) as RNNCell;\n    return new cls(Object.assign(config, {cell}));\n  }\n}\nserialization.registerClass(RNN);\n\n/**\n * An RNNCell layer.\n */\n// Porting Note: This is a common parent class for RNN cells. There is no\n// equivalent of this in PyKeras. Having a common parent class forgoes the\n//  need for `has_attr(cell, ...)` checks or its TypeScript equivalent.\n/** @doc {heading: 'Layers', subheading: 'Classes'} */\nexport abstract class RNNCell extends Layer {\n  /**\n   * Size(s) of the states.\n   * For RNN cells with only a single state, this is a single integer.\n   */\n  public stateSize: number|number[];\n  public dropoutMask: Tensor|Tensor[];\n  public recurrentDropoutMask: Tensor|Tensor[];\n}\n\nexport declare interface SimpleRNNCellLayerArgs extends LayerArgs {\n  /**\n   * units: Positive integer, dimensionality of the output space.\n   */\n  units: number;\n\n  /**\n   * Activation function to use.\n   * Default: hyperbolic tangent ('tanh').\n   * If you pass `null`,  'linear' activation will be applied.\n   */\n  activation?: ActivationIdentifier;\n\n  /**\n   * Whether the layer uses a bias vector.\n   */\n  useBias?: boolean;\n\n  /**\n   * Initializer for the `kernel` weights matrix, used for the linear\n   * transformation of the inputs.\n   */\n  kernelInitializer?: InitializerIdentifier|Initializer;\n\n  /**\n   * Initializer for the `recurrentKernel` weights matrix, used for\n   * linear transformation of the recurrent state.\n   */\n  recurrentInitializer?: InitializerIdentifier|Initializer;\n\n  /**\n   * Initializer for the bias vector.\n   */\n  biasInitializer?: InitializerIdentifier|Initializer;\n\n  /**\n   * Regularizer function applied to the `kernel` weights matrix.\n   */\n  kernelRegularizer?: RegularizerIdentifier|Regularizer;\n\n  /**\n   * Regularizer function applied to the `recurrent_kernel` weights matrix.\n   */\n  recurrentRegularizer?: RegularizerIdentifier|Regularizer;\n\n  /**\n   * Regularizer function applied to the bias vector.\n   */\n  biasRegularizer?: RegularizerIdentifier|Regularizer;\n\n  /**\n   * Constraint function applied to the `kernel` weights matrix.\n   */\n  kernelConstraint?: ConstraintIdentifier|Constraint;\n\n  /**\n   * Constraint function applied to the `recurrentKernel` weights matrix.\n   */\n  recurrentConstraint?: ConstraintIdentifier|Constraint;\n\n  /**\n   * Constraintfunction applied to the bias vector.\n   */\n  biasConstraint?: ConstraintIdentifier|Constraint;\n\n  /**\n   * Float number between 0 and 1. Fraction of the units to drop for the linear\n   * transformation of the inputs.\n   */\n  dropout?: number;\n\n  /**\n   * Float number between 0 and 1. Fraction of the units to drop for the linear\n   * transformation of the recurrent state.\n   */\n  recurrentDropout?: number;\n}\n\nexport class SimpleRNNCell extends RNNCell {\n  /** @nocollapse */\n  static className = 'SimpleRNNCell';\n  readonly units: number;\n  readonly activation: Activation;\n  readonly useBias: boolean;\n\n  readonly kernelInitializer: Initializer;\n  readonly recurrentInitializer: Initializer;\n  readonly biasInitializer: Initializer;\n\n  readonly kernelConstraint: Constraint;\n  readonly recurrentConstraint: Constraint;\n  readonly biasConstraint: Constraint;\n\n  readonly kernelRegularizer: Regularizer;\n  readonly recurrentRegularizer: Regularizer;\n  readonly biasRegularizer: Regularizer;\n\n  readonly dropout: number;\n  readonly recurrentDropout: number;\n\n  readonly stateSize: number;\n\n  kernel: LayerVariable;\n  recurrentKernel: LayerVariable;\n  bias: LayerVariable;\n\n  readonly DEFAULT_ACTIVATION = 'tanh';\n  readonly DEFAULT_KERNEL_INITIALIZER = 'glorotNormal';\n  readonly DEFAULT_RECURRENT_INITIALIZER = 'orthogonal';\n  readonly DEFAULT_BIAS_INITIALIZER: InitializerIdentifier = 'zeros';\n\n  constructor(args: SimpleRNNCellLayerArgs) {\n    super(args);\n    this.units = args.units;\n    assertPositiveInteger(this.units, `units`);\n    this.activation = getActivation(\n        args.activation == null ? this.DEFAULT_ACTIVATION : args.activation);\n    this.useBias = args.useBias == null ? true : args.useBias;\n\n    this.kernelInitializer = getInitializer(\n        args.kernelInitializer || this.DEFAULT_KERNEL_INITIALIZER);\n    this.recurrentInitializer = getInitializer(\n        args.recurrentInitializer || this.DEFAULT_RECURRENT_INITIALIZER);\n\n    this.biasInitializer =\n        getInitializer(args.biasInitializer || this.DEFAULT_BIAS_INITIALIZER);\n\n    this.kernelRegularizer = getRegularizer(args.kernelRegularizer);\n    this.recurrentRegularizer = getRegularizer(args.recurrentRegularizer);\n    this.biasRegularizer = getRegularizer(args.biasRegularizer);\n\n    this.kernelConstraint = getConstraint(args.kernelConstraint);\n    this.recurrentConstraint = getConstraint(args.recurrentConstraint);\n    this.biasConstraint = getConstraint(args.biasConstraint);\n\n    this.dropout = math_utils.min(\n        [1, math_utils.max([0, args.dropout == null ? 0 : args.dropout])]);\n    this.recurrentDropout = math_utils.min([\n      1,\n      math_utils.max(\n          [0, args.recurrentDropout == null ? 0 : args.recurrentDropout])\n    ]);\n    this.stateSize = this.units;\n    this.dropoutMask = null;\n    this.recurrentDropoutMask = null;\n  }\n\n  build(inputShape: Shape|Shape[]): void {\n    inputShape = getExactlyOneShape(inputShape);\n    // TODO(cais): Use regularizer.\n    this.kernel = this.addWeight(\n        'kernel', [inputShape[inputShape.length - 1], this.units], null,\n        this.kernelInitializer, this.kernelRegularizer, true,\n        this.kernelConstraint);\n    this.recurrentKernel = this.addWeight(\n        'recurrent_kernel', [this.units, this.units], null,\n        this.recurrentInitializer, this.recurrentRegularizer, true,\n        this.recurrentConstraint);\n    if (this.useBias) {\n      this.bias = this.addWeight(\n          'bias', [this.units], null, this.biasInitializer,\n          this.biasRegularizer, true, this.biasConstraint);\n    } else {\n      this.bias = null;\n    }\n    this.built = true;\n  }\n\n  // Porting Note: PyKeras' equivalent of this method takes two tensor inputs:\n  //   `inputs` and `states`. Here, the two tensors are combined into an\n  //   `Tensor[]` Array as the first input argument.\n  //   Similarly, PyKeras' equivalent of this method returns two values:\n  //    `output` and `[output]`. Here the two are combined into one length-2\n  //    `Tensor[]`, consisting of `output` repeated.\n  call(inputs: Tensor|Tensor[], kwargs: Kwargs): Tensor|Tensor[] {\n    return tidy(() => {\n      inputs = inputs as Tensor[];\n      if (inputs.length !== 2) {\n        throw new ValueError(\n            `SimpleRNNCell expects 2 input Tensors, got ${inputs.length}.`);\n      }\n      let prevOutput = inputs[1];\n      inputs = inputs[0];\n      const training = kwargs['training'] == null ? false : kwargs['training'];\n\n      if (0 < this.dropout && this.dropout < 1 && this.dropoutMask == null) {\n        this.dropoutMask = generateDropoutMask(\n                               () => tfc.onesLike(inputs as Tensor),\n                               this.dropout, training) as Tensor;\n      }\n      if (0 < this.recurrentDropout && this.recurrentDropout < 1 &&\n          this.recurrentDropoutMask == null) {\n        this.recurrentDropoutMask =\n            generateDropoutMask(\n                () => tfc.onesLike(prevOutput), this.recurrentDropout,\n                training) as Tensor;\n      }\n      let h: Tensor;\n      const dpMask: Tensor = this.dropoutMask as Tensor;\n      const recDpMask: Tensor = this.recurrentDropoutMask as Tensor;\n      if (dpMask != null) {\n        h = K.dot(tfc.mul(inputs, dpMask), this.kernel.read());\n      } else {\n        h = K.dot(inputs, this.kernel.read());\n      }\n      if (this.bias != null) {\n        h = K.biasAdd(h, this.bias.read());\n      }\n      if (recDpMask != null) {\n        prevOutput = tfc.mul(prevOutput, recDpMask);\n      }\n      let output = tfc.add(h, K.dot(prevOutput, this.recurrentKernel.read()));\n      if (this.activation != null) {\n        output = this.activation.apply(output);\n      }\n\n      // TODO(cais): Properly set learning phase on output tensor?\n      return [output, output];\n    });\n  }\n\n  getConfig(): serialization.ConfigDict {\n    const config: serialization.ConfigDict = {\n      units: this.units,\n      activation: serializeActivation(this.activation),\n      useBias: this.useBias,\n      kernelInitializer: serializeInitializer(this.kernelInitializer),\n      recurrentInitializer: serializeInitializer(this.recurrentInitializer),\n      biasInitializer: serializeInitializer(this.biasInitializer),\n      kernelRegularizer: serializeRegularizer(this.kernelRegularizer),\n      recurrentRegularizer: serializeRegularizer(this.recurrentRegularizer),\n      biasRegularizer: serializeRegularizer(this.biasRegularizer),\n      activityRegularizer: serializeRegularizer(this.activityRegularizer),\n      kernelConstraint: serializeConstraint(this.kernelConstraint),\n      recurrentConstraint: serializeConstraint(this.recurrentConstraint),\n      biasConstraint: serializeConstraint(this.biasConstraint),\n      dropout: this.dropout,\n      recurrentDropout: this.recurrentDropout,\n    };\n    const baseConfig = super.getConfig();\n    Object.assign(config, baseConfig);\n    return config;\n  }\n}\nserialization.registerClass(SimpleRNNCell);\n\nexport declare interface SimpleRNNLayerArgs extends BaseRNNLayerArgs {\n  /**\n   * Positive integer, dimensionality of the output space.\n   */\n  units: number;\n\n  /**\n   * Activation function to use.\n   *\n   * Defaults to  hyperbolic tangent (`tanh`)\n   *\n   * If you pass `null`, no activation will be applied.\n   */\n  activation?: ActivationIdentifier;\n\n  /**\n   * Whether the layer uses a bias vector.\n   */\n  useBias?: boolean;\n\n  /**\n   * Initializer for the `kernel` weights matrix, used for the linear\n   * transformation of the inputs.\n   */\n  kernelInitializer?: InitializerIdentifier|Initializer;\n\n  /**\n   * Initializer for the `recurrentKernel` weights matrix, used for\n   * linear transformation of the recurrent state.\n   */\n  recurrentInitializer?: InitializerIdentifier|Initializer;\n\n  /**\n   * Initializer for the bias vector.\n   */\n  biasInitializer?: InitializerIdentifier|Initializer;\n\n  /**\n   * Regularizer function applied to the kernel weights matrix.\n   */\n  kernelRegularizer?: RegularizerIdentifier|Regularizer;\n\n  /**\n   * Regularizer function applied to the recurrentKernel weights matrix.\n   */\n  recurrentRegularizer?: RegularizerIdentifier|Regularizer;\n\n  /**\n   * Regularizer function applied to the bias vector.\n   */\n  biasRegularizer?: RegularizerIdentifier|Regularizer;\n\n  /**\n   * Constraint function applied to the kernel weights matrix.\n   */\n  kernelConstraint?: ConstraintIdentifier|Constraint;\n\n  /**\n   * Constraint function applied to the recurrentKernel weights matrix.\n   */\n  recurrentConstraint?: ConstraintIdentifier|Constraint;\n\n  /**\n   * Constraint function applied to the bias vector.\n   */\n  biasConstraint?: ConstraintIdentifier|Constraint;\n\n  /**\n   * Number between 0 and 1. Fraction of the units to drop for the linear\n   * transformation of the inputs.\n   */\n  dropout?: number;\n\n  /**\n   * Number between 0 and 1. Fraction of the units to drop for the linear\n   * transformation of the recurrent state.\n   */\n  recurrentDropout?: number;\n}\n\n/**\n * RNNLayerConfig is identical to BaseRNNLayerConfig, except it makes the\n * `cell` property required. This interface is to be used with constructors\n * of concrete RNN layer subtypes.\n */\nexport declare interface RNNLayerArgs extends BaseRNNLayerArgs {\n  cell: RNNCell|RNNCell[];\n}\n\nexport class SimpleRNN extends RNN {\n  /** @nocollapse */\n  static className = 'SimpleRNN';\n  constructor(args: SimpleRNNLayerArgs) {\n    args.cell = new SimpleRNNCell(args);\n    super(args as RNNLayerArgs);\n    // TODO(cais): Add activityRegularizer.\n  }\n\n  call(inputs: Tensor|Tensor[], kwargs: Kwargs): Tensor|Tensor[] {\n    return tidy(() => {\n      if (this.cell.dropoutMask != null) {\n        tfc.dispose(this.cell.dropoutMask);\n        this.cell.dropoutMask = null;\n      }\n      if (this.cell.recurrentDropoutMask != null) {\n        tfc.dispose(this.cell.recurrentDropoutMask);\n        this.cell.recurrentDropoutMask = null;\n      }\n      const mask = kwargs == null ? null : kwargs['mask'];\n      const training = kwargs == null ? null : kwargs['training'];\n      const initialState: Tensor[] =\n          kwargs == null ? null : kwargs['initialState'];\n      return super.call(inputs, {mask, training, initialState});\n    });\n  }\n\n  // TODO(cais): Research possibility of refactoring out the tedious all\n  //   the getters that delegate to `this.cell` below.\n  get units(): number {\n    return (this.cell as SimpleRNNCell).units;\n  }\n\n  get activation(): Activation {\n    return (this.cell as SimpleRNNCell).activation;\n  }\n\n  get useBias(): boolean {\n    return (this.cell as SimpleRNNCell).useBias;\n  }\n\n  get kernelInitializer(): Initializer {\n    return (this.cell as SimpleRNNCell).kernelInitializer;\n  }\n\n  get recurrentInitializer(): Initializer {\n    return (this.cell as SimpleRNNCell).recurrentInitializer;\n  }\n\n  get biasInitializer(): Initializer {\n    return (this.cell as SimpleRNNCell).biasInitializer;\n  }\n\n  get kernelRegularizer(): Regularizer {\n    return (this.cell as SimpleRNNCell).kernelRegularizer;\n  }\n\n  get recurrentRegularizer(): Regularizer {\n    return (this.cell as SimpleRNNCell).recurrentRegularizer;\n  }\n\n  get biasRegularizer(): Regularizer {\n    return (this.cell as SimpleRNNCell).biasRegularizer;\n  }\n\n  get kernelConstraint(): Constraint {\n    return (this.cell as SimpleRNNCell).kernelConstraint;\n  }\n\n  get recurrentConstraint(): Constraint {\n    return (this.cell as SimpleRNNCell).recurrentConstraint;\n  }\n\n  get biasConstraint(): Constraint {\n    return (this.cell as SimpleRNNCell).biasConstraint;\n  }\n\n  get dropout(): number {\n    return (this.cell as SimpleRNNCell).dropout;\n  }\n\n  get recurrentDropout(): number {\n    return (this.cell as SimpleRNNCell).recurrentDropout;\n  }\n\n  getConfig(): serialization.ConfigDict {\n    const config: serialization.ConfigDict = {\n      units: this.units,\n      activation: serializeActivation(this.activation),\n      useBias: this.useBias,\n      kernelInitializer: serializeInitializer(this.kernelInitializer),\n      recurrentInitializer: serializeInitializer(this.recurrentInitializer),\n      biasInitializer: serializeInitializer(this.biasInitializer),\n      kernelRegularizer: serializeRegularizer(this.kernelRegularizer),\n      recurrentRegularizer: serializeRegularizer(this.recurrentRegularizer),\n      biasRegularizer: serializeRegularizer(this.biasRegularizer),\n      activityRegularizer: serializeRegularizer(this.activityRegularizer),\n      kernelConstraint: serializeConstraint(this.kernelConstraint),\n      recurrentConstraint: serializeConstraint(this.recurrentConstraint),\n      biasConstraint: serializeConstraint(this.biasConstraint),\n      dropout: this.dropout,\n      recurrentDropout: this.recurrentDropout,\n    };\n    const baseConfig = super.getConfig();\n    delete baseConfig['cell'];\n    Object.assign(config, baseConfig);\n    return config;\n  }\n\n  /** @nocollapse */\n  static fromConfig<T extends serialization.Serializable>(\n      cls: serialization.SerializableConstructor<T>,\n      config: serialization.ConfigDict): T {\n    return new cls(config);\n  }\n}\nserialization.registerClass(SimpleRNN);\n\n// Porting Note: Since this is a superset of SimpleRNNLayerConfig, we extend\n//   that interface instead of repeating the fields.\nexport declare interface GRUCellLayerArgs extends SimpleRNNCellLayerArgs {\n  /**\n   * Activation function to use for the recurrent step.\n   *\n   * Defaults to hard sigmoid (`hardSigmoid`).\n   *\n   * If `null`, no activation is applied.\n   */\n  recurrentActivation?: ActivationIdentifier;\n\n  /**\n   * Implementation mode, either 1 or 2.\n   *\n   * Mode 1 will structure its operations as a larger number of\n   *   smaller dot products and additions.\n   *\n   * Mode 2 will batch them into fewer, larger operations. These modes will\n   * have different performance profiles on different hardware and\n   * for different applications.\n   *\n   * Note: For superior performance, TensorFlow.js always uses implementation\n   * 2, regardless of the actual value of this configuration field.\n   */\n  implementation?: number;\n}\n\nexport class GRUCell extends RNNCell {\n  /** @nocollapse */\n  static className = 'GRUCell';\n  readonly units: number;\n  readonly activation: Activation;\n  readonly recurrentActivation: Activation;\n  readonly useBias: boolean;\n\n  readonly kernelInitializer: Initializer;\n  readonly recurrentInitializer: Initializer;\n  readonly biasInitializer: Initializer;\n\n  readonly kernelRegularizer: Regularizer;\n  readonly recurrentRegularizer: Regularizer;\n  readonly biasRegularizer: Regularizer;\n\n  readonly kernelConstraint: Constraint;\n  readonly recurrentConstraint: Constraint;\n  readonly biasConstraint: Constraint;\n\n  readonly dropout: number;\n  readonly recurrentDropout: number;\n\n  readonly stateSize: number;\n  readonly implementation: number;\n\n  readonly DEFAULT_ACTIVATION = 'tanh';\n  readonly DEFAULT_RECURRENT_ACTIVATION: ActivationIdentifier = 'hardSigmoid';\n\n  readonly DEFAULT_KERNEL_INITIALIZER = 'glorotNormal';\n  readonly DEFAULT_RECURRENT_INITIALIZER = 'orthogonal';\n  readonly DEFAULT_BIAS_INITIALIZER: InitializerIdentifier = 'zeros';\n\n  kernel: LayerVariable;\n  recurrentKernel: LayerVariable;\n  bias: LayerVariable;\n\n  constructor(args: GRUCellLayerArgs) {\n    super(args);\n\n    this.units = args.units;\n    assertPositiveInteger(this.units, 'units');\n    this.activation = getActivation(\n        args.activation === undefined ? this.DEFAULT_ACTIVATION :\n                                        args.activation);\n    this.recurrentActivation = getActivation(\n        args.recurrentActivation === undefined ?\n            this.DEFAULT_RECURRENT_ACTIVATION :\n            args.recurrentActivation);\n    this.useBias = args.useBias == null ? true : args.useBias;\n\n    this.kernelInitializer = getInitializer(\n        args.kernelInitializer || this.DEFAULT_KERNEL_INITIALIZER);\n    this.recurrentInitializer = getInitializer(\n        args.recurrentInitializer || this.DEFAULT_RECURRENT_INITIALIZER);\n\n    this.biasInitializer =\n        getInitializer(args.biasInitializer || this.DEFAULT_BIAS_INITIALIZER);\n\n    this.kernelRegularizer = getRegularizer(args.kernelRegularizer);\n    this.recurrentRegularizer = getRegularizer(args.recurrentRegularizer);\n    this.biasRegularizer = getRegularizer(args.biasRegularizer);\n\n    this.kernelConstraint = getConstraint(args.kernelConstraint);\n    this.recurrentConstraint = getConstraint(args.recurrentConstraint);\n    this.biasConstraint = getConstraint(args.biasConstraint);\n\n    this.dropout = math_utils.min(\n        [1, math_utils.max([0, args.dropout == null ? 0 : args.dropout])]);\n    this.recurrentDropout = math_utils.min([\n      1,\n      math_utils.max(\n          [0, args.recurrentDropout == null ? 0 : args.recurrentDropout])\n    ]);\n    this.implementation = args.implementation;\n    this.stateSize = this.units;\n    this.dropoutMask = null;\n    this.recurrentDropoutMask = null;\n  }\n\n  public build(inputShape: Shape|Shape[]): void {\n    inputShape = getExactlyOneShape(inputShape);\n    const inputDim = inputShape[inputShape.length - 1];\n    this.kernel = this.addWeight(\n        'kernel', [inputDim, this.units * 3], null, this.kernelInitializer,\n        this.kernelRegularizer, true, this.kernelConstraint);\n    this.recurrentKernel = this.addWeight(\n        'recurrent_kernel', [this.units, this.units * 3], null,\n        this.recurrentInitializer, this.recurrentRegularizer, true,\n        this.recurrentConstraint);\n    if (this.useBias) {\n      this.bias = this.addWeight(\n          'bias', [this.units * 3], null, this.biasInitializer,\n          this.biasRegularizer, true, this.biasConstraint);\n    } else {\n      this.bias = null;\n    }\n    // Porting Notes: Unlike the PyKeras implementation, we perform slicing\n    //   of the weights and bias in the call() method, at execution time.\n    this.built = true;\n  }\n\n  call(inputs: Tensor|Tensor[], kwargs: Kwargs): Tensor|Tensor[] {\n    return tidy(() => {\n      inputs = inputs as Tensor[];\n      if (inputs.length !== 2) {\n        throw new ValueError(\n            `GRUCell expects 2 input Tensors (inputs, h, c), got ` +\n            `${inputs.length}.`);\n      }\n\n      const training = kwargs['training'] == null ? false : kwargs['training'];\n      let hTMinus1 = inputs[1];  // Previous memory state.\n      inputs = inputs[0];\n\n      // Note: For superior performance, TensorFlow.js always uses\n      // implementation 2, regardless of the actual value of\n      // config.implementation.\n      if (0 < this.dropout && this.dropout < 1 && this.dropoutMask == null) {\n        this.dropoutMask = generateDropoutMask(\n                               () => tfc.onesLike(inputs as Tensor),\n                               this.dropout, training, 3) as Tensor[];\n      }\n      if (0 < this.recurrentDropout && this.recurrentDropout < 1 &&\n          this.recurrentDropoutMask == null) {\n        this.recurrentDropoutMask =\n            generateDropoutMask(\n                () => tfc.onesLike(hTMinus1), this.recurrentDropout, training,\n                3) as Tensor[];\n      }\n      const dpMask = this.dropoutMask as [Tensor, Tensor, Tensor];\n      const recDpMask = this.recurrentDropoutMask as [Tensor, Tensor, Tensor];\n      let z: Tensor;\n      let r: Tensor;\n      let hh: Tensor;\n\n      if (0 < this.dropout && this.dropout < 1) {\n        inputs = tfc.mul(inputs, dpMask[0]);\n      }\n      let matrixX = K.dot(inputs, this.kernel.read());\n      if (this.useBias) {\n        matrixX = K.biasAdd(matrixX, this.bias.read());\n      }\n      if (0 < this.recurrentDropout && this.recurrentDropout < 1) {\n        hTMinus1 = tfc.mul(hTMinus1, recDpMask[0]);\n      }\n\n      const recurrentKernelValue = this.recurrentKernel.read();\n      const [rk1, rk2] = tfc.split(\n          recurrentKernelValue, [2 * this.units, this.units],\n          recurrentKernelValue.rank - 1);\n      const matrixInner = K.dot(hTMinus1, rk1);\n\n      const [xZ, xR, xH] = tfc.split(matrixX, 3, matrixX.rank - 1);\n      const [recurrentZ, recurrentR] =\n          tfc.split(matrixInner, 2, matrixInner.rank - 1);\n      z = this.recurrentActivation.apply(tfc.add(xZ, recurrentZ));\n      r = this.recurrentActivation.apply(tfc.add(xR, recurrentR));\n\n      const recurrentH = K.dot(tfc.mul(r, hTMinus1), rk2);\n      hh = this.activation.apply(tfc.add(xH, recurrentH));\n\n      const h =\n          tfc.add(tfc.mul(z, hTMinus1), tfc.mul(tfc.add(1, tfc.neg(z)), hh));\n      // TODO(cais): Add use_learning_phase flag properly.\n      return [h, h];\n    });\n  }\n\n  getConfig(): serialization.ConfigDict {\n    const config: serialization.ConfigDict = {\n      units: this.units,\n      activation: serializeActivation(this.activation),\n      recurrentActivation: serializeActivation(this.recurrentActivation),\n      useBias: this.useBias,\n      kernelInitializer: serializeInitializer(this.kernelInitializer),\n      recurrentInitializer: serializeInitializer(this.recurrentInitializer),\n      biasInitializer: serializeInitializer(this.biasInitializer),\n      kernelRegularizer: serializeRegularizer(this.kernelRegularizer),\n      recurrentRegularizer: serializeRegularizer(this.recurrentRegularizer),\n      biasRegularizer: serializeRegularizer(this.biasRegularizer),\n      activityRegularizer: serializeRegularizer(this.activityRegularizer),\n      kernelConstraint: serializeConstraint(this.kernelConstraint),\n      recurrentConstraint: serializeConstraint(this.recurrentConstraint),\n      biasConstraint: serializeConstraint(this.biasConstraint),\n      dropout: this.dropout,\n      recurrentDropout: this.recurrentDropout,\n      implementation: this.implementation,\n    };\n    const baseConfig = super.getConfig();\n    Object.assign(config, baseConfig);\n    return config;\n  }\n}\nserialization.registerClass(GRUCell);\n\n// Porting Note: Since this is a superset of SimpleRNNLayerConfig, we inherit\n//   from that interface instead of repeating the fields here.\nexport declare interface GRULayerArgs extends SimpleRNNLayerArgs {\n  /**\n   * Activation function to use for the recurrent step.\n   *\n   * Defaults to hard sigmoid (`hardSigmoid`).\n   *\n   * If `null`, no activation is applied.\n   */\n  recurrentActivation?: ActivationIdentifier;\n\n  /**\n   * Implementation mode, either 1 or 2.\n   *\n   * Mode 1 will structure its operations as a larger number of\n   * smaller dot products and additions.\n   *\n   * Mode 2 will batch them into fewer, larger operations. These modes will\n   * have different performance profiles on different hardware and\n   * for different applications.\n   *\n   * Note: For superior performance, TensorFlow.js always uses implementation\n   * 2, regardless of the actual value of this configuration field.\n   */\n  implementation?: number;\n}\n\nexport class GRU extends RNN {\n  /** @nocollapse */\n  static className = 'GRU';\n  constructor(args: GRULayerArgs) {\n    if (args.implementation === 0) {\n      console.warn(\n          '`implementation=0` has been deprecated, and now defaults to ' +\n          '`implementation=1`. Please update your layer call.');\n    }\n    args.cell = new GRUCell(args);\n    super(args as RNNLayerArgs);\n    // TODO(cais): Add activityRegularizer.\n  }\n\n  call(inputs: Tensor|Tensor[], kwargs: Kwargs): Tensor|Tensor[] {\n    return tidy(() => {\n      if (this.cell.dropoutMask != null) {\n        tfc.dispose(this.cell.dropoutMask);\n        this.cell.dropoutMask = null;\n      }\n      if (this.cell.recurrentDropoutMask != null) {\n        tfc.dispose(this.cell.recurrentDropoutMask);\n        this.cell.recurrentDropoutMask = null;\n      }\n      const mask = kwargs == null ? null : kwargs['mask'];\n      const training = kwargs == null ? null : kwargs['training'];\n      const initialState: Tensor[] =\n          kwargs == null ? null : kwargs['initialState'];\n      return super.call(inputs, {mask, training, initialState});\n    });\n  }\n\n  get units(): number {\n    return (this.cell as GRUCell).units;\n  }\n\n  get activation(): Activation {\n    return (this.cell as GRUCell).activation;\n  }\n\n  get recurrentActivation(): Activation {\n    return (this.cell as GRUCell).recurrentActivation;\n  }\n\n  get useBias(): boolean {\n    return (this.cell as GRUCell).useBias;\n  }\n\n  get kernelInitializer(): Initializer {\n    return (this.cell as GRUCell).kernelInitializer;\n  }\n\n  get recurrentInitializer(): Initializer {\n    return (this.cell as GRUCell).recurrentInitializer;\n  }\n\n  get biasInitializer(): Initializer {\n    return (this.cell as GRUCell).biasInitializer;\n  }\n\n  get kernelRegularizer(): Regularizer {\n    return (this.cell as GRUCell).kernelRegularizer;\n  }\n\n  get recurrentRegularizer(): Regularizer {\n    return (this.cell as GRUCell).recurrentRegularizer;\n  }\n\n  get biasRegularizer(): Regularizer {\n    return (this.cell as GRUCell).biasRegularizer;\n  }\n\n  get kernelConstraint(): Constraint {\n    return (this.cell as GRUCell).kernelConstraint;\n  }\n\n  get recurrentConstraint(): Constraint {\n    return (this.cell as GRUCell).recurrentConstraint;\n  }\n\n  get biasConstraint(): Constraint {\n    return (this.cell as GRUCell).biasConstraint;\n  }\n\n  get dropout(): number {\n    return (this.cell as GRUCell).dropout;\n  }\n\n  get recurrentDropout(): number {\n    return (this.cell as GRUCell).recurrentDropout;\n  }\n\n  get implementation(): number {\n    return (this.cell as GRUCell).implementation;\n  }\n\n  getConfig(): serialization.ConfigDict {\n    const config: serialization.ConfigDict = {\n      units: this.units,\n      activation: serializeActivation(this.activation),\n      recurrentActivation: serializeActivation(this.recurrentActivation),\n      useBias: this.useBias,\n      kernelInitializer: serializeInitializer(this.kernelInitializer),\n      recurrentInitializer: serializeInitializer(this.recurrentInitializer),\n      biasInitializer: serializeInitializer(this.biasInitializer),\n      kernelRegularizer: serializeRegularizer(this.kernelRegularizer),\n      recurrentRegularizer: serializeRegularizer(this.recurrentRegularizer),\n      biasRegularizer: serializeRegularizer(this.biasRegularizer),\n      activityRegularizer: serializeRegularizer(this.activityRegularizer),\n      kernelConstraint: serializeConstraint(this.kernelConstraint),\n      recurrentConstraint: serializeConstraint(this.recurrentConstraint),\n      biasConstraint: serializeConstraint(this.biasConstraint),\n      dropout: this.dropout,\n      recurrentDropout: this.recurrentDropout,\n      implementation: this.implementation,\n    };\n    const baseConfig = super.getConfig();\n    delete baseConfig['cell'];\n    Object.assign(config, baseConfig);\n    return config;\n  }\n\n  /** @nocollapse */\n  static fromConfig<T extends serialization.Serializable>(\n      cls: serialization.SerializableConstructor<T>,\n      config: serialization.ConfigDict): T {\n    if (config['implmentation'] === 0) {\n      config['implementation'] = 1;\n    }\n    return new cls(config);\n  }\n}\nserialization.registerClass(GRU);\n\n// Porting Note: Since this is a superset of SimpleRNNLayerConfig, we extend\n//   that interface instead of repeating the fields.\nexport declare interface LSTMCellLayerArgs extends SimpleRNNCellLayerArgs {\n  /**\n   * Activation function to use for the recurrent step.\n   *\n   * Defaults to hard sigmoid (`hardSigmoid`).\n   *\n   * If `null`, no activation is applied.\n   */\n  recurrentActivation?: ActivationIdentifier;\n\n  /**\n   * If `true`, add 1 to the bias of the forget gate at initialization.\n   * Setting it to `true` will also force `biasInitializer = 'zeros'`.\n   * This is recommended in\n   * [Jozefowicz et\n   * al.](http://www.jmlr.org/proceedings/papers/v37/jozefowicz15.pdf).\n   */\n  unitForgetBias?: boolean;\n\n  /**\n   * Implementation mode, either 1 or 2.\n   *\n   * Mode 1 will structure its operations as a larger number of\n   *   smaller dot products and additions.\n   *\n   * Mode 2 will batch them into fewer, larger operations. These modes will\n   * have different performance profiles on different hardware and\n   * for different applications.\n   *\n   * Note: For superior performance, TensorFlow.js always uses implementation\n   * 2, regardless of the actual value of this configuration field.\n   */\n  implementation?: number;\n}\n\nexport class LSTMCell extends RNNCell {\n  /** @nocollapse */\n  static className = 'LSTMCell';\n  readonly units: number;\n  readonly activation: Activation;\n  readonly recurrentActivation: Activation;\n  readonly useBias: boolean;\n\n  readonly kernelInitializer: Initializer;\n  readonly recurrentInitializer: Initializer;\n  readonly biasInitializer: Initializer;\n  readonly unitForgetBias: boolean;\n\n  readonly kernelConstraint: Constraint;\n  readonly recurrentConstraint: Constraint;\n  readonly biasConstraint: Constraint;\n\n  readonly kernelRegularizer: Regularizer;\n  readonly recurrentRegularizer: Regularizer;\n  readonly biasRegularizer: Regularizer;\n\n  readonly dropout: number;\n  readonly recurrentDropout: number;\n\n  readonly stateSize: number[];\n  readonly implementation: number;\n\n  readonly DEFAULT_ACTIVATION = 'tanh';\n  readonly DEFAULT_RECURRENT_ACTIVATION = 'hardSigmoid';\n  readonly DEFAULT_KERNEL_INITIALIZER = 'glorotNormal';\n  readonly DEFAULT_RECURRENT_INITIALIZER = 'orthogonal';\n\n  readonly DEFAULT_BIAS_INITIALIZER = 'zeros';\n\n  kernel: LayerVariable;\n  recurrentKernel: LayerVariable;\n  bias: LayerVariable;\n\n  constructor(args: LSTMCellLayerArgs) {\n    super(args);\n\n    this.units = args.units;\n    assertPositiveInteger(this.units, 'units');\n    this.activation = getActivation(\n        args.activation === undefined ? this.DEFAULT_ACTIVATION :\n                                        args.activation);\n    this.recurrentActivation = getActivation(\n        args.recurrentActivation === undefined ?\n            this.DEFAULT_RECURRENT_ACTIVATION :\n            args.recurrentActivation);\n    this.useBias = args.useBias == null ? true : args.useBias;\n\n    this.kernelInitializer = getInitializer(\n        args.kernelInitializer || this.DEFAULT_KERNEL_INITIALIZER);\n    this.recurrentInitializer = getInitializer(\n        args.recurrentInitializer || this.DEFAULT_RECURRENT_INITIALIZER);\n\n    this.biasInitializer =\n        getInitializer(args.biasInitializer || this.DEFAULT_BIAS_INITIALIZER);\n    this.unitForgetBias = args.unitForgetBias;\n\n    this.kernelRegularizer = getRegularizer(args.kernelRegularizer);\n    this.recurrentRegularizer = getRegularizer(args.recurrentRegularizer);\n    this.biasRegularizer = getRegularizer(args.biasRegularizer);\n\n    this.kernelConstraint = getConstraint(args.kernelConstraint);\n    this.recurrentConstraint = getConstraint(args.recurrentConstraint);\n    this.biasConstraint = getConstraint(args.biasConstraint);\n\n    this.dropout = math_utils.min(\n        [1, math_utils.max([0, args.dropout == null ? 0 : args.dropout])]);\n    this.recurrentDropout = math_utils.min([\n      1,\n      math_utils.max(\n          [0, args.recurrentDropout == null ? 0 : args.recurrentDropout])\n    ]);\n    this.implementation = args.implementation;\n    this.stateSize = [this.units, this.units];\n    this.dropoutMask = null;\n    this.recurrentDropoutMask = null;\n  }\n\n  public build(inputShape: Shape|Shape[]): void {\n    inputShape = getExactlyOneShape(inputShape);\n    const inputDim = inputShape[inputShape.length - 1];\n    this.kernel = this.addWeight(\n        'kernel', [inputDim, this.units * 4], null, this.kernelInitializer,\n        this.kernelRegularizer, true, this.kernelConstraint);\n    this.recurrentKernel = this.addWeight(\n        'recurrent_kernel', [this.units, this.units * 4], null,\n        this.recurrentInitializer, this.recurrentRegularizer, true,\n        this.recurrentConstraint);\n    let biasInitializer: Initializer;\n    if (this.useBias) {\n      if (this.unitForgetBias) {\n        const capturedBiasInit = this.biasInitializer;\n        const capturedUnits = this.units;\n        biasInitializer = new (class CustomInit extends Initializer {\n          /** @nocollapse */\n          static className = 'CustomInit';\n\n          apply(shape: Shape, dtype?: DataType): Tensor {\n            // TODO(cais): More informative variable names?\n            const bI = capturedBiasInit.apply([capturedUnits]);\n            const bF = (new Ones()).apply([capturedUnits]);\n            const bCAndH = capturedBiasInit.apply([capturedUnits * 2]);\n            return K.concatAlongFirstAxis(\n                K.concatAlongFirstAxis(bI, bF), bCAndH);\n          }\n        })();\n      } else {\n        biasInitializer = this.biasInitializer;\n      }\n      this.bias = this.addWeight(\n          'bias', [this.units * 4], null, biasInitializer, this.biasRegularizer,\n          true, this.biasConstraint);\n    } else {\n      this.bias = null;\n    }\n    // Porting Notes: Unlike the PyKeras implementation, we perform slicing\n    //   of the weights and bias in the call() method, at execution time.\n    this.built = true;\n  }\n\n  call(inputs: Tensor|Tensor[], kwargs: Kwargs): Tensor|Tensor[] {\n    return tidy(() => {\n      const training = kwargs['training'] == null ? false : kwargs['training'];\n      inputs = inputs as Tensor[];\n      if (inputs.length !== 3) {\n        throw new ValueError(\n            `LSTMCell expects 3 input Tensors (inputs, h, c), got ` +\n            `${inputs.length}.`);\n      }\n      let hTMinus1 = inputs[1];    // Previous memory state.\n      const cTMinus1 = inputs[2];  // Previous carry state.\n      inputs = inputs[0];\n      if (0 < this.dropout && this.dropout < 1 && this.dropoutMask == null) {\n        this.dropoutMask = generateDropoutMask(\n                               () => tfc.onesLike(inputs as Tensor),\n                               this.dropout, training, 4) as Tensor[];\n      }\n      if (0 < this.recurrentDropout && this.recurrentDropout < 1 &&\n          this.recurrentDropoutMask == null) {\n        this.recurrentDropoutMask =\n            generateDropoutMask(\n                () => tfc.onesLike(hTMinus1), this.recurrentDropout, training,\n                4) as Tensor[];\n      }\n      const dpMask = this.dropoutMask as [Tensor, Tensor, Tensor, Tensor];\n      const recDpMask =\n          this.recurrentDropoutMask as [Tensor, Tensor, Tensor, Tensor];\n\n      // Note: For superior performance, TensorFlow.js always uses\n      // implementation 2 regardless of the actual value of\n      // config.implementation.\n      let i: Tensor;\n      let f: Tensor;\n      let c: Tensor;\n      let o: Tensor;\n      if (0 < this.dropout && this.dropout < 1) {\n        inputs = tfc.mul(inputs, dpMask[0]);\n      }\n      let z = K.dot(inputs, this.kernel.read());\n      if (0 < this.recurrentDropout && this.recurrentDropout < 1) {\n        hTMinus1 = tfc.mul(hTMinus1, recDpMask[0]);\n      }\n      z = tfc.add(z, K.dot(hTMinus1, this.recurrentKernel.read()));\n      if (this.useBias) {\n        z = K.biasAdd(z, this.bias.read());\n      }\n\n      const [z0, z1, z2, z3] = tfc.split(z, 4, z.rank - 1);\n\n      i = this.recurrentActivation.apply(z0);\n      f = this.recurrentActivation.apply(z1);\n      c = tfc.add(tfc.mul(f, cTMinus1), tfc.mul(i, this.activation.apply(z2)));\n      o = this.recurrentActivation.apply(z3);\n\n      const h = tfc.mul(o, this.activation.apply(c));\n      // TODO(cais): Add use_learning_phase flag properly.\n      return [h, h, c];\n    });\n  }\n\n  getConfig(): serialization.ConfigDict {\n    const config: serialization.ConfigDict = {\n      units: this.units,\n      activation: serializeActivation(this.activation),\n      recurrentActivation: serializeActivation(this.recurrentActivation),\n      useBias: this.useBias,\n      kernelInitializer: serializeInitializer(this.kernelInitializer),\n      recurrentInitializer: serializeInitializer(this.recurrentInitializer),\n      biasInitializer: serializeInitializer(this.biasInitializer),\n      unitForgetBias: this.unitForgetBias,\n      kernelRegularizer: serializeRegularizer(this.kernelRegularizer),\n      recurrentRegularizer: serializeRegularizer(this.recurrentRegularizer),\n      biasRegularizer: serializeRegularizer(this.biasRegularizer),\n      activityRegularizer: serializeRegularizer(this.activityRegularizer),\n      kernelConstraint: serializeConstraint(this.kernelConstraint),\n      recurrentConstraint: serializeConstraint(this.recurrentConstraint),\n      biasConstraint: serializeConstraint(this.biasConstraint),\n      dropout: this.dropout,\n      recurrentDropout: this.recurrentDropout,\n      implementation: this.implementation,\n    };\n    const baseConfig = super.getConfig();\n    Object.assign(config, baseConfig);\n    return config;\n  }\n}\nserialization.registerClass(LSTMCell);\n\n// Porting Note: Since this is a superset of SimpleRNNLayerConfig, we inherit\n//   from that interface instead of repeating the fields here.\nexport declare interface LSTMLayerArgs extends SimpleRNNLayerArgs {\n  /**\n   * Activation function to use for the recurrent step.\n   *\n   * Defaults to hard sigmoid (`hardSigmoid`).\n   *\n   * If `null`, no activation is applied.\n   */\n  recurrentActivation?: ActivationIdentifier;\n\n  /**\n   * If `true`, add 1 to the bias of the forget gate at initialization.\n   * Setting it to `true` will also force `biasInitializer = 'zeros'`.\n   * This is recommended in\n   * [Jozefowicz et\n   * al.](http://www.jmlr.org/proceedings/papers/v37/jozefowicz15.pdf).\n   */\n  unitForgetBias?: boolean;\n\n  /**\n   * Implementation mode, either 1 or 2.\n   *   Mode 1 will structure its operations as a larger number of\n   *   smaller dot products and additions, whereas mode 2 will\n   *   batch them into fewer, larger operations. These modes will\n   *   have different performance profiles on different hardware and\n   *   for different applications.\n   *\n   * Note: For superior performance, TensorFlow.js always uses implementation\n   * 2, regardless of the actual value of this config field.\n   */\n  implementation?: number;\n}\n\nexport class LSTM extends RNN {\n  /** @nocollapse */\n  static className = 'LSTM';\n  constructor(args: LSTMLayerArgs) {\n    if (args.implementation === 0) {\n      console.warn(\n          '`implementation=0` has been deprecated, and now defaults to ' +\n          '`implementation=1`. Please update your layer call.');\n    }\n    args.cell = new LSTMCell(args);\n    super(args as RNNLayerArgs);\n    // TODO(cais): Add activityRegularizer.\n  }\n\n  call(inputs: Tensor|Tensor[], kwargs: Kwargs): Tensor|Tensor[] {\n    return tidy(() => {\n      if (this.cell.dropoutMask != null) {\n        tfc.dispose(this.cell.dropoutMask);\n        this.cell.dropoutMask = null;\n      }\n      if (this.cell.recurrentDropoutMask != null) {\n        tfc.dispose(this.cell.recurrentDropoutMask);\n        this.cell.recurrentDropoutMask = null;\n      }\n      const mask = kwargs == null ? null : kwargs['mask'];\n      const training = kwargs == null ? null : kwargs['training'];\n      const initialState: Tensor[] =\n          kwargs == null ? null : kwargs['initialState'];\n      return super.call(inputs, {mask, training, initialState});\n    });\n  }\n\n  get units(): number {\n    return (this.cell as LSTMCell).units;\n  }\n\n  get activation(): Activation {\n    return (this.cell as LSTMCell).activation;\n  }\n\n  get recurrentActivation(): Activation {\n    return (this.cell as LSTMCell).recurrentActivation;\n  }\n\n  get useBias(): boolean {\n    return (this.cell as LSTMCell).useBias;\n  }\n\n  get kernelInitializer(): Initializer {\n    return (this.cell as LSTMCell).kernelInitializer;\n  }\n\n  get recurrentInitializer(): Initializer {\n    return (this.cell as LSTMCell).recurrentInitializer;\n  }\n\n  get biasInitializer(): Initializer {\n    return (this.cell as LSTMCell).biasInitializer;\n  }\n\n  get unitForgetBias(): boolean {\n    return (this.cell as LSTMCell).unitForgetBias;\n  }\n\n  get kernelRegularizer(): Regularizer {\n    return (this.cell as LSTMCell).kernelRegularizer;\n  }\n\n  get recurrentRegularizer(): Regularizer {\n    return (this.cell as LSTMCell).recurrentRegularizer;\n  }\n\n  get biasRegularizer(): Regularizer {\n    return (this.cell as LSTMCell).biasRegularizer;\n  }\n\n  get kernelConstraint(): Constraint {\n    return (this.cell as LSTMCell).kernelConstraint;\n  }\n\n  get recurrentConstraint(): Constraint {\n    return (this.cell as LSTMCell).recurrentConstraint;\n  }\n\n  get biasConstraint(): Constraint {\n    return (this.cell as LSTMCell).biasConstraint;\n  }\n\n  get dropout(): number {\n    return (this.cell as LSTMCell).dropout;\n  }\n\n  get recurrentDropout(): number {\n    return (this.cell as LSTMCell).recurrentDropout;\n  }\n\n  get implementation(): number {\n    return (this.cell as LSTMCell).implementation;\n  }\n\n  getConfig(): serialization.ConfigDict {\n    const config: serialization.ConfigDict = {\n      units: this.units,\n      activation: serializeActivation(this.activation),\n      recurrentActivation: serializeActivation(this.recurrentActivation),\n      useBias: this.useBias,\n      kernelInitializer: serializeInitializer(this.kernelInitializer),\n      recurrentInitializer: serializeInitializer(this.recurrentInitializer),\n      biasInitializer: serializeInitializer(this.biasInitializer),\n      unitForgetBias: this.unitForgetBias,\n      kernelRegularizer: serializeRegularizer(this.kernelRegularizer),\n      recurrentRegularizer: serializeRegularizer(this.recurrentRegularizer),\n      biasRegularizer: serializeRegularizer(this.biasRegularizer),\n      activityRegularizer: serializeRegularizer(this.activityRegularizer),\n      kernelConstraint: serializeConstraint(this.kernelConstraint),\n      recurrentConstraint: serializeConstraint(this.recurrentConstraint),\n      biasConstraint: serializeConstraint(this.biasConstraint),\n      dropout: this.dropout,\n      recurrentDropout: this.recurrentDropout,\n      implementation: this.implementation,\n    };\n    const baseConfig = super.getConfig();\n    delete baseConfig['cell'];\n    Object.assign(config, baseConfig);\n    return config;\n  }\n\n  /** @nocollapse */\n  static fromConfig<T extends serialization.Serializable>(\n      cls: serialization.SerializableConstructor<T>,\n      config: serialization.ConfigDict): T {\n    if (config['implmentation'] === 0) {\n      config['implementation'] = 1;\n    }\n    return new cls(config);\n  }\n}\nserialization.registerClass(LSTM);\n\nexport declare interface StackedRNNCellsArgs extends LayerArgs {\n  /**\n   * A `Array` of `RNNCell` instances.\n   */\n  cells: RNNCell[];\n}\n\nexport class StackedRNNCells extends RNNCell {\n  /** @nocollapse */\n  static className = 'StackedRNNCells';\n  protected cells: RNNCell[];\n\n  constructor(args: StackedRNNCellsArgs) {\n    super(args);\n    this.cells = args.cells;\n  }\n\n  get stateSize(): number[] {\n    // States are a flat list in reverse order of the cell stack.\n    // This allows perserving the requirement `stack.statesize[0] ===\n    // outputDim`. E.g., states of a 2-layer LSTM would be `[h2, c2, h1, c1]`,\n    // assuming one LSTM has states `[h, c]`.\n    const stateSize: number[] = [];\n    for (const cell of this.cells.slice().reverse()) {\n      if (Array.isArray(cell.stateSize)) {\n        stateSize.push(...cell.stateSize);\n      } else {\n        stateSize.push(cell.stateSize);\n      }\n    }\n    return stateSize;\n  }\n\n  call(inputs: Tensor|Tensor[], kwargs: Kwargs): Tensor|Tensor[] {\n    return tidy(() => {\n      inputs = inputs as Tensor[];\n      let states = inputs.slice(1);\n\n      // Recover per-cell states.\n      const nestedStates: Tensor[][] = [];\n      for (const cell of this.cells.slice().reverse()) {\n        if (Array.isArray(cell.stateSize)) {\n          nestedStates.push(states.splice(0, cell.stateSize.length));\n        } else {\n          nestedStates.push(states.splice(0, 1));\n        }\n      }\n      nestedStates.reverse();\n\n      // Call the cells in order and store the returned states.\n      const newNestedStates: Tensor[][] = [];\n      let callInputs: Tensor[];\n      for (let i = 0; i < this.cells.length; ++i) {\n        const cell = this.cells[i];\n        states = nestedStates[i];\n        // TODO(cais): Take care of constants.\n        if (i === 0) {\n          callInputs = [inputs[0]].concat(states);\n        } else {\n          callInputs = [callInputs[0]].concat(states);\n        }\n        callInputs = cell.call(callInputs, kwargs) as Tensor[];\n        newNestedStates.push(callInputs.slice(1));\n      }\n\n      // Format the new states as a flat list in reverse cell order.\n      states = [];\n      for (const cellStates of newNestedStates.slice().reverse()) {\n        states.push(...cellStates);\n      }\n      return [callInputs[0]].concat(states);\n    });\n  }\n\n  public build(inputShape: Shape|Shape[]): void {\n    if (isArrayOfShapes(inputShape)) {\n      // TODO(cais): Take care of input constants.\n      // const constantShape = inputShape.slice(1);\n      inputShape = (inputShape as Shape[])[0];\n    }\n    inputShape = inputShape as Shape;\n    let outputDim: number;\n    this.cells.forEach((cell, i) => {\n      nameScope(`RNNCell_${i}`, () => {\n        // TODO(cais): Take care of input constants.\n\n        cell.build(inputShape);\n        if (Array.isArray(cell.stateSize)) {\n          outputDim = cell.stateSize[0];\n        } else {\n          outputDim = cell.stateSize;\n        }\n        inputShape = [inputShape[0], outputDim] as Shape;\n      });\n    });\n    this.built = true;\n  }\n\n  getConfig(): serialization.ConfigDict {\n    const cellConfigs: serialization.ConfigDict[] = [];\n    for (const cell of this.cells) {\n      cellConfigs.push({\n        'className': cell.getClassName(),\n        'config': cell.getConfig(),\n      });\n    }\n    const config: serialization.ConfigDict = {'cells': cellConfigs};\n    const baseConfig = super.getConfig();\n    Object.assign(config, baseConfig);\n    return config;\n  }\n\n  /** @nocollapse */\n  static fromConfig<T extends serialization.Serializable>(\n      cls: serialization.SerializableConstructor<T>,\n      config: serialization.ConfigDict,\n      customObjects = {} as serialization.ConfigDict): T {\n    const cells: RNNCell[] = [];\n    for (const cellConfig of (config['cells'] as serialization.ConfigDict[])) {\n      cells.push(deserialize(cellConfig, customObjects) as RNNCell);\n    }\n    return new cls({cells});\n  }\n\n  get trainableWeights(): LayerVariable[] {\n    if (!this.trainable) {\n      return [];\n    }\n    const weights: LayerVariable[] = [];\n    for (const cell of this.cells) {\n      weights.push(...cell.trainableWeights);\n    }\n    return weights;\n  }\n\n  get nonTrainableWeights(): LayerVariable[] {\n    const weights: LayerVariable[] = [];\n    for (const cell of this.cells) {\n      weights.push(...cell.nonTrainableWeights);\n    }\n    if (!this.trainable) {\n      const trainableWeights: LayerVariable[] = [];\n      for (const cell of this.cells) {\n        trainableWeights.push(...cell.trainableWeights);\n      }\n      return trainableWeights.concat(weights);\n    }\n    return weights;\n  }\n\n  /**\n   * Retrieve the weights of a the model.\n   *\n   * @returns A flat `Array` of `tf.Tensor`s.\n   */\n  getWeights(): Tensor[] {\n    const weights: LayerVariable[] = [];\n    for (const cell of this.cells) {\n      weights.push(...cell.weights);\n    }\n    return batchGetValue(weights);\n  }\n\n  /**\n   * Set the weights of the model.\n   *\n   * @param weights An `Array` of `tf.Tensor`s with shapes and types matching\n   *     the output of `getWeights()`.\n   */\n  setWeights(weights: Tensor[]): void {\n    const tuples: Array<[LayerVariable, Tensor]> = [];\n    for (const cell of this.cells) {\n      const numParams = cell.weights.length;\n      const inputWeights = weights.splice(numParams);\n      for (let i = 0; i < cell.weights.length; ++i) {\n        tuples.push([cell.weights[i], inputWeights[i]]);\n      }\n    }\n    batchSetValue(tuples);\n  }\n\n  // TODO(cais): Maybe implemnt `losses` and `getLossesFor`.\n}\nserialization.registerClass(StackedRNNCells);\n\nfunction generateDropoutMask(\n    ones: () => Tensor, rate: number, training: boolean = null,\n    count = 1): Tensor|Tensor[] {\n  function droppedInputs(): Tensor {\n    return K.dropout(ones(), rate);\n  }\n  if (count > 1) {\n    const mask: Tensor[] = [];\n    for (let i = 0; i < count; i++) {\n      mask.push(K.inTrainPhase(droppedInputs, ones, training));\n    }\n    return mask.map(m => tfc.keep(m.clone()));\n  } else {\n    return tfc.keep(K.inTrainPhase(droppedInputs, ones, training).clone());\n  }\n}\n"]}},"error":null,"hash":"31a6e51539e33a5f349b87650ef99a5b","cacheData":{"env":{}}}