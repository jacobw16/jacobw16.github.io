{"id":"node_modules/@tensorflow/tfjs-layers/dist/backend/tfjs_backend.js","dependencies":[{"name":"C:\\Users\\Jacob\\Documents\\jump(3)\\scripts\\node_modules\\@tensorflow\\tfjs-layers\\dist\\backend\\tfjs_backend.js.map","includedInParent":true,"mtime":499162500000},{"name":"C:\\Users\\Jacob\\Documents\\jump(3)\\scripts\\node_modules\\@tensorflow\\tfjs-layers\\src\\backend\\tfjs_backend.ts","includedInParent":true,"mtime":499162500000},{"name":"C:\\Users\\Jacob\\Documents\\jump(3)\\scripts\\package.json","includedInParent":true,"mtime":1577649187475},{"name":"@tensorflow/tfjs-core","loc":{"line":16,"column":26},"parent":"C:\\Users\\Jacob\\Documents\\jump(3)\\scripts\\node_modules\\@tensorflow\\tfjs-layers\\dist\\backend\\tfjs_backend.js","resolved":"C:\\Users\\Jacob\\Documents\\jump(3)\\scripts\\node_modules\\@tensorflow\\tfjs-core\\dist\\tf-core.esm.js"},{"name":"../common","loc":{"line":17,"column":23},"parent":"C:\\Users\\Jacob\\Documents\\jump(3)\\scripts\\node_modules\\@tensorflow\\tfjs-layers\\dist\\backend\\tfjs_backend.js","resolved":"C:\\Users\\Jacob\\Documents\\jump(3)\\scripts\\node_modules\\@tensorflow\\tfjs-layers\\dist\\common.js"},{"name":"../errors","loc":{"line":18,"column":23},"parent":"C:\\Users\\Jacob\\Documents\\jump(3)\\scripts\\node_modules\\@tensorflow\\tfjs-layers\\dist\\backend\\tfjs_backend.js","resolved":"C:\\Users\\Jacob\\Documents\\jump(3)\\scripts\\node_modules\\@tensorflow\\tfjs-layers\\dist\\errors.js"},{"name":"../utils/math_utils","loc":{"line":19,"column":25},"parent":"C:\\Users\\Jacob\\Documents\\jump(3)\\scripts\\node_modules\\@tensorflow\\tfjs-layers\\dist\\backend\\tfjs_backend.js","resolved":"C:\\Users\\Jacob\\Documents\\jump(3)\\scripts\\node_modules\\@tensorflow\\tfjs-layers\\dist\\utils\\math_utils.js"},{"name":"./common","loc":{"line":20,"column":23},"parent":"C:\\Users\\Jacob\\Documents\\jump(3)\\scripts\\node_modules\\@tensorflow\\tfjs-layers\\dist\\backend\\tfjs_backend.js","resolved":"C:\\Users\\Jacob\\Documents\\jump(3)\\scripts\\node_modules\\@tensorflow\\tfjs-layers\\dist\\backend\\common.js"}],"generated":{"js":"\"use strict\";\n/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * deeplearn.js backend.\n */\nvar tfc = require(\"@tensorflow/tfjs-core\");\nvar tfjs_core_1 = require(\"@tensorflow/tfjs-core\");\nvar common_1 = require(\"../common\");\nvar errors_1 = require(\"../errors\");\nvar math_utils = require(\"../utils/math_utils\");\nvar common_2 = require(\"./common\");\n// tslint:enable\n/* Setting and getting backend from deeplearn.js. */\n// Default deeplearn.js backend is WebGL (GPU).\nvar backend = 'webgl';\nfunction setBackend(requestedBackend) {\n    tfc.setBackend(requestedBackend);\n    backend = requestedBackend;\n}\nexports.setBackend = setBackend;\nfunction getBackend() {\n    return backend;\n}\nexports.getBackend = getBackend;\n/**\n * Indicates whether the backend is operating symbolically.\n *\n * This function will be used to determine how to interpret user code. If\n * it returns true, calls to the backend construct a symbolic graph; if\n * it returns false, calls to the backend execute immediately.\n */\nfunction isBackendSymbolic() {\n    return false;\n}\nexports.isBackendSymbolic = isBackendSymbolic;\n/**\n * Get the number of elements in a Tensor.\n * @param x The Tensor.\n * @return Number of elements in `x`.\n */\nfunction countParams(x) {\n    var shape = x.shape;\n    if (shape.length > 0) {\n        return shape.reduce(function (a, b) { return a * b; });\n    }\n    else {\n        // Scalar.\n        return 1;\n    }\n}\nexports.countParams = countParams;\n/**\n * Casts a tensor to a different dtype and returns it.\n * @param x Input tensor.\n * @param dtype String: 'float32'|'int32'|'bool'.\n * @returns Tensor of the specified `dtype`.\n */\nfunction cast(x, dtype) {\n    return x.asType(dtype);\n}\nexports.cast = cast;\n/**\n * Adds a 1-sized dimension at index \"axis\".\n * @param x Input tensor.\n * @param axis Position where to add the new axis.\n * @returns Result of the dimension expansion.\n */\nfunction expandDims(x, axis) {\n    if (axis === void 0) { axis = -1; }\n    var outShape = x.shape.slice();\n    if (axis < 0) {\n        axis = outShape.length + axis + 1;\n    }\n    outShape.splice(axis, 0, 1);\n    return x.reshape(outShape);\n}\nexports.expandDims = expandDims;\n/**\n * Repeats a 2D tensor.\n *\n * If `x` has shape `[samples, dim]` and `n` is 2, for example, the output\n * will have shape `[samples, 2, dim]`.\n *\n * @param x Input tensor.\n * @param n Integer, number of times to repeat.\n * @returns The result of the repeat operation.\n * @throws ValueError: If input tensor is not 2D.\n */\nfunction repeat(x, n) {\n    return tfjs_core_1.tidy(function () {\n        if (x.shape.length !== 2) {\n            throw new errors_1.ValueError(\"repeat() expects a rank-2 tensor, but received a \" +\n                (\"rank-\" + x.shape.length + \" tensor.\"));\n        }\n        var y = expandDims(x, 1);\n        return tile(y, [1, n, 1]);\n    });\n}\nexports.repeat = repeat;\n/**\n * Flatten an Tensor into 1D.\n * @param x Input tensor.\n * @return The result of the flattening `x`.\n */\nfunction flatten(x) {\n    var newShape = [math_utils.arrayProd(x.shape)];\n    return x.reshape(newShape);\n}\nexports.flatten = flatten;\n/**\n * Turn a nD tensor into a 2D tensor with same 0th dimension.\n * In other words, it flattens each data samples of a batch.\n *\n * @param x The tensor to flatten. The rank of this tensor is required to be 2\n *   or higher.\n * @return The result of the flattening.\n */\nfunction batchFlatten(x) {\n    if (x.rank <= 1) {\n        throw new errors_1.ValueError(\"batchFlatten requires a minimum rank of 2. Got rank: \" + x.rank + \".\");\n    }\n    var newShape = [x.shape[0], math_utils.arrayProd(x.shape, 1)];\n    return x.reshape(newShape);\n}\nexports.batchFlatten = batchFlatten;\n/**\n * Do slicing along the first axis.\n * @param array input `tf.Tensor`.\n * @param start starting index, inclusive.\n * @param size size of the slice along the first axis.\n * @returns result of the slicing.\n * @throws ValueError: If `array` is of an unsupported subtype of `tf.Tensor`.\n */\nfunction sliceAlongFirstAxis(array, start, size) {\n    return tfjs_core_1.tidy(function () {\n        switch (array.rank) {\n            case 1:\n                return tfc.slice1d(array, start, size);\n            case 2:\n                return tfc.slice2d(array, [start, 0], [size, array.shape[1]]);\n            case 3:\n                return tfc.slice3d(array, [start, 0, 0], [size, array.shape[1], array.shape[2]]);\n            case 4:\n                return tfc.slice4d(array, [start, 0, 0, 0], [size, array.shape[1], array.shape[2], array.shape[3]]);\n            case 5:\n                return tfc.slice(array, [start, 0, 0, 0, 0], [\n                    size, array.shape[1], array.shape[2], array.shape[3], array.shape[4]\n                ]);\n            case 6:\n                return tfc.slice(array, [start, 0, 0, 0, 0, 0], [\n                    size, array.shape[1], array.shape[2], array.shape[3], array.shape[4],\n                    array.shape[5]\n                ]);\n            default:\n                throw new errors_1.ValueError(\"sliceAlongFirstAxis() received an unsupported tensor rank: \" +\n                    (\"\" + array.rank));\n        }\n    });\n}\nexports.sliceAlongFirstAxis = sliceAlongFirstAxis;\n/**\n * Do slicing along the last axis.\n * @param array input `tf.Tensor`.\n * @param start starting index, inclusive.\n * @param size size of the slice along the last axis.\n * @returns result of the slicing.\n * @throws ValueError: If `array` is of an unsupported subtype of `tf.Tensor`.\n */\nfunction sliceAlongLastAxis(array, start, size) {\n    return tfjs_core_1.tidy(function () {\n        switch (array.rank) {\n            case 1:\n                return tfc.slice1d(array, start, size);\n            case 2:\n                return tfc.slice2d(array, [0, start], [array.shape[0], size]);\n            case 3:\n                return tfc.slice3d(array, [0, 0, start], [array.shape[0], array.shape[1], size]);\n            case 4:\n                return tfc.slice4d(array, [0, 0, 0, start], [array.shape[0], array.shape[1], array.shape[2], size]);\n            default:\n                throw new errors_1.ValueError(\"sliceAlongLastAxis() received an unsupported tensor rank: \" +\n                    (\"\" + array.rank));\n        }\n    });\n}\nexports.sliceAlongLastAxis = sliceAlongLastAxis;\n/**\n * Do slicing along the sepcified axis.\n * @param array input `tf.Tensor`.\n * @param start starting index, inclusive.\n * @param size of the slice along the chosen axis.\n * @param choose an axis.\n * @returns result of the slicing.\n * @throws ValueError: If `array` is of an unsupported subtype of `tf.Tensor`.\n */\nfunction sliceAlongAxis(array, start, size, axis) {\n    return tfjs_core_1.tidy(function () {\n        switch (array.rank) {\n            case 1:\n                return tfc.slice1d(array, start, size);\n            case 2:\n                switch (axis) {\n                    case 1:\n                        return sliceAlongFirstAxis(array, start, size);\n                    case 2:\n                        return sliceAlongLastAxis(array, start, size);\n                    default:\n                        throw new errors_1.ValueError(\"The axis is not within the rank of the tensor \" +\n                            (\"\" + axis));\n                }\n            case 3:\n                switch (axis) {\n                    case 1:\n                        return sliceAlongFirstAxis(array, start, size);\n                    case 2:\n                        return tfc.slice3d(array, [0, start, 0], [array.shape[0], size, array.shape[2]]);\n                    case 3:\n                        return sliceAlongLastAxis(array, start, size);\n                    default:\n                        throw new errors_1.ValueError(\"The axis is not within the rank of the tensor \" +\n                            (\"\" + axis));\n                }\n            case 4:\n                switch (axis) {\n                    case 1:\n                        return sliceAlongFirstAxis(array, start, size);\n                    case 2:\n                        return tfc.slice4d(array, [0, start, 0, 0], [array.shape[0], size, array.shape[2], array.shape[3]]);\n                    case 3:\n                        return tfc.slice4d(array, [0, 0, start, 0], [array.shape[0], array.shape[1], size, array.shape[3]]);\n                    case 4:\n                        return sliceAlongLastAxis(array, start, size);\n                    default:\n                        throw new errors_1.ValueError(\"The axis is not within the rank of the tensor \" +\n                            (\"\" + axis));\n                }\n            default:\n                throw new errors_1.ValueError(\"sliceAlongLastAxis() received an unsupported tensor rank: \" +\n                    (\"\" + array.rank));\n        }\n    });\n}\nexports.sliceAlongAxis = sliceAlongAxis;\n/**\n * Concatenates a list of tensors alongside the specified axis.\n * @param tensors `Array` of tensors to concatenate.\n * @param axis Concatenation axis.\n * @returns The result of the concatenation.\n */\nfunction concatenate(tensors, axis) {\n    if (axis === void 0) { axis = -1; }\n    var rank;\n    if (axis < 0) {\n        rank = tensors[0].rank;\n        if (rank !== 0) {\n            axis = rank;\n        }\n        else {\n            axis = 0;\n        }\n    }\n    if (axis === tensors[0].rank) {\n        // Porting Note: This is necessary because tfc.concat() requires axis to be\n        //   in the interval [-rank, rank).\n        axis = -1;\n    }\n    // Porting Note: Sparse concat is not supported yet.\n    return tfc.concat(tensors, axis);\n}\nexports.concatenate = concatenate;\n/**\n * Concatenate two arrays along the first dimension.\n * @param a The 1st `tf.Tensor` to concatenate.\n * @param b The 2nd `tf.Tensor` to concatenate.\n * @returns Result of the concatenation.\n * @throws ValueError: If `a` is of an unsupported subtype of `tf.Tensor`.\n */\nfunction concatAlongFirstAxis(a, b) {\n    switch (a.rank) {\n        case 1:\n            return tfc.concat1d([a, b]);\n        case 2:\n            return tfc.concat2d([a, b], 0);\n        case 3:\n            return tfc.concat3d([a, b], 0);\n        case 4:\n            return tfc.concat4d([a, b], 0);\n        default:\n            throw new errors_1.ValueError(\"concatAlongFirstAxis() received an unsupported \" +\n                (\"tensor rank: \" + a.rank));\n    }\n}\nexports.concatAlongFirstAxis = concatAlongFirstAxis;\n/**\n * Creates a tensor by tiling `x` by `n`.\n * @param x A tensor.\n * @param n An Array of integers or a single integer. If an Array, the length\n *   must be the same as the number of dimensions in `x`. If a single integer,\n *   it will be treated as an Array of length 1.\n */\nfunction tile(x, n) {\n    if (!Array.isArray(n)) {\n        n = [n];\n    }\n    if (x.rank !== n.length) {\n        throw new errors_1.ValueError(\"The length of input n (\" + n.length + \") does not match \" +\n            (\"the number of dimensions in input x (\" + x.rank + \")\"));\n    }\n    return tfc.tile(x, n);\n}\nexports.tile = tile;\n/* Creation of random tensors. */\n/**\n * Get a tensor with normal distribution of values.\n *\n * @param shape Shape of the tensor.\n * @param mean mean value of the normal distribution.\n * @param stddev standard deviation of the normal distribution.\n * @param dtype\n * @param seed\n * @return The normal tensor.\n */\nfunction randomNormal(shape, mean, stddev, dtype, seed) {\n    if (mean === void 0) { mean = 0.0; }\n    if (stddev === void 0) { stddev = 1.0; }\n    return tfc.randomNormal(shape, mean, stddev, dtype, seed);\n}\nexports.randomNormal = randomNormal;\n/* Linear Algebra */\n/**\n * Multiply two tensors and returns the result as a tensor.\n *\n * For 2D tensors, this is equivalent to matrix multiplication (matMul).\n * For tensors of higher ranks, it follows the Theano behavior,\n * (e.g. `(2, 3) * (4, 3, 5) -> (2, 4, 5)`).  From the Theano documentation:\n *\n * For N dimensions it is a sum product over the last axis of x and the\n * second-to-last of y:\n *\n * @param a A tensor of at least rank 2.\n * @param b A tensor of at least rank 2.\n * @param activation (optional) A string identifying the activation\n *   function.\n * @return Result of the dot operation.\n */\nfunction dot(a, b, activation, bias) {\n    if ((a.rank < 2) || (b.rank < 2)) {\n        throw new errors_1.NotImplementedError(\"dot requires both inputs to be rank >= 2\" +\n            (\" but got x shape = \" + a.shape + \" and y shape = \" + b.shape));\n    }\n    if (b.rank >= 3) {\n        var xLastDim = a.shape.slice(-1)[0];\n        var ySecondLastDim = b.shape.slice(-2)[0];\n        if (xLastDim !== ySecondLastDim) {\n            throw new errors_1.NotImplementedError(\"If rank y >= 3, then the second last dim\" +\n                (\" of y must equal the last dim of x but got x shape = \" + a.shape + \" and \") +\n                (\" y shape = \" + b.shape));\n        }\n    }\n    // Handle basic 2D x 2D case.\n    if ((a.rank === 2) && (b.rank === 2)) {\n        var transposeA = false;\n        var transposeB = false;\n        // tfc.fused.matMul only fuses certain activation functions. Unsupported\n        // activation functions are treated as 'linear' activations, which is\n        // equivalent to a no-op.\n        return tfc.fused.matMul({\n            a: a,\n            b: b,\n            transposeA: transposeA,\n            transposeB: transposeB,\n            bias: bias ? reshapeBias(a.rank, bias, common_2.imageDataFormat()) : null,\n            activation: activation\n        });\n    }\n    else {\n        // Reshape x into the analogous 2D Tensor.\n        var aFirstDims = a.shape.slice(); // Holds all but the last dim of x.\n        var aLastDim = aFirstDims.pop();\n        a = a.reshape([-1, aLastDim]);\n        // Reshape y into the analogous 2D Tensor, and keep track of the\n        // required dimensions to reproduce the output shape.\n        var bShape = b.shape.slice();\n        var bLastDim = bShape.pop();\n        var ySecondLastDim = bShape.pop();\n        var yOtherDims = bShape.concat([bLastDim]);\n        // permutation should be like [r-2, 0, 1, 2, ... r-4, r-3, r-1]\n        // where r is the rank of y.\n        var perm = Array.from({ length: b.rank }, function (_, i) {\n            if (i === 0) {\n                return b.rank - 2;\n            }\n            else if (i <= b.rank - 2) {\n                return i - 1;\n            }\n            return i;\n        });\n        b = b.transpose(perm).reshape([ySecondLastDim, -1]);\n        // Multiply x and y as 2D Tensors, and then reshape back to original.\n        var outputShape = aFirstDims.concat(yOtherDims);\n        var transposeA = false;\n        var transposeB = false;\n        return tfc.fused\n            .matMul({\n            a: a,\n            b: b,\n            transposeA: transposeA,\n            transposeB: transposeB,\n            bias: bias ? reshapeBias(a.rank, bias, common_2.imageDataFormat()) : null,\n            activation: activation\n        })\n            .reshape(outputShape);\n    }\n}\nexports.dot = dot;\n/**\n * Compute the sign Tensor of an input Tensor.\n *\n * Elements of the input `tf.Tensor` that are === 0 are mapped to 0.\n * Elements of the input `tf.Tensor` that are > 0 are mapped to 1.\n * Elements of the input `tf.Tensor` that are < 0 are mapped to -1.\n *\n * @param x Input `tf.Tensor`.\n * @return The sign `tf.Tensor`.\n */\nfunction sign(x) {\n    // TODO(cais): Move to the core.\n    return tfjs_core_1.tidy(function () {\n        var zerosLikeX = tfjs_core_1.zerosLike(x);\n        var onesLikeX = tfjs_core_1.onesLike(x);\n        return tfjs_core_1.where(tfc.equal(x, zerosLikeX), zerosLikeX, tfjs_core_1.where(tfc.greater(x, tfjs_core_1.zerosLike(x)), onesLikeX, tfc.mul(-1, onesLikeX)));\n    });\n}\nexports.sign = sign;\n/**\n * Computes the one-hot representation of an integer tensor.\n * @param indices nD integer tensor of shape\n *   `(batch_size, dim1, dim2, ... dim(n-1))`\n * @param numClasses Integer, number of classes to consider.\n * @returns (n + 1)D one hot representation of the input\n *   with shape `(batch_size, dim1, dim2, ... dim(n-1), num_classes)`\n */\nfunction oneHot(indices, numClasses) {\n    return tfjs_core_1.tidy(function () {\n        if (indices.rank !== 1) {\n            throw new Error('Only 1D one-hot tensors are supported in the ' +\n                'deeplearn backend, at present.');\n        }\n        indices = indices.toInt();\n        return tfc.oneHot(indices, numClasses).toFloat();\n    });\n}\nexports.oneHot = oneHot;\n/* Elementary math functions. */\n/**\n * Retrieves the elements of indices `indices` in the tensor `reference`.\n * @param reference A tensor.\n * @param indices An integer tensor of indices or an `Array` of integers.\n * @param axis Axis along which to perform the gather operation.\n * @returns The result of the gathering as a tensor.\n */\nfunction gather(reference, indices, axis) {\n    return tfjs_core_1.tidy(function () {\n        if (Array.isArray(indices)) {\n            indices = tfjs_core_1.tensor1d(indices, 'int32');\n        }\n        else {\n            indices = indices.toInt();\n        }\n        return tfc.gather(reference, indices, axis);\n    });\n}\nexports.gather = gather;\n/**\n * Element-wise square.\n * @param x Input tensor.\n * @return element-wise x^2\n */\nfunction square(x) {\n    return tfc.mulStrict(x, x);\n}\nexports.square = square;\n/**\n * Element-wise exponentiation.\n *\n * Porting Note: In PyKeras, `a` (the exponent) is a Python integer, which\n *   takes advatnage of the backend's (e.g., TensorFlow's) automatic\n * conversion to tensor. Here we allow `a` to be either a number or a tensor.\n *\n * @param x The base tensor.\n * @param a The exponent, tensor or number. If a number, it is rounded to the\n *   nearest integer and converted to a tensor.\n * @returns A tensor of the same shape as `x`.\n */\nfunction pow(x, a) {\n    return tfjs_core_1.tidy(function () {\n        if (typeof (a) === 'number') {\n            a = tfjs_core_1.scalar(Math.round(a), 'int32');\n        }\n        if (a.dtype !== 'int32') {\n            throw new errors_1.NotImplementedError(\"Non-int32 dtype (\" + a.dtype + \") is not supported by pow() yet\");\n        }\n        return tfc.pow(x, a);\n    });\n}\nexports.pow = pow;\n/**\n * Reshapes bias tensor according to rank of x.\n */\nfunction reshapeBias(xRank, bias, dataFormat) {\n    var biasShape = bias.shape;\n    if (bias.rank !== 1 && bias.rank !== xRank) {\n        throw new errors_1.ValueError(\"Unexpected bias dimensions: \" + bias.rank +\n            (\"; expected it to be 1 or \" + xRank));\n    }\n    if (xRank === 5) {\n        if (dataFormat === 'channelsFirst') {\n            if (biasShape.length === 1) {\n                return bias.reshape([1, biasShape[0], 1, 1, 1]);\n            }\n            else {\n                return bias.reshape([1, biasShape[3], biasShape[0], biasShape[1], biasShape[2]]);\n            }\n        }\n        else if (dataFormat === 'channelsLast') {\n            if (biasShape.length === 1) {\n                return bias.reshape([1, 1, 1, 1, biasShape[0]]);\n            }\n            else {\n                return bias.reshape([1].concat(biasShape));\n            }\n        }\n    }\n    else if (xRank === 4) {\n        if (dataFormat === 'channelsFirst') {\n            if (biasShape.length === 1) {\n                return bias.reshape([1, biasShape[0], 1, 1]);\n            }\n            else {\n                return bias.reshape([1, biasShape[2], biasShape[0], biasShape[1]]);\n            }\n        }\n        else if (dataFormat === 'channelsLast') {\n            if (biasShape.length === 1) {\n                return bias.reshape([1, 1, 1, biasShape[0]]);\n            }\n            else {\n                return bias.reshape([1].concat(biasShape));\n            }\n        }\n    }\n    else if (xRank === 3) {\n        if (dataFormat === 'channelsFirst') {\n            if (biasShape.length === 1) {\n                return bias.reshape([1, biasShape[0], 1]);\n            }\n            else {\n                return bias.reshape([1, biasShape[1], biasShape[0]]);\n            }\n        }\n        else if (dataFormat === 'channelsLast') {\n            if (biasShape.length === 1) {\n                return bias.reshape([1, 1, biasShape[0]]);\n            }\n            else {\n                return bias.reshape([1].concat(biasShape));\n            }\n        }\n    }\n    else if (xRank < 3) {\n        return bias;\n    }\n    throw new errors_1.ValueError(\"Unsupported input rank by biasAdd: \" + bias.rank);\n}\n/* Neural-network operations. */\n/**\n * Add a bias to a tensor.\n *\n * @param x The tensor to add the bias to.\n * @param bias The bias to add to `x`. Must be 1D or the same rank as `x`.\n * @return Result of the bias adding.\n * @throws ValueError: If the rank of `bias` is incorrect.\n */\nfunction biasAdd(x, bias, dataFormat) {\n    return tfjs_core_1.tidy(function () {\n        if (dataFormat == null) {\n            dataFormat = common_2.imageDataFormat();\n        }\n        common_1.checkDataFormat(dataFormat);\n        return x.add(reshapeBias(x.rank, bias, dataFormat));\n    });\n}\nexports.biasAdd = biasAdd;\n/**\n * Exponential linear unit (ELU).\n * @param x A tensor or variable to compute the activation function for.\n * @param alpha: A scalar, a scaling factor for the negative section.\n * @return Output of the ELU operation.\n */\nfunction elu(x, alpha) {\n    if (alpha === void 0) { alpha = 1; }\n    // TODO(cais): Add support for alpha values other than 1.\n    if (alpha !== 1) {\n        throw new errors_1.NotImplementedError(\"Support for alpha values other than 1 (\" + alpha + \") is not implemented \" +\n            \"yet.\");\n    }\n    return tfc.elu(x);\n}\nexports.elu = elu;\n/**\n * Softsign of a tensor.\n *\n * Defined as x / (abs(x) + 1), element-wise.\n *\n * @param x: Input.\n * @returns Output.\n */\nfunction softsign(x) {\n    return tfjs_core_1.tidy(function () { return tfc.div(x, tfc.abs(x).add(1)); });\n}\nexports.softsign = softsign;\n/**\n * Sets entries in `x` to zero at random, while scaling the entire tensor.\n *\n * @param x input tensor.\n * @param level fraction of the entries in the tensor that will be set to 0.\n * @param noiseShape shape of randomly generated keep/drop flags, must be\n *   broadcastable to the shape of `x`. Optional.\n * @param seed random seed to ensure determinism. Optional.\n * @returns Result of the dropout operation.\n */\nfunction dropout(x, level, noiseShape, seed) {\n    return tfjs_core_1.tidy(function () { return tfc.dropout(x, level, noiseShape, seed); });\n}\nexports.dropout = dropout;\n/**\n * Element-wise, segment-wise linear approximation of sigmoid.\n *\n * Returns `0.` if `x < -2.5`, `1.` if `x > 2.5`.\n * In `-2.5 <= x <= 2.5`, returns `0.2 * x + 0.5`.\n *\n * @param x Input tensor.\n * @returns Output tensor.\n */\nfunction hardSigmoid(x) {\n    return tfjs_core_1.tidy(function () {\n        var y = tfc.add(.5, tfc.mul(.2, x));\n        return tfc.clipByValue(y, 0, 1);\n    });\n}\nexports.hardSigmoid = hardSigmoid;\n/**\n * Invoke `x` in the training phase, and `alt` otherwise.\n *\n * Porting Note: We do not create placeholder tensors for the `training`\n * boolean flag here, because there is no such thing in the TF.js imperative\n * backend.\n *\n * @param x The function to invoke iff `training` is `true`.\n * @param alt The function to invoke iff `training` is `false`.\n * @param training Boolean flag for whether training phase is active.\n * @returns The return value of `x()` if `training` is `true`, or the return\n *   value of `alt()` if `training` is `false`.\n */\nfunction inTrainPhase(x, alt, training) {\n    if (training === void 0) { training = false; }\n    return training ? x() : alt();\n}\nexports.inTrainPhase = inTrainPhase;\n"},"sourceMaps":{"js":{"version":3,"file":"tfjs_backend.js","sourceRoot":"","sources":["../../src/backend/tfjs_backend.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n\n/**\n * deeplearn.js backend.\n */\n\nimport * as tfc from '@tensorflow/tfjs-core';\nimport {onesLike as coreOnesLike, scalar, Tensor, Tensor1D, tensor1d, Tensor2D, Tensor3D, Tensor4D, Tensor5D, tidy, where, zerosLike as coreZerosLike} from '@tensorflow/tfjs-core';\nimport {checkDataFormat} from '../common';\nimport {NotImplementedError, ValueError} from '../errors';\nimport {DataFormat, Shape} from '../keras_format/common';\nimport {HasShape} from '../types';\nimport * as math_utils from '../utils/math_utils';\n\nimport {imageDataFormat} from './common';\n\n// tslint:enable\n\n/* Setting and getting backend from deeplearn.js. */\n\n// Default deeplearn.js backend is WebGL (GPU).\nlet backend: 'cpu'|'webgl' = 'webgl';\n\nexport function setBackend(requestedBackend: 'cpu'|'webgl') {\n  tfc.setBackend(requestedBackend);\n  backend = requestedBackend;\n}\n\nexport function getBackend(): 'cpu'|'webgl' {\n  return backend;\n}\n\n/**\n * Indicates whether the backend is operating symbolically.\n *\n * This function will be used to determine how to interpret user code. If\n * it returns true, calls to the backend construct a symbolic graph; if\n * it returns false, calls to the backend execute immediately.\n */\nexport function isBackendSymbolic(): boolean {\n  return false;\n}\n\n/**\n * Get the number of elements in a Tensor.\n * @param x The Tensor.\n * @return Number of elements in `x`.\n */\nexport function countParams(x: HasShape): number {\n  const shape = x.shape;\n  if (shape.length > 0) {\n    return shape.reduce((a: number, b: number) => a * b);\n  } else {\n    // Scalar.\n    return 1;\n  }\n}\n\n/**\n * Casts a tensor to a different dtype and returns it.\n * @param x Input tensor.\n * @param dtype String: 'float32'|'int32'|'bool'.\n * @returns Tensor of the specified `dtype`.\n */\nexport function cast(x: Tensor, dtype: tfc.DataType): Tensor {\n  return x.asType(dtype);\n}\n\n/**\n * Adds a 1-sized dimension at index \"axis\".\n * @param x Input tensor.\n * @param axis Position where to add the new axis.\n * @returns Result of the dimension expansion.\n */\nexport function expandDims(x: Tensor, axis = -1): Tensor {\n  const outShape = x.shape.slice();\n  if (axis < 0) {\n    axis = outShape.length + axis + 1;\n  }\n  outShape.splice(axis, 0, 1);\n  return x.reshape(outShape);\n}\n\n/**\n * Repeats a 2D tensor.\n *\n * If `x` has shape `[samples, dim]` and `n` is 2, for example, the output\n * will have shape `[samples, 2, dim]`.\n *\n * @param x Input tensor.\n * @param n Integer, number of times to repeat.\n * @returns The result of the repeat operation.\n * @throws ValueError: If input tensor is not 2D.\n */\nexport function repeat(x: Tensor, n: number): Tensor {\n  return tidy(() => {\n    if (x.shape.length !== 2) {\n      throw new ValueError(\n          `repeat() expects a rank-2 tensor, but received a ` +\n          `rank-${x.shape.length} tensor.`);\n    }\n    const y = expandDims(x, 1);\n    return tile(y, [1, n, 1]);\n  });\n}\n\n/**\n * Flatten an Tensor into 1D.\n * @param x Input tensor.\n * @return The result of the flattening `x`.\n */\nexport function flatten(x: Tensor): Tensor {\n  const newShape = [math_utils.arrayProd(x.shape)];\n  return x.reshape(newShape);\n}\n\n/**\n * Turn a nD tensor into a 2D tensor with same 0th dimension.\n * In other words, it flattens each data samples of a batch.\n *\n * @param x The tensor to flatten. The rank of this tensor is required to be 2\n *   or higher.\n * @return The result of the flattening.\n */\nexport function batchFlatten(x: Tensor): Tensor {\n  if (x.rank <= 1) {\n    throw new ValueError(\n        `batchFlatten requires a minimum rank of 2. Got rank: ${x.rank}.`);\n  }\n  const newShape = [x.shape[0], math_utils.arrayProd(x.shape, 1)];\n  return x.reshape(newShape);\n}\n\n/**\n * Do slicing along the first axis.\n * @param array input `tf.Tensor`.\n * @param start starting index, inclusive.\n * @param size size of the slice along the first axis.\n * @returns result of the slicing.\n * @throws ValueError: If `array` is of an unsupported subtype of `tf.Tensor`.\n */\nexport function sliceAlongFirstAxis(\n    array: Tensor, start: number, size: number): Tensor {\n  return tidy(() => {\n    switch (array.rank) {\n      case 1:\n        return tfc.slice1d(array as Tensor1D, start, size);\n      case 2:\n        return tfc.slice2d(\n            array as Tensor2D, [start, 0], [size, array.shape[1]]);\n      case 3:\n        return tfc.slice3d(\n            array as Tensor3D, [start, 0, 0],\n            [size, array.shape[1], array.shape[2]]);\n      case 4:\n        return tfc.slice4d(\n            array as Tensor4D, [start, 0, 0, 0],\n            [size, array.shape[1], array.shape[2], array.shape[3]]);\n      case 5:\n        return tfc.slice(array as Tensor5D, [start, 0, 0, 0, 0], [\n          size, array.shape[1], array.shape[2], array.shape[3], array.shape[4]\n        ]);\n      case 6:\n        return tfc.slice(array, [start, 0, 0, 0, 0, 0], [\n          size, array.shape[1], array.shape[2], array.shape[3], array.shape[4],\n          array.shape[5]\n        ]);\n      default:\n        throw new ValueError(\n            `sliceAlongFirstAxis() received an unsupported tensor rank: ` +\n            `${array.rank}`);\n    }\n  });\n}\n\n/**\n * Do slicing along the last axis.\n * @param array input `tf.Tensor`.\n * @param start starting index, inclusive.\n * @param size size of the slice along the last axis.\n * @returns result of the slicing.\n * @throws ValueError: If `array` is of an unsupported subtype of `tf.Tensor`.\n */\nexport function sliceAlongLastAxis(\n    array: Tensor, start: number, size: number): Tensor {\n  return tidy(() => {\n    switch (array.rank) {\n      case 1:\n        return tfc.slice1d(array as Tensor1D, start, size);\n      case 2:\n        return tfc.slice2d(\n            array as Tensor2D, [0, start], [array.shape[0], size]);\n      case 3:\n        return tfc.slice3d(\n            array as Tensor3D, [0, 0, start],\n            [array.shape[0], array.shape[1], size]);\n      case 4:\n        return tfc.slice4d(\n            array as Tensor4D, [0, 0, 0, start],\n            [array.shape[0], array.shape[1], array.shape[2], size]);\n      default:\n        throw new ValueError(\n            `sliceAlongLastAxis() received an unsupported tensor rank: ` +\n            `${array.rank}`);\n    }\n  });\n}\n\n/**\n * Do slicing along the sepcified axis.\n * @param array input `tf.Tensor`.\n * @param start starting index, inclusive.\n * @param size of the slice along the chosen axis.\n * @param choose an axis.\n * @returns result of the slicing.\n * @throws ValueError: If `array` is of an unsupported subtype of `tf.Tensor`.\n */\nexport function sliceAlongAxis(\n    array: Tensor, start: number, size: number, axis: number): Tensor {\n  return tidy(() => {\n    switch (array.rank) {\n      case 1:\n        return tfc.slice1d(array as Tensor1D, start, size);\n      case 2:\n        switch (axis) {\n          case 1:\n            return sliceAlongFirstAxis(array, start, size);\n          case 2:\n            return sliceAlongLastAxis(array, start, size);\n          default:\n            throw new ValueError(\n                `The axis is not within the rank of the tensor ` +\n                `${axis}`);\n        }\n      case 3:\n        switch (axis) {\n          case 1:\n            return sliceAlongFirstAxis(array, start, size);\n          case 2:\n            return tfc.slice3d(\n                array as Tensor3D, [0, start, 0],\n                [array.shape[0], size, array.shape[2]]);\n          case 3:\n            return sliceAlongLastAxis(array, start, size);\n          default:\n            throw new ValueError(\n                `The axis is not within the rank of the tensor ` +\n                `${axis}`);\n        }\n      case 4:\n        switch (axis) {\n          case 1:\n            return sliceAlongFirstAxis(array, start, size);\n          case 2:\n            return tfc.slice4d(\n                array as Tensor4D, [0, start, 0, 0],\n                [array.shape[0], size, array.shape[2], array.shape[3]]);\n          case 3:\n            return tfc.slice4d(\n                array as Tensor4D, [0, 0, start, 0],\n                [array.shape[0], array.shape[1], size, array.shape[3]]);\n          case 4:\n            return sliceAlongLastAxis(array, start, size);\n          default:\n            throw new ValueError(\n                `The axis is not within the rank of the tensor ` +\n                `${axis}`);\n        }\n      default:\n        throw new ValueError(\n            `sliceAlongLastAxis() received an unsupported tensor rank: ` +\n            `${array.rank}`);\n    }\n  });\n}\n\n/**\n * Concatenates a list of tensors alongside the specified axis.\n * @param tensors `Array` of tensors to concatenate.\n * @param axis Concatenation axis.\n * @returns The result of the concatenation.\n */\nexport function concatenate(tensors: Tensor[], axis = -1): Tensor {\n  let rank: number;\n  if (axis < 0) {\n    rank = tensors[0].rank;\n    if (rank !== 0) {\n      axis = rank;\n    } else {\n      axis = 0;\n    }\n  }\n  if (axis === tensors[0].rank) {\n    // Porting Note: This is necessary because tfc.concat() requires axis to be\n    //   in the interval [-rank, rank).\n    axis = -1;\n  }\n  // Porting Note: Sparse concat is not supported yet.\n  return tfc.concat(tensors, axis);\n}\n\n/**\n * Concatenate two arrays along the first dimension.\n * @param a The 1st `tf.Tensor` to concatenate.\n * @param b The 2nd `tf.Tensor` to concatenate.\n * @returns Result of the concatenation.\n * @throws ValueError: If `a` is of an unsupported subtype of `tf.Tensor`.\n */\nexport function concatAlongFirstAxis(a: Tensor, b: Tensor): Tensor {\n  switch (a.rank) {\n    case 1:\n      return tfc.concat1d([a as Tensor1D, b as Tensor1D]);\n    case 2:\n      return tfc.concat2d([a as Tensor2D, b as Tensor2D], 0);\n    case 3:\n      return tfc.concat3d([a as Tensor3D, b as Tensor3D], 0);\n    case 4:\n      return tfc.concat4d([a as Tensor4D, b as Tensor4D], 0);\n    default:\n      throw new ValueError(\n          `concatAlongFirstAxis() received an unsupported ` +\n          `tensor rank: ${a.rank}`);\n  }\n}\n\n/**\n * Creates a tensor by tiling `x` by `n`.\n * @param x A tensor.\n * @param n An Array of integers or a single integer. If an Array, the length\n *   must be the same as the number of dimensions in `x`. If a single integer,\n *   it will be treated as an Array of length 1.\n */\nexport function tile(x: Tensor, n: number|number[]): Tensor {\n  if (!Array.isArray(n)) {\n    n = [n];\n  }\n  if (x.rank !== n.length) {\n    throw new ValueError(\n        `The length of input n (${n.length}) does not match ` +\n        `the number of dimensions in input x (${x.rank})`);\n  }\n  return tfc.tile(x, n);\n}\n\n/* Creation of random tensors. */\n\n/**\n * Get a tensor with normal distribution of values.\n *\n * @param shape Shape of the tensor.\n * @param mean mean value of the normal distribution.\n * @param stddev standard deviation of the normal distribution.\n * @param dtype\n * @param seed\n * @return The normal tensor.\n */\nexport function randomNormal(\n    shape: Shape, mean = 0.0, stddev = 1.0, dtype?: 'float32'|'int32',\n    seed?: number): Tensor {\n  return tfc.randomNormal(shape, mean, stddev, dtype, seed);\n}\n\n/* Linear Algebra */\n\n/**\n * Multiply two tensors and returns the result as a tensor.\n *\n * For 2D tensors, this is equivalent to matrix multiplication (matMul).\n * For tensors of higher ranks, it follows the Theano behavior,\n * (e.g. `(2, 3) * (4, 3, 5) -> (2, 4, 5)`).  From the Theano documentation:\n *\n * For N dimensions it is a sum product over the last axis of x and the\n * second-to-last of y:\n *\n * @param a A tensor of at least rank 2.\n * @param b A tensor of at least rank 2.\n * @param activation (optional) A string identifying the activation\n *   function.\n * @return Result of the dot operation.\n */\nexport function dot(\n    a: Tensor, b: Tensor, activation?: tfc.fused.Activation,\n    bias?: Tensor): Tensor {\n  if ((a.rank < 2) || (b.rank < 2)) {\n    throw new NotImplementedError(\n        `dot requires both inputs to be rank >= 2` +\n        ` but got x shape = ${a.shape} and y shape = ${b.shape}`);\n  }\n  if (b.rank >= 3) {\n    const xLastDim = a.shape.slice(-1)[0];\n    const ySecondLastDim = b.shape.slice(-2)[0];\n    if (xLastDim !== ySecondLastDim) {\n      throw new NotImplementedError(\n          `If rank y >= 3, then the second last dim` +\n          ` of y must equal the last dim of x but got x shape = ${\n              a.shape} and ` +\n          ` y shape = ${b.shape}`);\n    }\n  }\n  // Handle basic 2D x 2D case.\n  if ((a.rank === 2) && (b.rank === 2)) {\n    const transposeA = false;\n    const transposeB = false;\n    // tfc.fused.matMul only fuses certain activation functions. Unsupported\n    // activation functions are treated as 'linear' activations, which is\n    // equivalent to a no-op.\n    return tfc.fused.matMul({\n      a,\n      b: b as Tensor2D,\n      transposeA,\n      transposeB,\n      bias: bias ? reshapeBias(a.rank, bias, imageDataFormat()) : null,\n      activation\n    });\n  } else {\n    // Reshape x into the analogous 2D Tensor.\n    const aFirstDims = a.shape.slice();  // Holds all but the last dim of x.\n    const aLastDim = aFirstDims.pop();\n    a = a.reshape([-1, aLastDim]);\n\n    // Reshape y into the analogous 2D Tensor, and keep track of the\n    // required dimensions to reproduce the output shape.\n    const bShape = b.shape.slice();\n    const bLastDim = bShape.pop();\n    const ySecondLastDim = bShape.pop();\n    const yOtherDims = [...bShape, bLastDim];\n    // permutation should be like [r-2, 0, 1, 2, ... r-4, r-3, r-1]\n    // where r is the rank of y.\n    const perm = Array.from({length: b.rank}, (_, i) => {\n      if (i === 0) {\n        return b.rank - 2;\n      } else if (i <= b.rank - 2) {\n        return i - 1;\n      }\n      return i;\n    });\n    b = b.transpose(perm).reshape([ySecondLastDim, -1]);\n\n    // Multiply x and y as 2D Tensors, and then reshape back to original.\n    const outputShape = [...aFirstDims, ...yOtherDims];\n    const transposeA = false;\n    const transposeB = false;\n    return tfc.fused\n        .matMul({\n          a,\n          b,\n          transposeA,\n          transposeB,\n          bias: bias ? reshapeBias(a.rank, bias, imageDataFormat()) : null,\n          activation\n        })\n        .reshape(outputShape);\n  }\n}\n\n/**\n * Compute the sign Tensor of an input Tensor.\n *\n * Elements of the input `tf.Tensor` that are === 0 are mapped to 0.\n * Elements of the input `tf.Tensor` that are > 0 are mapped to 1.\n * Elements of the input `tf.Tensor` that are < 0 are mapped to -1.\n *\n * @param x Input `tf.Tensor`.\n * @return The sign `tf.Tensor`.\n */\nexport function sign(x: Tensor): Tensor {\n  // TODO(cais): Move to the core.\n  return tidy(() => {\n    const zerosLikeX = coreZerosLike(x);\n    const onesLikeX = coreOnesLike(x);\n    return where(\n        tfc.equal(x, zerosLikeX), zerosLikeX,\n        where(\n            tfc.greater(x, coreZerosLike(x)), onesLikeX,\n            tfc.mul(-1, onesLikeX)));\n  });\n}\n\n/**\n * Computes the one-hot representation of an integer tensor.\n * @param indices nD integer tensor of shape\n *   `(batch_size, dim1, dim2, ... dim(n-1))`\n * @param numClasses Integer, number of classes to consider.\n * @returns (n + 1)D one hot representation of the input\n *   with shape `(batch_size, dim1, dim2, ... dim(n-1), num_classes)`\n */\nexport function oneHot(indices: Tensor, numClasses: number): Tensor {\n  return tidy(() => {\n    if (indices.rank !== 1) {\n      throw new Error(\n          'Only 1D one-hot tensors are supported in the ' +\n          'deeplearn backend, at present.');\n    }\n    indices = indices.toInt();\n    return tfc.oneHot(indices as Tensor1D, numClasses).toFloat();\n  });\n}\n\n/* Elementary math functions. */\n\n/**\n * Retrieves the elements of indices `indices` in the tensor `reference`.\n * @param reference A tensor.\n * @param indices An integer tensor of indices or an `Array` of integers.\n * @param axis Axis along which to perform the gather operation.\n * @returns The result of the gathering as a tensor.\n */\nexport function gather(\n    reference: Tensor, indices: number[]|Tensor1D, axis?: number): Tensor {\n  return tidy(() => {\n    if (Array.isArray(indices)) {\n      indices = tensor1d(indices, 'int32');\n    } else {\n      indices = indices.toInt();\n    }\n    return tfc.gather(reference, indices, axis);\n  });\n}\n\n/**\n * Element-wise square.\n * @param x Input tensor.\n * @return element-wise x^2\n */\nexport function square(x: Tensor): Tensor {\n  return tfc.mulStrict(x, x);\n}\n\n/**\n * Element-wise exponentiation.\n *\n * Porting Note: In PyKeras, `a` (the exponent) is a Python integer, which\n *   takes advatnage of the backend's (e.g., TensorFlow's) automatic\n * conversion to tensor. Here we allow `a` to be either a number or a tensor.\n *\n * @param x The base tensor.\n * @param a The exponent, tensor or number. If a number, it is rounded to the\n *   nearest integer and converted to a tensor.\n * @returns A tensor of the same shape as `x`.\n */\nexport function pow(x: Tensor, a: Tensor|number): Tensor {\n  return tidy(() => {\n    if (typeof (a) === 'number') {\n      a = scalar(Math.round(a), 'int32');\n    }\n    if (a.dtype !== 'int32') {\n      throw new NotImplementedError(\n          `Non-int32 dtype (${a.dtype}) is not supported by pow() yet`);\n    }\n    return tfc.pow(x, a);\n  });\n}\n\n/**\n * Reshapes bias tensor according to rank of x.\n */\nfunction reshapeBias(xRank: number, bias: Tensor, dataFormat: string) {\n  const biasShape = bias.shape;\n\n  if (bias.rank !== 1 && bias.rank !== xRank) {\n    throw new ValueError(\n        `Unexpected bias dimensions: ${bias.rank}` +\n        `; expected it to be 1 or ${xRank}`);\n  }\n\n  if (xRank === 5) {\n    if (dataFormat === 'channelsFirst') {\n      if (biasShape.length === 1) {\n        return bias.reshape([1, biasShape[0], 1, 1, 1]);\n      } else {\n        return bias.reshape(\n            [1, biasShape[3], biasShape[0], biasShape[1], biasShape[2]]);\n      }\n    } else if (dataFormat === 'channelsLast') {\n      if (biasShape.length === 1) {\n        return bias.reshape([1, 1, 1, 1, biasShape[0]]);\n      } else {\n        return bias.reshape([1].concat(biasShape));\n      }\n    }\n  } else if (xRank === 4) {\n    if (dataFormat === 'channelsFirst') {\n      if (biasShape.length === 1) {\n        return bias.reshape([1, biasShape[0], 1, 1]);\n      } else {\n        return bias.reshape([1, biasShape[2], biasShape[0], biasShape[1]]);\n      }\n    } else if (dataFormat === 'channelsLast') {\n      if (biasShape.length === 1) {\n        return bias.reshape([1, 1, 1, biasShape[0]]);\n      } else {\n        return bias.reshape([1].concat(biasShape));\n      }\n    }\n  } else if (xRank === 3) {\n    if (dataFormat === 'channelsFirst') {\n      if (biasShape.length === 1) {\n        return bias.reshape([1, biasShape[0], 1]);\n      } else {\n        return bias.reshape([1, biasShape[1], biasShape[0]]);\n      }\n    } else if (dataFormat === 'channelsLast') {\n      if (biasShape.length === 1) {\n        return bias.reshape([1, 1, biasShape[0]]);\n      } else {\n        return bias.reshape([1].concat(biasShape));\n      }\n    }\n  } else if (xRank < 3) {\n    return bias;\n  }\n  throw new ValueError(`Unsupported input rank by biasAdd: ${bias.rank}`);\n}\n\n/* Neural-network operations. */\n\n/**\n * Add a bias to a tensor.\n *\n * @param x The tensor to add the bias to.\n * @param bias The bias to add to `x`. Must be 1D or the same rank as `x`.\n * @return Result of the bias adding.\n * @throws ValueError: If the rank of `bias` is incorrect.\n */\nexport function biasAdd(\n    x: Tensor, bias: Tensor, dataFormat?: DataFormat): Tensor {\n  return tidy(() => {\n    if (dataFormat == null) {\n      dataFormat = imageDataFormat();\n    }\n    checkDataFormat(dataFormat);\n\n    return x.add(reshapeBias(x.rank, bias, dataFormat));\n  });\n}\n\n/**\n * Exponential linear unit (ELU).\n * @param x A tensor or variable to compute the activation function for.\n * @param alpha: A scalar, a scaling factor for the negative section.\n * @return Output of the ELU operation.\n */\nexport function elu(x: Tensor, alpha = 1): Tensor {\n  // TODO(cais): Add support for alpha values other than 1.\n  if (alpha !== 1) {\n    throw new NotImplementedError(\n        `Support for alpha values other than 1 (${alpha}) is not implemented ` +\n        `yet.`);\n  }\n  return tfc.elu(x);\n}\n\n/**\n * Softsign of a tensor.\n *\n * Defined as x / (abs(x) + 1), element-wise.\n *\n * @param x: Input.\n * @returns Output.\n */\nexport function softsign(x: Tensor): Tensor {\n  return tidy(() => tfc.div(x, tfc.abs(x).add(1)));\n}\n\n/**\n * Sets entries in `x` to zero at random, while scaling the entire tensor.\n *\n * @param x input tensor.\n * @param level fraction of the entries in the tensor that will be set to 0.\n * @param noiseShape shape of randomly generated keep/drop flags, must be\n *   broadcastable to the shape of `x`. Optional.\n * @param seed random seed to ensure determinism. Optional.\n * @returns Result of the dropout operation.\n */\nexport function dropout(\n    x: Tensor, level: number, noiseShape?: number[], seed?: number): Tensor {\n  return tidy(() => tfc.dropout(x, level, noiseShape, seed));\n}\n\n/**\n * Element-wise, segment-wise linear approximation of sigmoid.\n *\n * Returns `0.` if `x < -2.5`, `1.` if `x > 2.5`.\n * In `-2.5 <= x <= 2.5`, returns `0.2 * x + 0.5`.\n *\n * @param x Input tensor.\n * @returns Output tensor.\n */\nexport function hardSigmoid(x: Tensor): Tensor {\n  return tidy(() => {\n    const y = tfc.add(.5, tfc.mul(.2, x));\n    return tfc.clipByValue(y, 0, 1);\n  });\n}\n\n/**\n * Invoke `x` in the training phase, and `alt` otherwise.\n *\n * Porting Note: We do not create placeholder tensors for the `training`\n * boolean flag here, because there is no such thing in the TF.js imperative\n * backend.\n *\n * @param x The function to invoke iff `training` is `true`.\n * @param alt The function to invoke iff `training` is `false`.\n * @param training Boolean flag for whether training phase is active.\n * @returns The return value of `x()` if `training` is `true`, or the return\n *   value of `alt()` if `training` is `false`.\n */\nexport function inTrainPhase<T>(x: () => T, alt: () => T, training = false): T {\n  return training ? x() : alt();\n}\n"]}},"error":null,"hash":"6c2501a2f49096ac22adc8f37b7b6713","cacheData":{"env":{}}}