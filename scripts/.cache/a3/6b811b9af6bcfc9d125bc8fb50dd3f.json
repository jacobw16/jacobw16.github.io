{"id":"node_modules/@tensorflow/tfjs-layers/dist/utils/layer_utils.js","dependencies":[{"name":"C:\\Users\\Jacob\\Documents\\jump(3)\\scripts\\node_modules\\@tensorflow\\tfjs-layers\\dist\\utils\\layer_utils.js.map","includedInParent":true,"mtime":499162500000},{"name":"C:\\Users\\Jacob\\Documents\\jump(3)\\scripts\\node_modules\\@tensorflow\\tfjs-layers\\src\\utils\\layer_utils.ts","includedInParent":true,"mtime":499162500000},{"name":"C:\\Users\\Jacob\\Documents\\jump(3)\\scripts\\package.json","includedInParent":true,"mtime":1581896610560},{"name":"C:\\Users\\Jacob\\Documents\\jump(3)\\scripts\\node_modules\\@tensorflow\\tfjs-layers\\package.json","includedInParent":true,"mtime":1581030261368},{"name":"./variable_utils","loc":{"line":12,"column":31},"parent":"C:\\Users\\Jacob\\Documents\\jump(3)\\scripts\\node_modules\\@tensorflow\\tfjs-layers\\dist\\utils\\layer_utils.js","resolved":"C:\\Users\\Jacob\\Documents\\jump(3)\\scripts\\node_modules\\@tensorflow\\tfjs-layers\\dist\\utils\\variable_utils.js"}],"generated":{"js":"\"use strict\";\n/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar variable_utils_1 = require(\"./variable_utils\");\n/**\n * Print the summary of a LayersModel object.\n *\n * @param model tf.LayersModel instance.\n * @param lineLength Total length of printed lines. Set this to adapt to the\n *   display to different terminal or console sizes.\n * @param positions Relative or absolute positions of log elements in each\n *   line. Each number corresponds to right-most (i.e., ending) position of a\n *   column.\n *   If not provided, defaults to `[0.45, 0.85, 1]` for sequential-like\n *   models and `[0.33, 0.55, 0.67, 1]` for non-sequential like models.\n * @param printFn Print function to use.\n *   It will be called on each line of the summary. You can provide a custom\n *   function in order to capture the string summary. Defaults to `console.log`.\n */\nfunction printSummary(model, lineLength, positions, \n// tslint:disable-next-line:no-any\nprintFn) {\n    if (printFn === void 0) { printFn = console.log; }\n    var sequentialLike = isModelSequentialLike(model);\n    // Header names for different log elements.\n    var toDisplay = ['Layer (type)', 'Output shape', 'Param #'];\n    if (sequentialLike) {\n        lineLength = lineLength || 65;\n        positions = positions || [0.45, 0.85, 1];\n    }\n    else {\n        lineLength = lineLength || 98;\n        positions = positions || [0.33, 0.55, 0.67, 1];\n        // Header names for different log elements.\n    }\n    if (positions[positions.length - 1] <= 1) {\n        // `positions` is relative. Convert it to absolute positioning.\n        positions = positions.map(function (p) { return Math.floor(lineLength * p); });\n    }\n    var relevantNodes;\n    if (!sequentialLike) {\n        toDisplay.push('Receives inputs');\n        relevantNodes = [];\n        for (var depth in model.nodesByDepth) {\n            relevantNodes.push.apply(relevantNodes, model.nodesByDepth[depth]);\n        }\n    }\n    printFn('_'.repeat(lineLength));\n    printRow(toDisplay, positions, printFn);\n    printFn('='.repeat(lineLength));\n    var layers = model.layers;\n    for (var i = 0; i < layers.length; ++i) {\n        if (sequentialLike) {\n            printLayerSummary(layers[i], positions, printFn);\n        }\n        else {\n            printLayerSummaryWithConnections(layers[i], positions, relevantNodes, printFn);\n        }\n        printFn((i === layers.length - 1 ? '=' : '_').repeat(lineLength));\n    }\n    // tslint:disable-next-line:no-any\n    model.checkTrainableWeightsConsistency();\n    var trainableCount = countTrainableParams(model);\n    var nonTrainableCount = variable_utils_1.countParamsInWeights(model.nonTrainableWeights);\n    printFn(\"Total params: \" + (trainableCount + nonTrainableCount));\n    printFn(\"Trainable params: \" + trainableCount);\n    printFn(\"Non-trainable params: \" + nonTrainableCount);\n    printFn('_'.repeat(lineLength));\n}\nexports.printSummary = printSummary;\nfunction countTrainableParams(model) {\n    var trainableCount;\n    // tslint:disable:no-any\n    if (model.collectedTrainableWeights != null) {\n        trainableCount =\n            variable_utils_1.countParamsInWeights(model.collectedTrainableWeights);\n    }\n    else {\n        trainableCount = variable_utils_1.countParamsInWeights(model.trainableWeights);\n    }\n    // tslint:enable:no-any\n    return trainableCount;\n}\nfunction isModelSequentialLike(model) {\n    var sequentialLike = true;\n    var nodesByDepth = [];\n    var nodes = [];\n    for (var depth in model.nodesByDepth) {\n        nodesByDepth.push(model.nodesByDepth[depth]);\n    }\n    for (var _i = 0, nodesByDepth_1 = nodesByDepth; _i < nodesByDepth_1.length; _i++) {\n        var depthNodes = nodesByDepth_1[_i];\n        if (depthNodes.length > 1 ||\n            depthNodes.length === 1 && depthNodes[0].inboundLayers.length > 1) {\n            sequentialLike = false;\n            break;\n        }\n        nodes.push.apply(nodes, depthNodes);\n    }\n    if (sequentialLike) {\n        // Search for shared layers.\n        for (var _a = 0, _b = model.layers; _a < _b.length; _a++) {\n            var layer = _b[_a];\n            var flag = false;\n            for (var _c = 0, _d = layer.inboundNodes; _c < _d.length; _c++) {\n                var node = _d[_c];\n                if (nodes.indexOf(node) !== -1) {\n                    if (flag) {\n                        sequentialLike = false;\n                        break;\n                    }\n                    else {\n                        flag = true;\n                    }\n                }\n            }\n            if (!sequentialLike) {\n                break;\n            }\n        }\n    }\n    return sequentialLike;\n}\nfunction printRow(fields, positions, \n// tslint:disable-next-line:no-any\nprintFn) {\n    if (printFn === void 0) { printFn = console.log; }\n    var line = '';\n    for (var i = 0; i < fields.length; ++i) {\n        if (i > 0) {\n            line = line.slice(0, line.length - 1) + ' ';\n        }\n        line += fields[i];\n        line = line.slice(0, positions[i]);\n        line += ' '.repeat(positions[i] - line.length);\n    }\n    printFn(line);\n}\n/**\n * Prints a summary for a single Layer, without connectivity information.\n *\n * @param layer: Layer instance to print.\n */\nfunction printLayerSummary(layer, positions, \n// tslint:disable-next-line:no-any\nprintFn) {\n    var outputShape;\n    try {\n        outputShape = JSON.stringify(layer.outputShape);\n    }\n    catch (err) {\n        outputShape = 'multiple';\n    }\n    var name = layer.name;\n    var className = layer.getClassName();\n    var fields = [name + \" (\" + className + \")\", outputShape, layer.countParams().toString()];\n    printRow(fields, positions, printFn);\n}\n/**\n * Prints a summary for a single Layer, with connectivity information.\n */\nfunction printLayerSummaryWithConnections(layer, positions, relevantNodes, \n// tslint:disable-next-line:no-any\nprintFn) {\n    var outputShape;\n    try {\n        outputShape = JSON.stringify(layer.outputShape);\n    }\n    catch (err) {\n        outputShape = 'multiple';\n    }\n    var connections = [];\n    for (var _i = 0, _a = layer.inboundNodes; _i < _a.length; _i++) {\n        var node = _a[_i];\n        if (relevantNodes != null && relevantNodes.length > 0 &&\n            relevantNodes.indexOf(node) === -1) {\n            continue;\n        }\n        for (var i = 0; i < node.inboundLayers.length; ++i) {\n            var inboundLayer = node.inboundLayers[i].name;\n            var inboundLayerIndex = node.nodeIndices[i];\n            var inboundTensorIndex = node.tensorIndices[i];\n            connections.push(inboundLayer + \"[\" + inboundLayerIndex + \"][\" + inboundTensorIndex + \"]\");\n        }\n    }\n    var name = layer.name;\n    var className = layer.getClassName();\n    var firstConnection = connections.length === 0 ? '' : connections[0];\n    var fields = [\n        name + \" (\" + className + \")\", outputShape, layer.countParams().toString(),\n        firstConnection\n    ];\n    printRow(fields, positions, printFn);\n    for (var i = 1; i < connections.length; ++i) {\n        printRow(['', '', '', connections[i]], positions, printFn);\n    }\n}\n"},"sourceMaps":{"js":{"version":3,"file":"layer_utils.js","sourceRoot":"","sources":["../../src/utils/layer_utils.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n\nimport {Container} from '../engine/container';\nimport {Layer, Node} from '../engine/topology';\nimport {countParamsInWeights} from './variable_utils';\n\n/**\n * Print the summary of a LayersModel object.\n *\n * @param model tf.LayersModel instance.\n * @param lineLength Total length of printed lines. Set this to adapt to the\n *   display to different terminal or console sizes.\n * @param positions Relative or absolute positions of log elements in each\n *   line. Each number corresponds to right-most (i.e., ending) position of a\n *   column.\n *   If not provided, defaults to `[0.45, 0.85, 1]` for sequential-like\n *   models and `[0.33, 0.55, 0.67, 1]` for non-sequential like models.\n * @param printFn Print function to use.\n *   It will be called on each line of the summary. You can provide a custom\n *   function in order to capture the string summary. Defaults to `console.log`.\n */\nexport function printSummary(\n    model: Container, lineLength?: number, positions?: number[],\n    // tslint:disable-next-line:no-any\n    printFn: (message?: any, ...optionalParams: any[]) => void =\n        console.log): void {\n  const sequentialLike = isModelSequentialLike(model);\n\n  // Header names for different log elements.\n  const toDisplay: string[] = ['Layer (type)', 'Output shape', 'Param #'];\n  if (sequentialLike) {\n    lineLength = lineLength || 65;\n    positions = positions || [0.45, 0.85, 1];\n  } else {\n    lineLength = lineLength || 98;\n    positions = positions || [0.33, 0.55, 0.67, 1];\n    // Header names for different log elements.\n  }\n\n  if (positions[positions.length - 1] <= 1) {\n    // `positions` is relative. Convert it to absolute positioning.\n    positions = positions.map(p => Math.floor(lineLength * p));\n  }\n\n  let relevantNodes: Node[];\n  if (!sequentialLike) {\n    toDisplay.push('Receives inputs');\n    relevantNodes = [];\n    for (const depth in model.nodesByDepth) {\n      relevantNodes.push(...model.nodesByDepth[depth]);\n    }\n  }\n\n  printFn('_'.repeat(lineLength));\n  printRow(toDisplay, positions, printFn);\n  printFn('='.repeat(lineLength));\n\n  const layers = model.layers;\n  for (let i = 0; i < layers.length; ++i) {\n    if (sequentialLike) {\n      printLayerSummary(layers[i], positions, printFn);\n    } else {\n      printLayerSummaryWithConnections(\n          layers[i], positions, relevantNodes, printFn);\n    }\n    printFn((i === layers.length - 1 ? '=' : '_').repeat(lineLength));\n  }\n\n  // tslint:disable-next-line:no-any\n  (model as any).checkTrainableWeightsConsistency();\n\n  const trainableCount = countTrainableParams(model);\n  const nonTrainableCount = countParamsInWeights(model.nonTrainableWeights);\n\n  printFn(`Total params: ${trainableCount + nonTrainableCount}`);\n  printFn(`Trainable params: ${trainableCount}`);\n  printFn(`Non-trainable params: ${nonTrainableCount}`);\n  printFn('_'.repeat(lineLength));\n}\n\nfunction countTrainableParams(model: Container): number {\n  let trainableCount: number;\n  // tslint:disable:no-any\n  if ((model as any).collectedTrainableWeights != null) {\n    trainableCount =\n        countParamsInWeights((model as any).collectedTrainableWeights);\n  } else {\n    trainableCount = countParamsInWeights(model.trainableWeights);\n  }\n  // tslint:enable:no-any\n  return trainableCount;\n}\n\nfunction isModelSequentialLike(model: Container): boolean {\n  let sequentialLike = true;\n  const nodesByDepth: Node[][] = [];\n  const nodes: Node[] = [];\n  for (const depth in model.nodesByDepth) {\n    nodesByDepth.push(model.nodesByDepth[depth]);\n  }\n  for (const depthNodes of nodesByDepth) {\n    if (depthNodes.length > 1 ||\n        depthNodes.length === 1 && depthNodes[0].inboundLayers.length > 1) {\n      sequentialLike = false;\n      break;\n    }\n    nodes.push(...depthNodes);\n  }\n  if (sequentialLike) {\n    // Search for shared layers.\n    for (const layer of model.layers) {\n      let flag = false;\n      for (const node of layer.inboundNodes) {\n        if (nodes.indexOf(node) !== -1) {\n          if (flag) {\n            sequentialLike = false;\n            break;\n          } else {\n            flag = true;\n          }\n        }\n      }\n      if (!sequentialLike) {\n        break;\n      }\n    }\n  }\n  return sequentialLike;\n}\n\nfunction printRow(\n    fields: string[], positions: number[],\n    // tslint:disable-next-line:no-any\n    printFn: (message?: any, ...optionalParams: any[]) => void = console.log) {\n  let line = '';\n  for (let i = 0; i < fields.length; ++i) {\n    if (i > 0) {\n      line = line.slice(0, line.length - 1) + ' ';\n    }\n    line += fields[i];\n    line = line.slice(0, positions[i]);\n    line += ' '.repeat(positions[i] - line.length);\n  }\n  printFn(line);\n}\n\n/**\n * Prints a summary for a single Layer, without connectivity information.\n *\n * @param layer: Layer instance to print.\n */\nfunction printLayerSummary(\n    layer: Layer, positions: number[],\n    // tslint:disable-next-line:no-any\n    printFn: (message?: any, ...optionalParams: any[]) => void) {\n  let outputShape: string;\n  try {\n    outputShape = JSON.stringify(layer.outputShape);\n  } catch (err) {\n    outputShape = 'multiple';\n  }\n\n  const name = layer.name;\n  const className = layer.getClassName();\n  const fields: string[] =\n      [`${name} (${className})`, outputShape, layer.countParams().toString()];\n  printRow(fields, positions, printFn);\n}\n\n/**\n * Prints a summary for a single Layer, with connectivity information.\n */\nfunction printLayerSummaryWithConnections(\n    layer: Layer, positions: number[], relevantNodes: Node[],\n    // tslint:disable-next-line:no-any\n    printFn: (message?: any, ...optionalParams: any[]) => void) {\n  let outputShape: string;\n  try {\n    outputShape = JSON.stringify(layer.outputShape);\n  } catch (err) {\n    outputShape = 'multiple';\n  }\n\n  const connections: string[] = [];\n  for (const node of layer.inboundNodes) {\n    if (relevantNodes != null && relevantNodes.length > 0 &&\n        relevantNodes.indexOf(node) === -1) {\n      continue;\n    }\n    for (let i = 0; i < node.inboundLayers.length; ++i) {\n      const inboundLayer = node.inboundLayers[i].name;\n      const inboundLayerIndex = node.nodeIndices[i];\n      const inboundTensorIndex = node.tensorIndices[i];\n      connections.push(\n          `${inboundLayer}[${inboundLayerIndex}][${inboundTensorIndex}]`);\n    }\n  }\n  const name = layer.name;\n  const className = layer.getClassName();\n  const firstConnection = connections.length === 0 ? '' : connections[0];\n  const fields: string[] = [\n    `${name} (${className})`, outputShape, layer.countParams().toString(),\n    firstConnection\n  ];\n\n  printRow(fields, positions, printFn);\n  for (let i = 1; i < connections.length; ++i) {\n    printRow(['', '', '', connections[i]], positions, printFn);\n  }\n}\n"]}},"error":null,"hash":"306713170dc7f3632f3cd1374864a86c","cacheData":{"env":{}}}